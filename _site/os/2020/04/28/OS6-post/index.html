
<!doctype html>














<html class="theme-next muse use-motion" lang="ko">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/assets/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/assets/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/assets/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="OS," />





  <link rel="alternate" href="/atom.xml" title="Ko" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/assets/favicon.ico?v=5.1.1" />
















<meta name="description" content="김덕수 교수님의 OS강의 Lecture 6">
<meta name="keywords" content="OS">
<meta property="og:type" content="article">
<meta property="og:title" content="OS Lecture 6">
<meta property="og:url" content="http://localhost:4000/os/2020/04/28/OS6-post/">
<meta property="og:site_name" content="Ko">
<meta property="og:description" content="김덕수 교수님의 OS강의 Lecture 6">
<meta property="og:locale" content="ko">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OS Lecture 6">
<meta name="twitter:description" content="김덕수 교수님의 OS강의 Lecture 6">


<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '작성자'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://localhost:4000/"/>





  <title>OS Lecture 6 | Ko</title>
  
















</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="ko">

  
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ko</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            홈
          </a>
        </li>
      
        
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            아카이브
          </a>
        </li>
      
        
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            태그
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    TeX: {
      equationNumbers: {
        autoNumber: "AMS"
      }
    },
    tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$'] ],
    processEscapes: true,
  }
});
MathJax.Hub.Register.MessageHook("Math Processing Error",function (message) {
	  alert("Math Processing Error: "+message[1]);
	});
MathJax.Hub.Register.MessageHook("TeX Jax - parse error",function (message) {
	  alert("Math Processing Error: "+message[1]);
	});
</script>
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script src="https://cdn.jsdelivr.net/npm/mermaid@8.4.0/dist/mermaid.js"></script>
<script>mermaid.initialize({startOnLoad:true});</script>



<div id="posts" class="posts-expand">
  
  

  

  
  
  

  <article class="post post-type- " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/os/2020/04/28/OS6-post/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="고중범">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="assets/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ko">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
          
          
            OS Lecture 6
          
        </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">작성일</span>
              
              <time title="" itemprop="dateCreated datePublished" datetime="2020-04-28T21:00:00+09:00">
                2020-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/category/#/OS" itemprop="url" rel="index">
                    <span itemprop="name">OS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          
            
          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
  
  












  <p>유튜브 <a href="https://www.youtube.com/channel/UCHvXywxOtwLedY5OX-Teg5w">HPC Lab. KOREATECH 채널</a>, 김덕수 교수님의 OS 강의를 보고 정리한 내용입니다.</p>

<hr />

<h1 id="lecture-6">Lecture 6</h1>

<h1 id="process-synchronization">Process Synchronization</h1>

<p>다중 프로그래밍 시스템 환경 (Multi-Programming)</p>

<ul>
  <li>Process가 여러개이다.</li>
  <li>Process들은 서로 독립적으로, 동시에 동작한다.</li>
  <li>공유 자원 또는 데이터가 있을 때, 문제가 발생한다.</li>
</ul>

<p><strong>다중프로그램 시스템 환경에서 Error가 발생하지 않으려면 프로세스끼리의 ‘대화’ 또는 ‘협약’이 필요하다.</strong></p>

<p><strong>-&gt; 동기화가 필요하다.</strong></p>

<p><strong>Synchronization (동기화)</strong></p>

<ul>
  <li>프로세스들이 서로 동작을 맞추는 것</li>
  <li>프로세스들이 서로 정보를 공유하는 것</li>
</ul>

<h2 id="asynchronous-and-concurrent-ps">Asynchronous and Concurrent P’s</h2>

<p><strong>Asynchronous</strong> (비동기화)</p>

<ul>
  <li>프로세스들이 서로 대화를 안하고 개인행동하는 경우</li>
</ul>

<p><strong>Concurrent</strong> (병행)</p>

<ul>
  <li>여러 프로세스들이 동시에 동작하는 경우</li>
</ul>

<p><strong>‘병행’ 수행중인 ‘비동기적’인 프로세스들이 공유 자원에 동시에 접근하면 문제 발생</strong></p>

<p>-&gt; 프로세스간의 대화없이 같은 공간에 작업하게 되면 문제가 발생한다. (위에서 말했던 에러가 발생하는 원인)</p>

<h2 id="terminologies">Terminologies</h2>

<ul>
  <li><strong>Shared data (공유 데이터)</strong>
    <ul>
      <li>여러 프로세스들이 공유하는 데이터</li>
    </ul>
  </li>
  <li><strong>Critical section (CS, 임계 영역)</strong>
    <ul>
      <li>Shared data를 접근하는 코드 영역</li>
    </ul>
  </li>
  <li><strong>Mutual exclusion (상호배제)</strong>
    <ul>
      <li>둘 이상의 프로세스가 동시에 CS에 진입하지 못하도록 막는 것</li>
    </ul>
  </li>
</ul>

<h2 id="critical-section">Critical Section</h2>

<p>사용자가 작성한 Code는 Compiler에 의해 <strong>Machine instruction (기계어 명령)</strong>로 바뀐다.</p>

<blockquote>
  <p><strong>Machine Instructions are commands or programs written in machine code of a machine (computer) that it can recognize and execute.</strong></p>
</blockquote>

<ul>
  <li>
    <p><strong>Atomicity</strong> : 쪼갤 수 없다. 중간에 방해할 수 없다.</p>
  </li>
  <li>
    <p><strong>Individible</strong> : 분리가 불가능하다</p>

    <p>-&gt; 명령 실행 도중에 Interrupt를 받지 않는것이 보장된다. (Non-preemption)</p>
  </li>
</ul>

<p>예를 들어, 2개의 Process가 shared data에 동시에 1을 더하려고 할 때, <strong>결과는 기계어 명령 수행 과정에 따라서 1또는 2로 달라질 수 있다.</strong></p>

<p>-&gt; 이런 상태를 <strong>Race condition</strong>이라고 한다. (동시에 접근할 때 자료의 일관성을 해치는 결과가 나타날 수 있다.)</p>

<h2 id="mutual-exclusion-상호배제">Mutual Exclusion (상호배제)</h2>

<p>: 한 Process가 Critical section에 대해서 실행되는 동안, 다른 Process가 못들어오게 막는 것이다. (항상 원하는 결과를 도출하기 위해 지켜져야하는 규칙 중 하나!)</p>

<h2 id="mutual-exclusion-methods">Mutual Exclusion Methods</h2>

<ul>
  <li><strong>Mutual exclusion primitives</strong>
    <ul>
      <li><strong>enterCS() primitive</strong>
        <ul>
          <li>Critical section 진입 전 검사 (안에 다른 Process가 있는지 검사한다.)</li>
        </ul>
      </li>
      <li><strong>exitCS( primitive)</strong>
        <ul>
          <li>Critical section을 벗어났음을 시스템에 알린다. (후처리 과정)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>primitives란 보통 가장 기본이 되는 연산을 의미한다. 위 연산들을 구현해야하는데, 조건이 있다.</p>

<h3 id="requirements-for-me-primitives">Requirements for ME primitives</h3>

<p>구현을 할 때, 만족해야할 조건 3가지가 있다.</p>

<ul>
  <li><strong>Mutual exclusion (상호배제)</strong>
    <ul>
      <li>CS에 있으면 못들어오게 한다.</li>
    </ul>
  </li>
  <li><strong>Progress (진행)</strong>
    <ul>
      <li>CS에 아무도 없으면 들어갈 수 있도록 해야된다. (방해하면 안된다.)</li>
    </ul>
  </li>
  <li><strong>Bounded waiting (한정대기)</strong>
    <ul>
      <li>제한시간 내에 CS로 들어갈 수 있어야 된다.</li>
    </ul>
  </li>
</ul>

<h2 id="sw-solutions">SW Solutions</h2>

<h3 id="two-process-mutual-exclusion">Two Process Mutual Exclusion</h3>

<h4 id="첫번째-시도"><strong>첫번째 시도</strong></h4>

<p>: Turn을 사용해서 구현한다. (유희왕, 하스스톤같은 게임의 Turn하고 똑같음)</p>

<ol>
  <li>Process A, Process B가 있다.</li>
  <li>Turn이 0이면  A의 차례, Turn이 1이면 B의 차례다.</li>
  <li><strong>자신의 차례가 오면 일을하고, 나올때 상대에게 차례를 넘겨준다.</strong></li>
</ol>

<p>위와 같은 순서로 진행된다.</p>

<p>조건을 만족하는지 체크해보면, <strong>Progress의 조건을 만족하지 못한다.</strong></p>

<ul>
  <li>Process A가 뻉뻉돌다가 죽어버리면 Turn을 넘겨받지 못해서 CS가 비었음에도 들어가지 못하게 된다.
    <ul>
      <li>상대에게 차례를 넘겨주지 못할 때</li>
    </ul>
  </li>
  <li>한 Process가 두 번 연속 CS에 진입 불가하다. (다른 프로세스에게 Turn을 넘겨받아야만 하기 때문이다.)</li>
</ul>

<p>아쉽게도 조건을 위배한다.</p>

<h4 id="두번째-시도"><strong>두번째 시도</strong></h4>

<p>: Flag를 사용하여 구현한다.</p>

<p>CS에 들어갈꺼면 깃발을 들고, 나왔으면 깃발을 내린다.</p>

<ol>
  <li>2개의 Process가 있다.</li>
  <li>상대편의 깃발을 본다
    <ul>
      <li>들려있으면? -&gt; 기다린다.</li>
      <li>내려가있으면? -&gt; 들어간다.</li>
    </ul>
  </li>
  <li>내 일이 끝나면 깃발을 내리고 나온다.</li>
  <li>상대편이 내려간 내 깃발을 보고 들어온다.</li>
</ol>

<p>위와 같은 순서로 진행된다.</p>

<p>조건을 만족하는지 체크해보면, 내 깃발은 내려가 있는 상태고, 상대 깃발이 내려가 있는걸 보고 깃발을 들려고 하는데 Preemption된 경우에</p>

<ul>
  <li>상대가 와서 내 깃발이 내려가있는걸 보고 먼저 CS로 들어간다.</li>
  <li>나는 다시 자원할당받아서 하려던거 마저 하기위해 CS로 들어간다.</li>
</ul>

<p>-&gt; Mutual exclusion 조건에 위배한다.</p>

<p>상대 깃발을 체크하고, CS에 들어가기 직전에 깃발을 들어서 문제가 된다.</p>

<p>여기서 착각하면 안되는 것은, 위에서 Machine instruction이 Atomicity한 특성을 가지고 있고, 중간에 Preemption이 일어날 수 없다고 했는데, Code의 줄 사이사이에서 Preemption이 일어난다. 예를들어,</p>

<div class="language-c highlighter-rouge"><div class="highlight"><table style="margin: 0px"><tbody><tr><td class="gutter"><pre>1<br/>2<br/>3</pre></td><td class="code"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="c1">// Preemption 발생
</span><span class="n">b</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
</code></pre></td></tr></tbody></table></div></div>

<p>이런 Code가 있다고 했을 때, a=3을 수행하고, b=4를 수행하려는데 Preemption이 발생할 수도 있다는 것이다.</p>

<h4 id="세번째-시도"><strong>세번째 시도</strong></h4>

<p>: 두번째와 비슷한데 순서가 다르다. 이번에는 들어갈거라고 먼저 깃발을 든다. (깃발을 먼저 들고, 상대를 체크하는 순서로 바뀌었다.)</p>

<p>Progress, Bounded waiting 조건을 위반한다.</p>

<ul>
  <li>2개의 프로세스가 동시에 왔다가 서로 깃발을 올린것을 보고 아무도 안들어갈 수도 있다.</li>
</ul>

<h3 id="mutual-exclusion-solutions">Mutual Exclusion Solutions</h3>

<h4 id="dekkers-algorithm">Dekker’s Algorithm</h4>

<ul>
  <li>Process가 2개일 때, Mutual exclusion을 보장하는 최초의 알고리즘이다.</li>
  <li>Flag와 Turn을 동시에 쓴다.</li>
</ul>

<p><strong>순서</strong></p>

<ol>
  <li>2개의 Process가 있다.</li>
  <li>Process 하나가 깃발을 든다.
    <ul>
      <li><strong>상대가 깃발을 안 들고 있다면 바로 CS로 들어간다.</strong></li>
      <li>상대가 깃발을 들었다면 Turn을 체크한다.</li>
    </ul>
  </li>
  <li>Turn을 체크한 다음 내 Turn이 아니면 깃발을 내리고 Turn이 돌아오기를 기다린다.</li>
  <li><strong>일을 하고나서 CS에서 빠져나오면서 Turn을 넘긴다.</strong></li>
  <li>나머지 Process가 들어가서 일한다.</li>
</ol>

<p>앞선 시도와 다른점은 상대가 깃발을 안 들고 있었음에도 불구하고 못들어가는 문제가 있었었는데, 상대가 깃발을 안 들고 있다면 바로 CS로 들어가게 함으로써 이 문제를 해결했다.</p>

<h4 id="petersons-algorithm">Peterson’s Algorithm</h4>

<p>: Dekker의 알고리즘을 간단하게 만든 것이다.</p>

<p><strong>순서</strong></p>

<ol>
  <li>2개의 Process가 있다.</li>
  <li>Process 하나가 깃발을 들고, <strong>Turn을 양보한다.</strong></li>
  <li>상대가 깃발을 들고있고, 상대방 Turn이면 기다린다.</li>
</ol>

<p>Turn을 넘겨주는게 아니라, 양보한다는 것이 Dekker’s algorithm과 다른점이다.</p>

<h3 id="n-process-mutual-exclusion-solutions">N-Process Mutual Exclusion Solutions</h3>

<p>Process가 여러개 있을 때의 Mutual Exclusion를 만족하기위한 해결책들</p>

<h4 id="dijkstra-algorithm-다익스트라-알고리즘">Dijkstra Algorithm (다익스트라 알고리즘)</h4>

<p>대단한 분이라서 이분 이름을 딴 알고리즘이 많다.</p>

<p>지금은 Mutual exclusion에 대한 다익스트라 알고리즘을 다룬다.</p>

<ul>
  <li><strong>마찬가지로 Turn과 Flag를 사용하는데, Flag의 state가 3개</strong>
    <ul>
      <li><strong>idle</strong> (CS 진입을 시도하고 있지 않는 단계)</li>
      <li><strong>want-in</strong> (CS 진입을 하고 싶은 의사를 밝히는 단계)</li>
      <li><strong>in-CS</strong> (CS 진입을 하기 직전의 단계)</li>
    </ul>
  </li>
</ul>

<p>want-in(1단계)과 in-CS(2단계)를 둘다 통과해야 CS에 들어갈 수 있다.</p>

<p><strong>Want-in 단계 과정</strong></p>

<ol>
  <li>$P_i$가 CS에 들어가고 싶다고 말한다. (flag state를 want-in으로)</li>
  <li>자기 Turn이 아니면 상대의 State가 idle이 될 때까지 체크하면서 기다린다.</li>
  <li>상대의 일이 끝나는 순간 Turn을 자기껄로 뺏어오고, in-CS State로 진입한다.
    <ul>
      <li>이 과정에서 여러 Process들이 Turn가지고 싸운다. 뺏고 뺏기고 난리치면서 여러개의 Process가  2단계로 진입</li>
    </ul>
  </li>
</ol>

<p><strong>In-CS 단계 과정</strong></p>

<ol>
  <li>
    <p>flag state를 in-CS로 바뀐다.</p>
  </li>
  <li>
    <p>j라는 반복를 위한 변수을 사용하여 while문을 돌린다.</p>

    <ul>
      <li>
        <p>Case 1. j &lt; n(Process의 수) - 1</p>

        <ul>
          <li>반복문이 끝까지 다 돌았을 때</li>
        </ul>
      </li>
      <li>Case 2. (j == i) or (flag[j] != in-CS)
        <ul>
          <li>j가 i 가 아니고, flag[j] 가 in-CS state일 경우</li>
        </ul>
      </li>
      <li>in-CS state인 Process가 나보다 먼저 있음</li>
    </ul>

    <p>Case 2의 경우에는 다시 처음으로 돌아간다. Case 1의 경우에는 CS로 $P_i$가 들어간다.</p>
  </li>
</ol>

<p>여기까지가 Softeware적으로 Mutual Exclusion을 구현하기위한 방법이었다. 단점은 다음과 같다.</p>

<ul>
  <li>속도가 느리다.</li>
  <li>구현이 복잡하다.</li>
  <li>Code 실행 중간에 Preemption 될 수 있다.
    <ul>
      <li>OS가 도와줘서 interrupt를 막을 수 있지만 overhead가 발생한다.</li>
    </ul>
  </li>
  <li>아무것도 안하면서 기다리는게 아니라 뺑뺑돌면서 기다린다. (Busy waiting)
    <ul>
      <li>Busy waiting은 비효율적이다.</li>
    </ul>
  </li>
</ul>

<h2 id="hw-solution">HW solution</h2>

<p>SW solution을 썻는데 비효율적이었다. 그래서 Hardware적 차원에서 도움을 받아 새로운 Solution을 만들었다.</p>

<h3 id="testandset-tas-instruction">TestAndSet (TAS) instruction</h3>

<ul>
  <li>Test와 Set을 한번에 수행하는 “기계어” -&gt; <strong>수행중에 interrupt를 받지 않는것이 보장된다.</strong></li>
  <li>Busy waiting</li>
</ul>

<p><em>앞에서 Machine instruction은 atomicity하고 individible이었지만,</em></p>

<p><em>코드의 줄 사이에서 개입이 일어날 수 있다고 했다.</em></p>

<p><em>여기서 TestAndSet instruction은 여러줄의 Machine instruction을 묶어서 한번에 수행하도록 만든 것 같은 느낌..</em></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><table style="margin: 0px"><tbody><tr><td class="gutter"><pre>1<br/>2<br/>3<br/>4<br/>5</pre></td><td class="code"><pre class="highlight"><code><span class="n">boolean</span> <span class="n">TestAndSet</span><span class="p">(</span><span class="n">boolean</span> <span class="o">*</span><span class="n">target</span><span class="p">){</span>
	<span class="n">boolean</span> <span class="n">temp</span> <span class="o">=</span> <span class="o">*</span><span class="n">target</span><span class="p">;</span> <span class="c1">// target에 temp 기록
</span>	<span class="o">*</span><span class="n">target</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 포인터로 temp를 true로 설정
</span>	<span class="k">return</span> <span class="n">temp</span><span class="p">;</span> <span class="c1">// return true
</span><span class="p">}</span>
</code></pre></td></tr></tbody></table></div></div>

<p><strong>여러줄의 Machine instructions가 한번에 수행되도록 만들어놨기 때문에, 중간에 Interrupt가 없어서, Mutual Exclusion이 간단하게 구현되었다.</strong></p>

<h3 id="me-with-tas-instruction">ME with TAS instruction</h3>

<p>Mutual exclusion은 쉽게 해결을 했지만, 프로세스가 3개 이상이 될 경우 Bounded waiting 조건을 위배한다.</p>

<ol>
  <li>프로세스 여러개가 있다. {1,2,3,…}</li>
  <li>1번이 CS에 들어가서 일을 하고 있고, 2번3번은 뺑뺑 돌고있다.</li>
  <li>1번이 일을 다 마치고 나간다.</li>
  <li>3번이 먼저 들어와서 일하는 도중에 4번이 들어와서 2번과 같이 뺑뺑 돈다.</li>
  <li>3번이 끝나고 나갔는데 4번이 먼저 들어가서 일을 한다.</li>
</ol>

<ul>
  <li>위처럼 운이 나쁘면 못들어가서 Bounded waiting조건을 위배하게 된다.</li>
</ul>

<p>그래도 의미있는건 TAS라는 구조로 Mutual exclusion이 쉽게 해결되었다는것 이다.</p>

<p>그렇다면 3개 이상의 Process가 있는 환경에서 모든 조건을 부합하려면 어떻게 해야할까?</p>

<p>-&gt; <strong>waiting이라는 새로운 변수를 사용한다.</strong></p>

<ul>
  <li>
    <p>기다려야하면 True, 기다리지 않아도 되면 False</p>
  </li>
  <li>
    <p>내가 CS에서 일을 마치고 나오면 while문으로 내 뒤에 <strong>대기중인 프로세스를 찾는다.</strong></p>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><table style="margin: 0px"><tbody><tr><td class="gutter"><pre>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17</pre></td><td class="code"><pre class="highlight"><code><span class="c1">// Process i 의 진입 영역
</span><span class="k">do</span>
<span class="p">{</span>
	<span class="n">waiting</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">key</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">waiting</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">TestAndSet</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
    <span class="n">waiting</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="c1">// Critical section
</span>    <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">while</span><span class="p">((</span><span class="n">j</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">waiting</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="c1">// 대기중인 프로세스를 찾는다.
</span>        <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">;</span>		   <span class="c1">// i 뒤로 순서대로 검사
</span>    <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> 					   <span class="c1">// 대기중인 프로세스가 없을 때, j는 i와 같을 것이다.
</span>        <span class="n">lock</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">waiting</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span><span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
</code></pre></td></tr></tbody></table></div></div>

<ul>
  <li>장점
    <ul>
      <li>구현이 간단하다.</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>Busy waiting
        <ul>
          <li>TAS안에서 뺑뺑 돌고있어야 한다는 문제가 있다. (여기서도 역시나 Busy waiting 문제)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="os-supported-sw-solution">OS supported SW solution</h2>

<p>이번에는 OS의 도움을 받아 Mutual Exclusion을 구현하는 방법을 살펴보자.</p>

<h3 id="spinlock">Spinlock</h3>

<ul>
  <li>정수형 변수 S를 사용한다.</li>
  <li><strong>S에는 초기화, P(), V() operation으로만 접근이 가능하다.</strong>
    <ul>
      <li>위 연산들은 Atomicity한 특성을 가지고 있음
        <ul>
          <li><strong>OS가 이 연산들의 Atomicity를 보장한다.</strong></li>
          <li>TAS처럼 여러 Machine instructions가 한번에 수행된다.</li>
        </ul>
      </li>
      <li>각각 네덜란드어로 Proberen(시도), Verhogen(증가)의 의미를 가지고 있다.</li>
    </ul>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><table style="margin: 0px"><tbody><tr><td class="gutter"><pre>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>9<br/>10<br/>11<br/>12<br/>13<br/>14</pre></td><td class="code"><pre class="highlight"><code><span class="c1">// P()는 물건의 개수 or 자물쇠를 거는 것
</span><span class="n">P</span><span class="p">(</span><span class="n">S</span><span class="p">){</span>
    <span class="c1">// 물건이 없다면, 물건이 생기기를 while문 안에서 기다린다.
</span>    <span class="k">while</span><span class="p">(</span><span class="n">S</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">)</span><span class="k">do</span> 
    <span class="n">endwhile</span><span class="p">;</span>
    <span class="c1">// 물건이 있어서 while문을 빠져나왔다면, 물건을 하나 가져간다. -&gt; S-1
</span>    <span class="n">S</span> <span class="o">&lt;-</span> <span class="n">S</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// V()는 물건을 집어넣는 것 or 자물쇠를 푸는 것
</span><span class="n">V</span><span class="p">(</span><span class="n">S</span><span class="p">){</span>
    <span class="c1">// 물건을 집어넣는다 -&gt; S+1
</span>    <span class="n">S</span> <span class="o">&lt;-</span> <span class="n">S</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></tbody></table></div></div>

<p><strong>OS가 서포트해주는 Spinlock이라는 Operation으로 Mutual exclusion이 간단하게 구현된다.</strong></p>

<ul>
  <li>CS에 들어갈 때 P()로 문을 잠근다.</li>
  <li>CS에 V()로 문을 열어두고 나온다.</li>
</ul>

<p>P()와 V()는 Atomicity가 보장되기 때문에,</p>

<p><strong>중간에 Preemption되지 않아서, 동시에 들어가거나 아무도 못들어가는 문제는 발생하지 않는다.</strong></p>

<p>-&gt; OS가 도와주니까 쉽게 구현할 수 있다.</p>

<p><strong>Spinlock의 문제점</strong></p>

<ul>
  <li>
    <p><strong>Multi-processor 환경에서만 가능하다.</strong></p>

    <p>ex)</p>

    <ol>
      <li>CPU가 하나일 때, Pi가 CS에 들어와서 일을 한다. S는 1에서 0이 되었다.</li>
      <li>Pi가 CS에서 멈췄다.</li>
      <li>PJ가 CPU를 할당받았지만, Pi가 V() operation을 수행하지 못해서 Pj는 P()에서 계속 뻉뻉 돌아야한다.</li>
      <li>결국 Pi와 Pj 둘 다 일을 못하게 된다.</li>
    </ol>

    <p>-&gt; CPU가 여러개가 있어야 Pi와 Pj가 동시에 돌아가야 Logic이 성립한다.</p>
  </li>
  <li>
    <p><strong>여전히 Busy waiting 문제가 있다.</strong></p>
  </li>
</ul>

<h3 id="semaphore">Semaphore</h3>

<p>1965년에 Dijkstra가 제안 (이분 또 나오시네)</p>

<ul>
  <li>이번에도 S를 사용하는데, <strong>S는 이번에는 음이 아닌 정수형 변수!</strong></li>
  <li><strong>임의의 S변수 하나에 Ready queue하나가 할당 된다.</strong>
    <ul>
      <li>이게 어떤 역할을 할지 중점적으로 보자.</li>
    </ul>
  </li>
</ul>

<p>두가지 종류의 Semaphore가 있다.</p>

<ul>
  <li><strong>Binary Semaphore</strong>
    <ul>
      <li>S가 0또는 1, 두 종류의 값만 갖는다.</li>
      <li>Mutual exclusion문제에 사용한다.</li>
    </ul>
  </li>
  <li><strong>Counting Semaphore</strong>
    <ul>
      <li>S가 0이상의 정수값을 갖는다.</li>
      <li>Producer-Consumer문제 등을 해결하기 위해 사용한다.(?)</li>
    </ul>
  </li>
</ul>

<p>Spinlock과 무엇이 다를지 코드와 함께 살펴보자.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><table style="margin: 0px"><tbody><tr><td class="gutter"><pre>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15</pre></td><td class="code"><pre class="highlight"><code><span class="n">P</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">S</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
		<span class="n">then</span> <span class="n">S</span> <span class="o">&lt;-</span> <span class="n">S</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> 
        <span class="c1">//여기서 queue가 대기실 역할을 한다. Busy waiting 문제해결
</span>	<span class="k">else</span> <span class="n">wait</span> <span class="n">on</span> <span class="n">the</span> <span class="n">queue</span> <span class="n">Q_s</span><span class="p">;</span> 
<span class="p">}</span>

<span class="n">V</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//Queue안에 대기하는 Process가 있으면
</span>    <span class="k">if</span><span class="p">(</span><span class="n">Q_s</span><span class="p">)</span>
        <span class="n">then</span> <span class="n">wakeup</span> <span class="n">one</span> <span class="n">of</span> <span class="n">them</span><span class="p">;</span>
    <span class="k">else</span> <span class="n">S</span> <span class="o">&lt;-</span> <span class="n">S</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></tbody></table></div></div>

<p>Spinlock과 다른점은 Busy waiting문제가 없다는점! 각각의 S 하나마다 대기실(Ready queue)를 할당했기 때문이다.이런식으로 여러 Synchronization문제를 해결할 수 있다.</p>

<h4 id="process-synchronization-with-semaphore">Process Synchronization with Semaphore</h4>

<p>Process들의 실행순서를 맞출 수 있다. P()와 V()를 이용해서 프로세스간의 순서를 결정한다.</p>

<h4 id="producer-consumer-problem-with-semaphore">Producer-Consumer Problem with Semaphore</h4>

<ul>
  <li>Producer는 Data를 생산해내는 녀석들 (Buffer에 쌓아둠)
    <ul>
      <li>프린터 드라이버</li>
      <li>컴파일러</li>
      <li>어셈블러</li>
    </ul>
  </li>
  <li>Consumer들은 이 Data를 가져다가 쓰는 녀석들</li>
</ul>

<p>Producer가 생산해내는 Data는 Buffer에 저장된다. 여러개의 Producer와 Consumer가 있기때문에 Buffer에 접근하는것에 대해서 동기화가 필요하다.</p>

<p><strong>ex) Single bufer에서의 Producer-Consumer Problem</strong></p>

<p>Buffer에는 한번에 한 녀석만 접근해야된다. 2개의 Semaphore 변수를 선언해서 사용한다.</p>

<ul>
  <li>Consumed (소비되었니?)</li>
  <li>Produced (생산되었니?)</li>
</ul>

<p><strong>Producer 입장에서</strong></p>

<ol>
  <li>생산자가 Buffer에 Data를 넣을때 Buffer가 비었는지(소비되었는지) 체크 (Semaphore &lt;- 0)
    <ul>
      <li>비었으면 생산하고 Produce했다고 표시한다. (Semaphore &lt;- 1)</li>
      <li>비어있지 않으면 대기실에서 기다린다.</li>
    </ul>
  </li>
</ol>

<p><strong>Consumer 입장에서</strong></p>

<ol>
  <li>Buffer에 물건이 있는지(생산되었는지) 체크 (Semaphore &lt;- 1)
    <ul>
      <li>비었으면 대기실에서 기다린다. (생산이 되면 Producer가 깨워줌)</li>
      <li>비어있지 않으면 들어가서 Data를 사용한다.</li>
    </ul>
  </li>
</ol>

<p><strong>ex) N개의 buffer에서의 Producer-Consumer Problem</strong>에서,</p>

<p>생산자도 여러명이고 소비자도 여러명, Buffer도 여러개일때는?</p>

<p><strong>이중으로 P()와 V()를 사용</strong></p>

<ul>
  <li>겉부분의 P()와 V()
    <ul>
      <li>mutexP : 다른 Producer가 있는지 확인하기 위한 변수</li>
      <li>mutexC : 다른 Consumer가 있는지 확인하기 위한 변수</li>
    </ul>
  </li>
  <li>안부분의 P()와 V()
    <ul>
      <li>nrfull : Consumer입장에서 buffer가 얼만큼 차있는지 확인하기 위한 변수</li>
      <li>nrempty : Producer입장에서 buffer에 자리가 얼마만큼 있는지 확인하기 위한 변수</li>
    </ul>
  </li>
</ul>

<h4 id="reader-writer-problem-with-semaphore">Reader-Writer Problem with Semaphore</h4>

<ul>
  <li>Reader는 데이터에 대해 읽기 연산만 수행</li>
  <li>Writer는 데이터에 대해 갱신 연산을 수행</li>
</ul>

<p>Read같은 경우 동시에 같은 데이터에 접근해도 문제가 없다. 하지만 Write는 별다른 Synchronization없이 여러명이서 쓰면 난리가 난다. 그러므로 Data의 Consistency 보장이 필요하다.</p>

<dl>
  <dt><strong>해결법</strong></dt>
  <dd>
    <p>Reader/Writer에 대한 우선권을 부여한다.</p>
  </dd>
</dl>

<ul>
  <li>Reader가 우선권을 가지는 경우
    <ul>
      <li>3가지 변수를 사용
        <ul>
          <li>wmutex : 다른 Writer가 있는지 확인하기 위한 변수</li>
          <li>rmutex : 다른 Reader가 있는지 확인하기 위한 변수</li>
          <li>nreaders : Reader의 수를 표현하기 위한 변수</li>
        </ul>
      </li>
      <li>Reader가 없을때 Read하기 위해 들어갈때는 Writer가 못들어오도록 막고 시작한다.</li>
      <li>Read를 마치고 나가려고할때, 마지막 Reader라면 Wrtier가 들어올 수 있도록 한다.</li>
    </ul>
  </li>
  <li>Writer가 우선권을 가지는 경우</li>
</ul>

<p><strong>Semaphore의 효과</strong></p>

<ul>
  <li>No busy waiting
    <ul>
      <li>대기실을 만들어서 해결했다. (각 S변수 하나마다 Ready queue가 할당되었었다.)</li>
    </ul>
  </li>
  <li>Semaphore queue에 대한 wake-up순서는 비결정적이다.
    <ul>
      <li><strong>Starvation problem이 있다.</strong></li>
    </ul>
  </li>
</ul>

<h3 id="eventcount--sequencer">Eventcount / Sequencer</h3>

<p>은행업무와 비교해서 생각하면 쉬운 개념!</p>

<ul>
  <li><strong>Sequencer</strong>
    <ul>
      <li>정수형 변수</li>
      <li>생성시 0으로 초기화하고 감소하지 않는다.</li>
      <li>순서를 유지하고 ticket() operation으로만 접근 가능</li>
    </ul>
  </li>
  <li><strong>ticket(S)</strong>
    <ul>
      <li>현재까지 ticket() Operation이 호출 된 횟수 반환 (번호표)</li>
      <li>Indivisible Operation</li>
      <li>0에서 시작해서 번호표를 뽑을 때마다 번호가 계속 +1씩 증가한다.</li>
    </ul>
  </li>
  <li><strong>Eventcount</strong>
    <ul>
      <li>정수형 변수</li>
      <li>생성시 0으로 초기화하고 감소하지 않는다.</li>
      <li>특정사건의 발생 횟수를 기록 (은행으로 치면 지금까지 업무처리가 끝난 번호까지)</li>
      <li><strong>read(E), advance(E), await(E,v) operation</strong>으로만 접근 가능
        <ul>
          <li>read는 현재 번호가 몇번인지 보고있는 것</li>
          <li>advance는 은행원이 다음번호로 넘기는 행위 (기다리고있는 프로세스를 깨운다.)</li>
          <li>await(E,v)에서 v는 번호표, E는 현재 번호 -&gt; 내 번호가 더 크면 대기실에서 기다린다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><strong>순서</strong></p>

<ol>
  <li>Process가 와서 번호표를 뽑는다. (ticket(S))</li>
  <li>내 차례가 올때까지 대기실에서 기다린다 (await(E,v))</li>
  <li>일을 끝내고 기다리고 있는 다른 Process를 깨운다 (advance(E))</li>
</ol>

<p>위와같은 순서로 진행된다.</p>

<p>이 방법으로 Producer-Consumer Problem을 풀어보자. (강의에서 확인하자)</p>

<h2 id="language-level-solution">Language-Level Solution</h2>

<p>여전히 구현이 어렵고, 에러가 생길 가능성이 높다. 그래서 이번에는 Programming language수준에서 Mutual exclusion 문제를 해결해보자!</p>

<h3 id="high-level-mechanism">High-Level Mechanism</h3>

<p>프로그래밍언어가 Mutual exclusion을 Support하자!</p>

<ul>
  <li>사용이 쉽다.</li>
  <li>Object-Oriented concept과 유사하다.</li>
</ul>

<p>앞에서 했던 방법들(Low-level mechanisms)은 Flexible했지만, 많이 복잡했고, 쓰기도 힘들었다.</p>

<ul>
  <li><strong>Error 발생 확률이 높았다.</strong></li>
</ul>

<p>그러니까 우리가 쓰는 High level의 Program language로 쉽게 Solution을 만들보자! Monitor, Path expression, Serializers등등 여러가지가 있지만 Monitor만 살펴보도록 하자.</p>

<h3 id="monitor">Monitor</h3>

<p>책방에 대입해서 생각해보자.</p>

<p>Critical Data와 Critical Section을 모아논 하나의 방이라고 생각하면된다. (한번에 한명만 들어올 수 있는 책방)</p>

<ul>
  <li>Critical data: 내가 빌리고싶은 책</li>
  <li>Critical section: 내가 대출하거나 반납하기위해서 들리는 카운터</li>
</ul>

<p>이 외에도 Conditional variable과 wait(), signal() operation들이 존재한다.</p>

<p><strong>Monitor의 구조</strong></p>

<ul>
  <li>Entry queue (진입큐)
    <ul>
      <li>한번에 하나만 들어가도록하는 queue</li>
      <li>Function마다 하나씩 존재</li>
    </ul>
  </li>
  <li>Mutual exclusion
    <ul>
      <li><strong>Monitor내에는 항상 하나의 Process만 진입가능</strong> (Programming language로 보장)</li>
    </ul>
  </li>
  <li>Information hiding (정보 은폐)
    <ul>
      <li>Ciritical data에는 모니터 내의 프로세스만 접근가능</li>
    </ul>
  </li>
  <li>Condition queue (조건 큐)
    <ul>
      <li>모니터 내의 특정 이벤트를 기다리는 프로세스들의 대기실</li>
    </ul>
  </li>
  <li>Signaler queue (신호제공자 큐)
    <ul>
      <li>모니터에는 항상 하나의 신호제공자 큐가 존재</li>
      <li>전화부스라고 생각하면 된다.</li>
      <li>signal을 보내기위해 잠깐 들어가는 공간</li>
    </ul>
  </li>
</ul>

<p>자원할당이라는 문제로 동작을 살펴보자. (자원을 책이라고 가정한다.)</p>

<ul>
  <li>책을 요청하는 function과, 책을 반납하는 function이 존재한다.
    <ul>
      <li>release and request</li>
      <li>각각의 Function은 Entry queue를 가지게 된다.</li>
    </ul>
  </li>
  <li>Conditon queue이라는 대기실이 존재한다.</li>
  <li>대기실의 Process를 깨우는 공간인 Signaler queue가 존재한다.</li>
</ul>

<div class="language-c# highlighter-rouge"><div class="highlight"><table style="margin: 0px"><tbody><tr><td class="gutter"><pre>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>9<br/>10<br/>11<br/>12<br/>13</pre></td><td class="code"><pre class="highlight"><code><span class="c1">//기존의 방식과는 다르게 생각한대로 짜면됨</span>
<span class="n">procedure</span> <span class="nf">requestR</span><span class="p">();</span>
<span class="n">begin</span>
    <span class="k">if</span><span class="p">(~</span><span class="n">R_Available</span><span class="p">)</span><span class="n">then</span>
        <span class="n">R_Free</span><span class="p">.</span><span class="nf">wait</span><span class="p">();</span> <span class="c1">//책이 없으면 기다려라</span>
    <span class="n">R_Available</span> <span class="p">&lt;-</span> <span class="k">false</span><span class="p">;</span>
<span class="n">end</span><span class="p">;</span>

<span class="n">procedure</span> <span class="nf">releaseR</span><span class="p">();</span>
<span class="n">begin</span>
    <span class="n">R_Available</span> <span class="p">&lt;-</span> <span class="k">true</span><span class="p">;</span> <span class="c1">//반납했으니까 true로 바꾼다.</span>
	<span class="n">R_Free</span><span class="p">.</span><span class="nf">signal</span><span class="p">();</span> <span class="c1">//Condition queue에 기다렸던놈 나와라.</span>
<span class="n">end</span><span class="p">;</span>
</code></pre></td></tr></tbody></table></div></div>

<p>이런식으로 그냥 생각하는대로 쉽게 짤 수가 있다. 여기서 주의해서 생각해야할 것은</p>

<ul>
  <li>Monitor에는 한번에 한명만 들어갈 수 있다.</li>
  <li>Release와 Request가 각각 나뉘어져있어서 Release를 마치고 signaler queue에서 Condition queue에서 기다리고있는 사람을 불렀을 때, Monitor에는 한명만 들어갈 수있기 때문에, Monitor에서 나와야한다.</li>
  <li>위의 코드는 간단하게 짠거라서 없지만, release의 경우 자원을 반납하고나서, 마무리 작업이 남아있기 때문에 Condition queue안의 대기하고 있는 사람을 부르고나서 signaler queue에 들어가있다가 다시 Monitor로 들어가서 남은일을 하고 나온다.</li>
</ul>

<h4 id="procuder-consumer-problem-with-monitor">Procuder-Consumer Problem with Monitor</h4>

<p>이번에는 Producer-Consumer Problem을 Monitor로 해결해보자.</p>

<p>Variables</p>

<ul>
  <li>ValidBufs: 물건의 개수</li>
  <li>in, out: Data가 들어갈 공간</li>
</ul>

<p>Procedure</p>

<ul>
  <li>fillBuf(): Producer가 사용할 Procedure</li>
  <li>emptyBuf(): Consumer가 사용할 Procedure</li>
</ul>

<p>Condition queue</p>

<ul>
  <li>bufHasData: Buffer에 ‘데이터’가 있는지 (Consumer가 기다리는 공간)</li>
  <li>bufHasSpace: Buffer에 ‘공간’이 있는지 (Producer가 기다리는 공간)</li>
</ul>

<p>위와 같은 구성으로, 코드를 작성해보면</p>

<div class="language-c# highlighter-rouge"><div class="highlight"><table style="margin: 0px"><tbody><tr><td class="gutter"><pre>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20</pre></td><td class="code"><pre class="highlight"><code><span class="c1">//Producer</span>
<span class="n">procedure</span> <span class="nf">fillBuff</span><span class="p">();</span>
<span class="n">begin</span>
    <span class="c1">//물건의 수가 N이다? -&gt; 꽉찼다. 그러니까 기다려라</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">validBufs</span><span class="p">=</span><span class="n">N</span><span class="p">)</span><span class="n">then</span> <span class="n">bufHasSpace</span><span class="p">.</span><span class="nf">wait</span><span class="p">();</span>
	<span class="n">buffer</span><span class="p">[</span><span class="k">in</span><span class="p">]</span> <span class="p">&lt;-</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">validBufs</span> <span class="p">&lt;-</span> <span class="n">validBufs</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
	<span class="k">in</span> <span class="p">&lt;-</span> <span class="p">(</span><span class="k">in</span> <span class="p">+</span> <span class="m">1</span><span class="p">)</span> <span class="n">mod</span> <span class="n">N</span><span class="p">;</span>
	<span class="n">bufHasData</span><span class="p">.</span><span class="nf">signal</span><span class="p">();</span> <span class="c1">//물건을 기다리는 Consumer가 있으면 깨운다.</span>
<span class="n">end</span><span class="p">;</span>
<span class="c1">//Consumer</span>
<span class="n">procedure</span> <span class="nf">emptyBuf</span><span class="p">():</span>
<span class="n">begin</span>
    <span class="c1">//물건의 수가 0이다? -&gt; 데이터가 없다. 그러니까 기다려라</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">validBufs</span><span class="p">=</span><span class="m">0</span><span class="p">)</span><span class="n">then</span> <span class="n">bufHasData</span><span class="p">.</span><span class="nf">wait</span><span class="p">();</span>
	<span class="n">data</span> <span class="p">&lt;-</span> <span class="n">buffer</span><span class="p">[</span><span class="k">out</span><span class="p">];</span>
	<span class="n">validBuf</span> <span class="p">&lt;-</span> <span class="n">validBuf</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
	<span class="k">out</span> <span class="p">&lt;-</span> <span class="p">(</span><span class="k">out</span> <span class="p">+</span> <span class="m">1</span><span class="p">)</span> <span class="n">mod</span> <span class="n">N</span><span class="p">;</span>
	<span class="n">bufHasSpace</span><span class="p">.</span><span class="nf">signal</span><span class="p">();</span> <span class="c1">//공간을 기다리는 Producer가 있으면 깨운다.</span>
<span class="n">end</span><span class="p">;</span>
</code></pre></td></tr></tbody></table></div></div>

<h4 id="reader-writer-problem-with-monitor"><strong>Reader-Writer Problem with Monitor</strong></h4>

<p>read같은 경우는 한번에 여러명이 할 수 있었지만, write같은 경우는 한번에 여러명이 할 경우 큰일난다고 위에서 말했었다. 위에서만 Semaphore를 이용해서 했었지만, 이번에는 Monitor를 이용해서 좀더 간단하게 만들어보자.</p>

<p>Variables</p>

<ul>
  <li>nReader: Reader의 수</li>
  <li>writing: writer의 존재유무</li>
</ul>

<p>Procedure</p>

<ul>
  <li>beginRead: Reader가 사용할 Procedure</li>
  <li>finishRead: Reader가 사용할 Procedure2</li>
  <li>beginWrite: Writer가 사용할 Procedure</li>
  <li>finishWrite: Writer가 사용할 Procedure2</li>
</ul>

<p>Condition queue</p>

<ul>
  <li>waitWrite: Writer가 기다리는 공간</li>
  <li>waitRead: Writer가 이미 Monitor내에 있을 경우 Reader가 기다리는 공간</li>
</ul>

<div class="language-c# highlighter-rouge"><div class="highlight"><table style="margin: 0px"><tbody><tr><td class="gutter"><pre>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15<br/>16<br/>17<br/>18<br/>19<br/>20<br/>21<br/>22<br/>23<br/>24</pre></td><td class="code"><pre class="highlight"><code><span class="n">procedure</span> <span class="nf">beginReading</span><span class="p">();</span>
<span class="n">begin</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">writing</span> <span class="n">or</span> <span class="nf">queue</span><span class="p">(</span><span class="n">waitWrite</span><span class="p">))</span><span class="n">then</span> <span class="n">waitRead</span><span class="p">.</span><span class="nf">wait</span><span class="p">();</span>
	<span class="n">nReader</span> <span class="p">&lt;-</span> <span class="n">nReader</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="nf">queue</span><span class="p">(</span><span class="n">waitRead</span><span class="p">))</span><span class="n">then</span> <span class="n">waitRead</span><span class="p">.</span><span class="nf">signal</span><span class="p">();</span>
<span class="n">end</span><span class="p">;</span>
<span class="n">procedure</span> <span class="nf">finishReading</span><span class="p">():</span>
<span class="n">begin</span>
    <span class="n">nReader</span> <span class="p">&lt;-</span> <span class="n">nReader</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span>
	<span class="k">if</span><span class="p">(</span><span class="n">nReader</span><span class="p">=</span><span class="m">0</span><span class="p">)</span><span class="n">then</span> <span class="n">waitWrite</span><span class="p">.</span><span class="nf">signal</span><span class="p">();</span>
<span class="n">end</span><span class="p">;</span>

<span class="n">procedure</span> <span class="nf">beginWriting</span><span class="p">():</span>
<span class="n">begin</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">writing</span> <span class="n">or</span> <span class="n">nReader</span><span class="p">&gt;</span><span class="m">0</span><span class="p">)</span><span class="n">then</span> <span class="n">waitWrite</span><span class="p">.</span><span class="nf">wait</span><span class="p">();</span>
	<span class="n">writing</span> <span class="p">&lt;-</span> <span class="k">true</span><span class="p">;</span>
<span class="n">end</span><span class="p">;</span>

<span class="n">procedure</span> <span class="nf">finishWriting</span><span class="p">();</span>
<span class="n">begin</span>
    <span class="n">writing</span> <span class="p">&lt;-</span> <span class="k">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="nf">queue</span><span class="p">(</span><span class="n">waitRead</span><span class="p">))</span><span class="n">then</span> <span class="n">waitRead</span><span class="p">.</span><span class="nf">signal</span><span class="p">();</span>
	<span class="k">else</span> <span class="n">waitWrite</span><span class="p">.</span><span class="nf">signal</span><span class="p">();</span>
<span class="n">end</span><span class="p">;</span>
</code></pre></td></tr></tbody></table></div></div>

<p>이런식으로 짜면 된다. (솔직히 procedure 4개 나올줄은 몰랐습니다.)</p>

<h4 id="dining-philosopher-problem-with-monitor">Dining Philosopher Problem with Monitor</h4>

<p>이번에는 Dining philosopher problem</p>

<ul>
  <li>5명의 철학자</li>
  <li>하는일은 생각하는일, 스파게티 먹는일을 반복함</li>
  <li>공유자원: 스파게티 포크</li>
  <li>스파게티를 먹기위해서는 좌우 포크2개를 모두 들어야한다.</li>
</ul>

<p>Variables</p>

<ul>
  <li>numForks[0~4]: 철학자들이 쓸 수 있는 포크의 개수</li>
</ul>

<p>Procedure</p>

<ul>
  <li>pickUp: 스파게티를 먹을 사람이 포크를 드는 것</li>
  <li>putDown: 생각하는 사람이 포크를 내려놓는 것</li>
</ul>

<p>Condition queue</p>

<ul>
  <li>room[0~4]: 철학자들의 방 5개</li>
</ul>

<div class="language-c# highlighter-rouge"><div class="highlight"><table style="margin: 0px"><tbody><tr><td class="gutter"><pre>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>9<br/>10<br/>11<br/>12<br/>13<br/>14<br/>15</pre></td><td class="code"><pre class="highlight"><code><span class="n">procedure</span> <span class="nf">pickUp</span><span class="p">(</span><span class="n">me</span><span class="p">);</span>
<span class="n">begin</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">numForks</span><span class="p">&lt;</span><span class="m">2</span><span class="p">)</span><span class="n">then</span> <span class="n">room</span><span class="p">[</span><span class="n">me</span><span class="p">].</span><span class="nf">wait</span><span class="p">();</span>
	<span class="c1">//내 양쪽사람이 쓸수 있는 포크는 1개씩 줄어든다.</span>
	<span class="n">numForks</span><span class="p">[</span><span class="n">me</span><span class="p">-</span><span class="m">1</span><span class="p">]</span> <span class="p">&lt;-</span> <span class="n">numForks</span><span class="p">[</span><span class="n">me</span><span class="p">-</span><span class="m">1</span><span class="p">]</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span>
	<span class="n">numForks</span><span class="p">[</span><span class="n">me</span><span class="p">+</span><span class="m">1</span><span class="p">]</span> <span class="p">&lt;-</span> <span class="n">numForks</span><span class="p">[</span><span class="n">me</span><span class="p">+</span><span class="m">1</span><span class="p">]</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span>
<span class="n">end</span><span class="p">;</span>

<span class="n">procedure</span> <span class="nf">putDown</span><span class="p">(</span><span class="n">me</span><span class="p">);</span>
<span class="n">begin</span>
    <span class="n">numForks</span><span class="p">[</span><span class="n">me</span><span class="p">-</span><span class="m">1</span><span class="p">]</span> <span class="p">&lt;-</span> <span class="n">numForks</span><span class="p">[</span><span class="n">me</span><span class="p">-</span><span class="m">1</span><span class="p">]</span> <span class="p">+</span> <span class="m">1</span>
    <span class="n">numForks</span><span class="p">[</span><span class="n">me</span><span class="p">+</span><span class="m">1</span><span class="p">]</span> <span class="p">&lt;-</span> <span class="n">numForks</span><span class="p">[</span><span class="n">me</span><span class="p">+</span><span class="m">1</span><span class="p">]</span> <span class="p">+</span> <span class="m">1</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">numForks</span><span class="p">[</span><span class="n">me</span><span class="p">+</span><span class="m">1</span><span class="p">]=</span><span class="m">2</span><span class="p">)</span><span class="n">then</span> <span class="n">room</span><span class="p">[</span><span class="n">me</span><span class="p">+</span><span class="m">1</span><span class="p">].</span><span class="nf">signal</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">numForks</span><span class="p">[</span><span class="n">me</span><span class="p">-</span><span class="m">1</span><span class="p">]=</span><span class="m">2</span><span class="p">)</span><span class="n">then</span> <span class="n">room</span><span class="p">[</span><span class="n">me</span><span class="p">-</span><span class="m">1</span><span class="p">].</span><span class="nf">signal</span><span class="p">();</span>
<span class="n">end</span><span class="p">;</span>    
</code></pre></td></tr></tbody></table></div></div>

<p>Reader-Writer Problem이랑 비슷하게 풀릴 줄 알고 Procedure를 처음에 4개를 준비했었었는데, 필요 없었습니다ㅠ</p>

<p>이렇게 여러가지 문제를 Monitor를 이용해서 쉽게 해결할 수 있었다.</p>

<p>장점과 단점을 살펴보면,</p>

<ul>
  <li>장점
    <ul>
      <li>사용이 쉽다.</li>
      <li>Deadlock과 Error의 발생 가능성이 낮다.</li>
    </ul>
  </li>
  <li>단점
    <ul>
      <li>Monitor를 지원하는 언어에서만 사용 가능</li>
      <li>Compiler가 OS를 이해하고 있어야한다.
        <ul>
          <li>Critical section 접근을 위한 코드 생성</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>



      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            
            <a href="/tag/#/OS" rel="tag"># OS</a>
          
        </div>
      

      
      
      
      
      

      
      
        <div class="post-nav" id="post-nav-id">
          <div class="post-nav-next post-nav-item">
            
              <a href="/english/2020/05/21/English_Conversation-post/" rel="next" title="Aran님의 유튜브 발음시리즈">
                <i class="fa fa-chevron-left"></i> Aran님의 유튜브 발음시리즈
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/information/2020/04/23/Covariance-post/" rel="prev" title="Covariance (공분산)">
                Covariance (공분산) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      
      

      
    </footer>
  </article>

  <div class="post-spread">
    
  </div>
</div>


<script src="https://utteranc.es/client.js"
        repo="Kojungbeom/kojungbeom.github.io"
        issue-term="title"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          

  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        
        
        







      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            목차
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            흝어보기
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/assets/images/avatar.gif"
               alt="고중범" />
          <p class="site-author-name" itemprop="name">고중범</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">포스트</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">카테고리</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">태그</span>
              </a>
            </div>
          

        </nav>

        
        
        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            








            
              <div class="post-toc-content">
    <ol class=nav>
      <li class="nav-item nav-level-1"> <a class="nav-link" href="#lecture-6"> <span class="nav-number">1</span> <span class="nav-text">Lecture 6</span> </a> </li> <li class="nav-item nav-level-1"> <a class="nav-link" href="#process-synchronization"> <span class="nav-number">2</span> <span class="nav-text">Process Synchronization</span> </a> <ol class="nav-child"> <li class="nav-item nav-level-2"> <a class="nav-link" href="#asynchronous-and-concurrent-ps"> <span class="nav-number">2.1</span> <span class="nav-text">Asynchronous and Concurrent P’s</span> </a> </li> <li class="nav-item nav-level-2"> <a class="nav-link" href="#terminologies"> <span class="nav-number">2.2</span> <span class="nav-text">Terminologies</span> </a> </li> <li class="nav-item nav-level-2"> <a class="nav-link" href="#critical-section"> <span class="nav-number">2.3</span> <span class="nav-text">Critical Section</span> </a> </li> <li class="nav-item nav-level-2"> <a class="nav-link" href="#mutual-exclusion-상호배제"> <span class="nav-number">2.4</span> <span class="nav-text">Mutual Exclusion (상호배제)</span> </a> </li> <li class="nav-item nav-level-2"> <a class="nav-link" href="#mutual-exclusion-methods"> <span class="nav-number">2.5</span> <span class="nav-text">Mutual Exclusion Methods</span> </a> <ol class="nav-child"> <li class="nav-item nav-level-3"> <a class="nav-link" href="#requirements-for-me-primitives"> <span class="nav-number">2.5.1</span> <span class="nav-text">Requirements for ME primitives</span> </a> </li> </ol> </li> <li class="nav-item nav-level-2"> <a class="nav-link" href="#sw-solutions"> <span class="nav-number">2.6</span> <span class="nav-text">SW Solutions</span> </a> <ol class="nav-child"> <li class="nav-item nav-level-3"> <a class="nav-link" href="#two-process-mutual-exclusion"> <span class="nav-number">2.6.1</span> <span class="nav-text">Two Process Mutual Exclusion</span> </a> <ol class="nav-child"> <li class="nav-item nav-level-4"> <a class="nav-link" href="#첫번째-시도"> <span class="nav-number">2.6.1.1</span> <span class="nav-text">첫번째 시도</strong</span> </a> </li> <li class="nav-item nav-level-4"> <a class="nav-link" href="#두번째-시도"> <span class="nav-number">2.6.1.2</span> <span class="nav-text">두번째 시도</strong</span> </a> </li> <li class="nav-item nav-level-4"> <a class="nav-link" href="#세번째-시도"> <span class="nav-number">2.6.1.3</span> <span class="nav-text">세번째 시도</strong</span> </a> </li> </ol> </li> <li class="nav-item nav-level-3"> <a class="nav-link" href="#mutual-exclusion-solutions"> <span class="nav-number">2.6.2</span> <span class="nav-text">Mutual Exclusion Solutions</span> </a> <ol class="nav-child"> <li class="nav-item nav-level-4"> <a class="nav-link" href="#dekkers-algorithm"> <span class="nav-number">2.6.2.1</span> <span class="nav-text">Dekker’s Algorithm</span> </a> </li> <li class="nav-item nav-level-4"> <a class="nav-link" href="#petersons-algorithm"> <span class="nav-number">2.6.2.2</span> <span class="nav-text">Peterson’s Algorithm</span> </a> </li> </ol> </li> <li class="nav-item nav-level-3"> <a class="nav-link" href="#n-process-mutual-exclusion-solutions"> <span class="nav-number">2.6.3</span> <span class="nav-text">N-Process Mutual Exclusion Solutions</span> </a> <ol class="nav-child"> <li class="nav-item nav-level-4"> <a class="nav-link" href="#dijkstra-algorithm-다익스트라-알고리즘"> <span class="nav-number">2.6.3.1</span> <span class="nav-text">Dijkstra Algorithm (다익스트라 알고리즘)</span> </a> </li> </ol> </li> </ol> </li> <li class="nav-item nav-level-2"> <a class="nav-link" href="#hw-solution"> <span class="nav-number">2.7</span> <span class="nav-text">HW solution</span> </a> <ol class="nav-child"> <li class="nav-item nav-level-3"> <a class="nav-link" href="#testandset-tas-instruction"> <span class="nav-number">2.7.1</span> <span class="nav-text">TestAndSet (TAS) instruction</span> </a> </li> <li class="nav-item nav-level-3"> <a class="nav-link" href="#me-with-tas-instruction"> <span class="nav-number">2.7.2</span> <span class="nav-text">ME with TAS instruction</span> </a> </li> </ol> </li> <li class="nav-item nav-level-2"> <a class="nav-link" href="#os-supported-sw-solution"> <span class="nav-number">2.8</span> <span class="nav-text">OS supported SW solution</span> </a> <ol class="nav-child"> <li class="nav-item nav-level-3"> <a class="nav-link" href="#spinlock"> <span class="nav-number">2.8.1</span> <span class="nav-text">Spinlock</span> </a> </li> <li class="nav-item nav-level-3"> <a class="nav-link" href="#semaphore"> <span class="nav-number">2.8.2</span> <span class="nav-text">Semaphore</span> </a> <ol class="nav-child"> <li class="nav-item nav-level-4"> <a class="nav-link" href="#process-synchronization-with-semaphore"> <span class="nav-number">2.8.2.1</span> <span class="nav-text">Process Synchronization with Semaphore</span> </a> </li> <li class="nav-item nav-level-4"> <a class="nav-link" href="#producer-consumer-problem-with-semaphore"> <span class="nav-number">2.8.2.2</span> <span class="nav-text">Producer-Consumer Problem with Semaphore</span> </a> </li> <li class="nav-item nav-level-4"> <a class="nav-link" href="#reader-writer-problem-with-semaphore"> <span class="nav-number">2.8.2.3</span> <span class="nav-text">Reader-Writer Problem with Semaphore</span> </a> </li> </ol> </li> <li class="nav-item nav-level-3"> <a class="nav-link" href="#eventcount--sequencer"> <span class="nav-number">2.8.3</span> <span class="nav-text">Eventcount / Sequencer</span> </a> </li> </ol> </li> <li class="nav-item nav-level-2"> <a class="nav-link" href="#language-level-solution"> <span class="nav-number">2.9</span> <span class="nav-text">Language-Level Solution</span> </a> <ol class="nav-child"> <li class="nav-item nav-level-3"> <a class="nav-link" href="#high-level-mechanism"> <span class="nav-number">2.9.1</span> <span class="nav-text">High-Level Mechanism</span> </a> </li> <li class="nav-item nav-level-3"> <a class="nav-link" href="#monitor"> <span class="nav-number">2.9.2</span> <span class="nav-text">Monitor</span> </a> <ol class="nav-child"> <li class="nav-item nav-level-4"> <a class="nav-link" href="#procuder-consumer-problem-with-monitor"> <span class="nav-number">2.9.2.1</span> <span class="nav-text">Procuder-Consumer Problem with Monitor</span> </a> </li> <li class="nav-item nav-level-4"> <a class="nav-link" href="#reader-writer-problem-with-monitor"> <span class="nav-number">2.9.2.2</span> <span class="nav-text">Reader-Writer Problem with Monitor</strong</span> </a> </li> <li class="nav-item nav-level-4"> <a class="nav-link" href="#dining-philosopher-problem-with-monitor"> <span class="nav-number">2.9.2.3</span> <span class="nav-text">Dining Philosopher Problem with Monitor</span> </a> </li> </ol> </li> </ol> </li> </ol> </li>
    </ol>
  </div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>

        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">고중범</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://jekyllrb.com">Jekyll</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/simpleyyt/jekyll-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>





















  
   
  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/jquery/index.js?v=2.1.3"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  
  
  
  
  <script type="text/javascript" src="/assets/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/assets/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/assets/js/src/motion.js?v=5.1.1"></script>



  
  

  <script type="text/javascript" src="/assets/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/assets/js/src/post-details.js?v=5.1.1"></script>


  


  <script type="text/javascript" src="/assets/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  











  




  

    

  







  






  

  

  
  


  

  

  

</body>
</html>

