<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/atom.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-09-02T21:45:55+09:00</updated><id>http://localhost:4000/atom.xml</id><title type="html">Ko</title><author><name>고중범</name></author><entry><title type="html">Ubuntu 18.04 LTS 네트워크 설정</title><link href="http://localhost:4000/ubuntu/2020/09/02/ubuntu_network/" rel="alternate" type="text/html" title="Ubuntu 18.04 LTS 네트워크 설정" /><published>2020-09-02T21:00:00+09:00</published><updated>2020-09-02T21:00:00+09:00</updated><id>http://localhost:4000/ubuntu/2020/09/02/ubuntu_network</id><content type="html" xml:base="http://localhost:4000/ubuntu/2020/09/02/ubuntu_network/">&lt;h1 id=&quot;ubuntu-1804-lts-네트워크-설정&quot;&gt;Ubuntu 18.04 LTS 네트워크 설정&lt;/h1&gt;

&lt;h3 id=&quot;dns-확인&quot;&gt;DNS 확인&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ nslookup server
$ nslookup
&amp;gt; server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;hostname-설정&quot;&gt;Hostname 설정&lt;/h3&gt;

&lt;h4 id=&quot;설정파일로-변경&quot;&gt;설정파일로 변경&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ hostname
$ sudo vim /etc/hostname
$ sudo reboot
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;hostname을 변경&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;명령어로-변경하기&quot;&gt;명령어로 변경하기&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ hostnamectl set-hostname &quot;Host_name&quot;
$ sudo reboot
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;고정-ip설정&quot;&gt;고정 IP설정&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo vim /etc/netplan/*.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Let NetworkManager manage all devices on this system
network:
  ethernets:
      enp0s31f6:
              dhcp4: no
              dhcp6: no
              #optional: true
              addresses: [192.x.x.x/xx]
              gateway4 : 192.x.x.x
              nameservers:
                      addresses: [8.8.8.8,8.8.4.4]

  version: 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo netplan apply
$ ip addr
$ ip route
$ ifconfig
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://mani4u.tistory.com/88&quot;&gt;서브넷 계산표&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;자동-ip설정&quot;&gt;자동 IP설정&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Let NetworkManager manage all devices on this system
network:
    ethernets:
        enp0s3:
            addresses: []
            dhcp4: true
            optional: true
    version: 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo netplan apply
$ ip addr
$ ip route
$ ifconfig
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;route-확인-route--n&quot;&gt;Route 확인$ route -n&lt;/h3&gt;

&lt;h4 id=&quot;route&quot;&gt;route&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ route
$ route -n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;netstat--r&quot;&gt;netstat -r&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ netstat -r

$ netstat -rn
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;ip&quot;&gt;ip&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ip route list
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>고중범</name></author><category term="Ubuntu" /><summary type="html">Ubuntu 18.04 LTS 네트워크 설정</summary></entry><entry><title type="html">How to install SCALA</title><link href="http://localhost:4000/installation/2020/09/02/how_to_install_scala/" rel="alternate" type="text/html" title="How to install SCALA" /><published>2020-09-02T21:00:00+09:00</published><updated>2020-09-02T21:00:00+09:00</updated><id>http://localhost:4000/installation/2020/09/02/how_to_install_scala</id><content type="html" xml:base="http://localhost:4000/installation/2020/09/02/how_to_install_scala/">&lt;h1 id=&quot;install-scala&quot;&gt;INSTALL SCALA&lt;/h1&gt;

&lt;h4 id=&quot;1-download-targz-file&quot;&gt;1. Download &lt;code class=&quot;highlighter-rouge&quot;&gt;tar.gz&lt;/code&gt; file&lt;/h4&gt;

&lt;p&gt;https://www.scala-lang.org/download/install.html&lt;/p&gt;

&lt;h4 id=&quot;2-extract-file&quot;&gt;2. Extract File&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ tar xvf scala-2.x.x.tgz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;3-move-scala-folder&quot;&gt;3. Move Scala folder&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mv scala-2.x.x /usr/local/share/scala
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;4-set-environment-variable&quot;&gt;4. Set Environment Variable&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vim .bashrc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ export SCALA_HOME=/usr/local/share/scala
$ export PATH=$PATH:$SCALA_HOME/bin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ source .bashrc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;5-restart-terminal-and-check-version&quot;&gt;5. Restart Terminal and Check version&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ scala --version
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>고중범</name></author><category term="Installation" /><summary type="html">SCALA 다운로드 방법</summary></entry><entry><title type="html">GCC란</title><link href="http://localhost:4000/installation/2020/08/20/gcc/" rel="alternate" type="text/html" title="GCC란" /><published>2020-08-20T21:00:00+09:00</published><updated>2020-08-20T21:00:00+09:00</updated><id>http://localhost:4000/installation/2020/08/20/gcc</id><content type="html" xml:base="http://localhost:4000/installation/2020/08/20/gcc/">&lt;p&gt;이 글은 내가 편하게 보겠다고 만든 요약본입니다. &lt;a href=&quot;http://doc.kldp.org/KoreanDoc/html/gcc_and_make/gcc_and_make-1.html&quot;&gt;본문 링크&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;1-gcc&quot;&gt;1. &lt;em&gt;gcc&lt;/em&gt;&lt;/h1&gt;

&lt;p&gt;세상에서 가장 뛰어난 C compiler 중 하나이다. C언어는 컴퓨터 세상의 만국공통어이고, &lt;code class=&quot;highlighter-rouge&quot;&gt;gcc&lt;/code&gt;는 리눅스와 일심동체라고 봐도 무방하다고 한다. (&lt;a href=&quot;http://doc.kldp.org/KoreanDoc/html/gcc_and_make/gcc_and_make-1.html&quot;&gt;여기&lt;/a&gt;서 그랬음..) 저 링크에서 보면 도스/윈도우 환경에서 배운 C가 엉터리라고 하는데, 요즘 &lt;code class=&quot;highlighter-rouge&quot;&gt;Ubuntu&lt;/code&gt;환경에서 C++ 프로그래밍을 하다보면 진짜 맞는거 같다. 도스/윈도우 환경에서 했던거는 하기 쉽게 잘 만들어놔서 코드말고는 신경쓸게 없었다면, 리눅스 환경에서 하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Compile&lt;/code&gt;과정에 대한 이해도 필요하기 때문이다. 지금까지 C는 할 줄 안다고 생각했던게 좀 부끄러워진다. 하지만 이제부터 잘하면 될 일, C의 “ 정통사용법”에 대해서 익혀보자.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;gcc = 1종 보통 수동 스틱방식, 정통 소림권법, 3대째 내려오는 비법 떡갈비집&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;2-gcc-에-대한-기본-이해&quot;&gt;2. &lt;em&gt;gcc&lt;/em&gt; 에 대한 기본 이해&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gcc -version
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;gcc version 출력하기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;gcc&lt;/em&gt; 나도 처음에는 그냥 패키지로 깔 필요도 없이 먼저 깔려있었던 거 같은데, 소스코드로 부터 설치해보면 구조를 파악할 수 있다니 한번 따라가보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/usr/lib/gcc-lib/xxxx/xxxx/cc1
/usr/lib/gcc-lib/xxxx/xxxx/cpp
/usr/lib/gcc-lib/xxxx/xxxx/include/*.h
/usr/lib/gcc-lib/xxxx/xxxx/libgcc.a
/usr/lib/gcc-lib/xxxx/xxxx/specs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;폴더안을 살펴보면 이러한 구조로 되어있는데, &lt;code class=&quot;highlighter-rouge&quot;&gt;cc1&lt;/code&gt;이 C compiler의 본체라고 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;C++ compiler는 &lt;code class=&quot;highlighter-rouge&quot;&gt;cc1plus&lt;/code&gt;, Objective C compiler는 &lt;code class=&quot;highlighter-rouge&quot;&gt;cc1obj&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;아무것도 안해보고 구조를 보면 봐도 뭔지 모를텐데, (사실 지금도 모른다.) &lt;em&gt;gcc&lt;/em&gt;는 C랑 C++ 코드를 구분하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Link&lt;/code&gt; 작업도 하고, 소스를 만들고 하는 선행되어야하는 것들을 해주는 녀석이다.&lt;/p&gt;

&lt;h2 id=&quot;gcc-사용하기&quot;&gt;&lt;em&gt;gcc&lt;/em&gt; 사용하기&lt;/h2&gt;

&lt;p&gt;역시 시작은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Hello, World.&lt;/code&gt;인가보다.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// hello.c
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello, World.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gcc hello.c 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 입력하고, 아무 메세지도 안나오면 성공이다. 대신, 해당 폴더에 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello&lt;/code&gt;라는 파일 하나가 만들어져 있을 것이다. 아래와 같이 입력하면 터미널에 Hello, World가 출력될 것이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./hello
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;-o-옵션&quot;&gt;-o 옵션&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;gcc&lt;/em&gt;에는 여러가지 옵션들이 많이 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;-o&lt;/code&gt;옵션은 Output 파일명을 정하는 옵션이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gcc -o &amp;lt;원하는 파일명&amp;gt; &amp;lt;코드 파일명&amp;gt;
$ gcc &amp;lt;코드 파일명&amp;gt; -o &amp;lt;원하는 파일명&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위에 처럼 해주면 내가 지정한 파일명으로 실행파일이 만들어 질 것이다. (위 두개 방법중 선택하면 된다.)&lt;/p&gt;

&lt;h3 id=&quot;-c--옵션&quot;&gt;-c  옵션&lt;/h3&gt;

&lt;p&gt;오로지 Compile 작업만 하고 싶은 경우에 사용한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gcc -c hello.c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이때 만들어지는 파일은 &lt;code class=&quot;highlighter-rouge&quot;&gt;.o&lt;/code&gt;확장자가 붙어서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object file&lt;/code&gt;, 즉 목적파일 이라고 부른다. (&lt;code class=&quot;highlighter-rouge&quot;&gt;hello.o&lt;/code&gt;) 나중에 코드가 많아지고 복잡해지면, 여러개로 나누어서 모듈화를 잘해서 프로그램을 만들게 되는데, 이때 이 많은 코드들 중에서 하나에서만 main 함수를 가져야한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gcc -o baz foo.c bar.c
$ gcc -c foo.c &amp;amp; gcc -c bar.c
$ gcc -c foo.c bar.c
$ gcc -o baz foo.o bar.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와 같이 여러가지 방식으로 만들 수 있다. 여기서 잠깐 &lt;code class=&quot;highlighter-rouge&quot;&gt;.o&lt;/code&gt;파일이 무엇인지 집고 넘어가자. C언어가 실행파일을 만들어내는 과정을 생각해보면, &lt;code class=&quot;highlighter-rouge&quot;&gt;.c&lt;/code&gt;파일을 &lt;code class=&quot;highlighter-rouge&quot;&gt;.o&lt;/code&gt;파일로 만들고, &lt;code class=&quot;highlighter-rouge&quot;&gt;.o&lt;/code&gt;파일을 실행파일로 만든다.  이때, &lt;code class=&quot;highlighter-rouge&quot;&gt;.c&lt;/code&gt;파일이 &lt;code class=&quot;highlighter-rouge&quot;&gt;.o&lt;/code&gt;파일로 만드는 과정이 Compile 과정이고, &lt;code class=&quot;highlighter-rouge&quot;&gt;.o&lt;/code&gt;파일을 실행파일로 만드는 과정을 Link라고 한다. 이때 Compile 과정은 &lt;em&gt;gcc&lt;/em&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;cc1&lt;/code&gt;이 담당하는 일이고, Link 과정은 ld라는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Linker&lt;/code&gt;가 담당한다. 즉! &lt;em&gt;gcc&lt;/em&gt;란 Compiler와 Linker를 관리하는 외부업체라고 보면 될 것 같다.&lt;/p&gt;

&lt;h3 id=&quot;-l-옵션&quot;&gt;-l 옵션&lt;/h3&gt;

&lt;p&gt;#include 문장에서 지정한 Header file이 들어있는 곳을 정하는 옵션이다. (보기만 해도 중요하고 자주 사용하게 될 것 같다.)  &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;gt;&lt;/code&gt;를 쓴 경우는 시스템표준 헤더가 있는 곳을 기준으로 파일을 찾는다. &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&quot;&lt;/code&gt;를 쓰는 경우는 현재 디렉토리를 기준으로 Header file을 찾는다. 예를 들어 살펴보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gcc -c myprog1.c -I..
$ gcc -c myprog1.c -Iinclude
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;위에꺼는 헤더파일이 (..), 즉 하위폴더에 있다는 의미&lt;/li&gt;
  &lt;li&gt;아래꺼는 include라는 폴더에 있다는 의미&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;여러번 쓸 수 있고, 순서대로 Header file을 찾는다고 한다. 주의해야 할 것은 폴더명은 &lt;code class=&quot;highlighter-rouge&quot;&gt;-l&lt;/code&gt;다음에 띄어쓰기를 하지 않고 바로 써줘야 한다.&lt;/p&gt;

&lt;h3 id=&quot;-l-옵션과--l-옵션&quot;&gt;-l 옵션과 -L 옵션&lt;/h3&gt;

&lt;p&gt;라이브러리가 뭔지 집고 넘어가자. 지금까지는 그냥 단순하게 함수 창고라고 생각하고 구성이 어떤지는 생각안해봤으니까 이번에 해봐야지. Library file의 확장자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;.a&lt;/code&gt;이다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Archive&lt;/code&gt;라는 의미일 것으로 추측된다. 이런 Library file은 &lt;code class=&quot;highlighter-rouge&quot;&gt;.o&lt;/code&gt;확장자를 가진 Object file들을 모아서 관리하는 도서관이라고 할 수 있다. 단순히 모아논게 아니라 체계적으로 정리를 해놨기 때문이다. 프로그래밍에 있어서 뭔가 정리가 되어있고, 순서가 있다면 빠짐없이 나오는 &lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;를 이용해서 정리되어있다. 어떤 Library file이 있다면, 그 안에 어떤 Object file들이 있는지 아래의 명령어로 알 수가 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ar t libc.a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제는 Library file을 만드는 방법을 마찬가지로 예시를 들어서 이해해보자. 그전에 다시한번 좋은 글을 써주신 &lt;a href=&quot;http://doc.kldp.org/KoreanDoc/html/gcc_and_make/gcc_and_make-2.html&quot;&gt;이 글&lt;/a&gt; 저자분께 감사합니다.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// myfunc.h
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;say_hello&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// myfunc.c
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &quot;myfunc.h&quot;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; 
&lt;span class=&quot;nf&quot;&gt;say_hello&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello, Linux guys!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// hello.c
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include &quot;myfunc.h&quot;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;say_hello&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gcc -c myfunc.c
$ ar r libmylib.a myfunc.o // r옵션: 새로운 object file이면 추가, 있던거면 치환
$ ar s libmylib.a // Archive index를 생성
$ ar t libmylib.a // Archive에 있는 file list를 출력
myfunc.o
$ gcc -o say_linux hello.c -lmylib
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;일단 이렇게하면 실패한다. 아래서 어떻게해야 할지 방법을 찾아보자. &lt;em&gt;ar&lt;/em&gt; 명령어 관련 내용은 &lt;a href=&quot;https://devanix.tistory.com/195&quot;&gt;여기&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;-l-옵션-1&quot;&gt;-l 옵션&lt;/h4&gt;

&lt;p&gt;이 녀석은 위에서는 Header file 경로를 나타내는 용도로 사용했었는데, Link할 Library를 명시해주는 용도로도 쓰인다. 마찬가지로 띄어쓰기 없이 바짝 붙여서 사용한다. 위에서 우리가 &lt;code class=&quot;highlighter-rouge&quot;&gt;libmylib.a&lt;/code&gt;라는 파일을 만들어놨는데, &lt;code class=&quot;highlighter-rouge&quot;&gt;-l&lt;/code&gt; 옵션하고 같이 사용할 때는 보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;-lmylib&lt;/code&gt;처럼 &lt;code class=&quot;highlighter-rouge&quot;&gt;lib&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;.a&lt;/code&gt;를 떼고 명시해준다.&lt;/p&gt;

&lt;h4 id=&quot;-l-옵션-2&quot;&gt;-L 옵션&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-L&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;-l&lt;/code&gt;의 다른점을 보면, &lt;code class=&quot;highlighter-rouge&quot;&gt;-l&lt;/code&gt;은 Link할 라이브러리를 명시하는 거라면, &lt;code class=&quot;highlighter-rouge&quot;&gt;-L&lt;/code&gt;은 라이브러리의 위치를 정해주는 옵션이다. Linker에게 라이브러리 위치를 알려주는 역할을 한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gcc -o say_linux hello.c -lmylib -L.&amp;lt;디렉토리 경로&amp;gt;
$ gcc -o say_linux hello.c -lmylib -L. // 현재 디렉토리에서 찾아라
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 두 옵션을 사용하면 성공적으로 컴파일 될 것이다.&lt;/p&gt;

&lt;h1 id=&quot;3-make&quot;&gt;3. Make&lt;/h1&gt;

&lt;p&gt;위에서 &lt;em&gt;gcc&lt;/em&gt;를 이용해서 소스코드를 컴파일하고, Link하고, 실행파일로 만드는 법을 알아봤다. 하지만 프로젝트가 커지게되면 소스코드를 엄청나게 많아지게 되는데, 이럴때마다 &lt;em&gt;gcc&lt;/em&gt;로 노가다 뛰는 것은 별로 하고싶지 않을 것이다. 그래서 이런 과정을 효율적으로 관리하기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt;이라는 형식을 사용한다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Opencv&lt;/code&gt; install 할 때도 그렇고, Darknet setup할 때도 그렇고, &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt;명령을 사용했던 기억이 있는데, 이 명령이&lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt;에서 내용을 읽어와서 Object file을 만들어내는 것 이다.&lt;/p&gt;

&lt;p&gt;하여튼 결국에 이 &lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt;은 효율적이고 일관성있게 코드들을 관리하기 위해서 사용하는 만큼 그 안에 여러가지 규칙들이 있는데, 이런 규칙들을 잘 따라서 작성하는게 중요하다.&lt;/p&gt;

&lt;p&gt;역시 또 예시를 들어서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt;을 어떻게 만들어야 하는지 알아보자. (아래 명령어들은 Terminal에서의 make 명령어 종류들이다.)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ make config           /* 설정 작업을 한다 */
$ make dep              /* 화일 의존성을 검사한다 */
$ make clean            /* 만든 화일들을 지우고 깨긋한 상태로 만든다 */
$ make zImage           /* zImage(압축커널)를 만든다 */
$ make zlilo            /* 커널을 만들고 LILO를 설정한다 */
$ make bzImage          /* bzImage(비대압축커널)를 만든다 */
$ make modules          /* 커널 모듈을 만든다 */
$ make modules_install  /* 커널 모듈을 인스톨한다 */
$ make
$ make all
$ make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;makefile-작성&quot;&gt;Makefile 작성&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gcc -o foo foo.c bar.c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 명령어를 치면 무슨 일이 일어나는지 이제는 안다. &lt;code class=&quot;highlighter-rouge&quot;&gt;foo.c&lt;/code&gt;랑 &lt;code class=&quot;highlighter-rouge&quot;&gt;bar.c&lt;/code&gt;로 &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;라는 Object file을 만드는 것 이다. 이걸 이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt;로 옮겨 작성해보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;목표:	   목표를 만드는데 필요한 것들
		목표를 달성하기 위한 명령 1
		목표를 달성하기 위한 명령 2
=================================
foo:	foo.o bar.o
		gcc -o foo foo.o bar.o
foo.o:	foo.c
		gcc -c foo.c
bar.o: 	bar.c
		gcc -c bar.c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 규칙에 따라서 작성을 해야하고, 실수가 있으면 안된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;각 요소 구분은 콤마가 아니라 띄어쓰기로 한다.&lt;/li&gt;
  &lt;li&gt;다음 줄로 넘어가서는 &lt;Tab&gt;키를 눌러야한다. (스페이스나 다른 키는 사용하면 안된다.)
&lt;/Tab&gt;    &lt;ul&gt;
      &lt;li&gt;명령에 해당하는 줄은 &lt;Tab&gt;키로 시작해야한다. 매우 중요!&lt;/Tab&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;근데 순서를 보면 신기하게도 역순으로 진행되는 꼴이라는 걸 알 수 있다.  &lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt;에서는 사실 이미 있는걸 다시 만들 필요가 없는 구조로 작동하는 것이다. (변화가 있는 파일은 똑똑하게도 &lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt;이 알아서 갱신한다.)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 첫번째 make 명령어
$ make
gcc -c foo.c
gcc -c bar.c
gcc -o foo foo.o bar.o

// foo.c를 고치고 다시 make 명령어
$ make
gcc -c foo.c
gcc -o foo foo.o bar.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;를 만들기 위해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;foo.o&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;bar.o&lt;/code&gt;가 필요한데, 그럼 &lt;code class=&quot;highlighter-rouge&quot;&gt;foo.o&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;foo.c&lt;/code&gt;를 가지고 &lt;code class=&quot;highlighter-rouge&quot;&gt;gcc -c foo.c&lt;/code&gt;를 해야하고, &lt;code class=&quot;highlighter-rouge&quot;&gt;bar.o&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;bar.c&lt;/code&gt;를 가지고 &lt;code class=&quot;highlighter-rouge&quot;&gt;gcc -c bar.c&lt;/code&gt;를 해야하고 이런식으로 되는 것이다.&lt;/p&gt;

&lt;h2 id=&quot;make-clean&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make clean&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;만약 깔끔하게 코드빼고 다 지우고 싶다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;make clean&lt;/code&gt;명령을 사용하면 된다. 그리고 이게 정상적으로 작동하기 위해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt;에 명령을 더 추가해줘야한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;clean:
		rm-f foo foo.o bar.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;추가해주고 Terminal에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;make clean&lt;/code&gt;명령을 해주면 다음과 같은 결과가 나온다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ make clean
rm -f foo foo.o bar.o
$ make
gcc -c foo.c
gcc -c bar.c
gcc -o foo foo.o bar.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;make-all&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make all&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;make all&lt;/code&gt; 명령만 입력하면 깔끔하게 모든 파일 전부 컴파일하도록 만든다. 가장 맨 윗줄에 다음을 추가한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;all: foo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ make all
gcc -c foo.c
gcc -c bar.c
gcc -o foo foo.o bar.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;일반적으로 사람들이 이렇게 많이 하고, 직관적이니까 편의를 위해 이렇게 만들어주는 것도 고려하자.&lt;/p&gt;

&lt;h2 id=&quot;꼬리말-규칙-패턴-규칙&quot;&gt;꼬리말 규칙, 패턴 규칙&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt;에 보면 다음과 같은 표현을 자주 볼 것 이다. (아직 안 뜯어봐서 잘 모르겠지만..)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.c.o:
		gcc -c ${CFLAGS} $&amp;lt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기서 &lt;code class=&quot;highlighter-rouge&quot;&gt;.c.o&lt;/code&gt;의 의미는 “&lt;code class=&quot;highlighter-rouge&quot;&gt;.c&lt;/code&gt;를 입력 파일로 받고, &lt;code class=&quot;highlighter-rouge&quot;&gt;.o&lt;/code&gt;파일로 만든다.”라는 의미를 가지고 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;$&amp;lt;&lt;/code&gt;는 redirection을 의미한다고 하는데, 뭔지는 잘 모르겠지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;.c.o&lt;/code&gt; 에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;.c&lt;/code&gt;부분을 의미하게 되는 것 이다.&lt;/p&gt;

&lt;h2 id=&quot;gnu-make-확장-기능&quot;&gt;GNU make 확장 기능&lt;/h2&gt;

&lt;p&gt;위에 꼬리말, 패턴 규칙보다 더 논리적인 확장 문법이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;%.o: %.c
        gcc -c -o $@ ${CFLAGS} $&amp;lt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;의 오른쪽이 입력파일(&lt;code class=&quot;highlighter-rouge&quot;&gt;.c&lt;/code&gt;), 왼쪽이 Object file(&lt;code class=&quot;highlighter-rouge&quot;&gt;.o&lt;/code&gt;)이 된다. 파일명 대신 &lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt;기호를 사용하는데, 예를들어 &lt;code class=&quot;highlighter-rouge&quot;&gt;foo.c&lt;/code&gt;라는 입력파일이 들어오면 &lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt;가 &lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;를 나타내는 식으로 작동하게 된다.&lt;/p&gt;

&lt;p&gt;기호를 정리하면 다음과 같다.  (감사합니다. &lt;a href=&quot;http://doc.kldp.org/KoreanDoc/html/gcc_and_make/gcc_and_make-3.html&quot;&gt;링크&lt;/a&gt;)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $&amp;lt;     입력 화일을 의미합니다. 콜론의 오른쪽에 오는 패턴을 치환합니다.
 $@     출력 화일을 의미합니다. 콜론의 왼쪽에 오는 패턴을 치환합니다.
 $*     입력 화일에서 꼬리말(.c, .s 등)을 떼넨 화일명을 나타냅니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;macro&quot;&gt;Macro&lt;/h2&gt;

&lt;p&gt;일단 Macro에 대해 간단하게 이야기하면, 변수화한다고 생각하면 될 것 같다. (상수화 일수도 있는데 조금 헷갈린다.) 예를 들면 다음과 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ROOT = /usr/local
HEADERS = $(ROOT)/include
SOURCES = $(ROOT)/src
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그럼 앞에서 나온 &lt;code class=&quot;highlighter-rouge&quot;&gt;${CFLAGS}&lt;/code&gt;는 뭘 의미하고 있는걸까? 써있는 그대로 Flag와 비슷한거 같은데, 설정값이라고 보면 될 것 같다. Terminal에서 해당 설정값을 make할 때 넘겨주고 그것을 받아 처리하는 방식이라고 생각하고 넘어가자. (유닉스 쉘에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;{}&lt;/code&gt;은 변수값을 알아낼 때 쓰는 표현이라고 한다. 이것도 알고 넘어가자.)&lt;/p&gt;

&lt;h1 id=&quot;마무리&quot;&gt;마무리&lt;/h1&gt;

&lt;p&gt;일단 여기까지가  &lt;em&gt;gcc&lt;/em&gt;와 Makefile에 대한 내용이었고, 다른 내용들도 훨씬 많다고 하니 필요할 경우 찾아보며 진행하면 될 것 같다. &lt;a href=&quot;http://doc.kldp.org/KoreanDoc/html/gcc_and_make/gcc_and_make-3.html&quot;&gt;본문&lt;/a&gt;에는 마지막 부분에 주의사항이 있으니 한번씩 읽어보고, 이정도면 일단은 될 것 같다.&lt;/p&gt;</content><author><name>고중범</name></author><category term="Installation" /><summary type="html">GCC 입문자용</summary></entry><entry><title type="html">Aran님의 유튜브 발음시리즈</title><link href="http://localhost:4000/english/2020/05/21/English_Conversation-post/" rel="alternate" type="text/html" title="Aran님의 유튜브 발음시리즈" /><published>2020-05-21T21:00:00+09:00</published><updated>2020-05-21T21:00:00+09:00</updated><id>http://localhost:4000/english/2020/05/21/English_Conversation-post</id><content type="html" xml:base="http://localhost:4000/english/2020/05/21/English_Conversation-post/">&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=dDoc2afLtyM&quot;&gt;Youtube Aran TV 발음시리즈&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;매끄럽고-매력적인-말하기의-3가지-원칙&quot;&gt;매끄럽고 매력적인 말하기의 3가지 원칙&lt;/h1&gt;

&lt;p&gt;언어란 문화 어휘 문법 &lt;strong&gt;발음&lt;/strong&gt;으로 이루어져있다.&lt;/p&gt;

&lt;p&gt;소통을 하기위해선 발음이 중요하다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;외국인들이 너의 언어를 잘 알아듣지 못하는 이유&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;발음자체가 문제&lt;/li&gt;
  &lt;li&gt;1음절 단어를 2음절로 발음&lt;/li&gt;
  &lt;li&gt;2음절에 강세가 있는 단어를 1음절에 강세를 주는 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;-&amp;gt; &lt;strong&gt;언어는 약속이고, 발음에는 정답이 있다. (복수정답이 있다.)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;존중해야하는건 억양이다.(Accent, 말투) 정답이 없다!&lt;/p&gt;

&lt;p&gt;발음과 억양을 바꾸려면 &lt;strong&gt;[듣기 - 연습 - 녹음 - 교정]&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;외국인처럼 하려면 어떻게 해야할까?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;문장에서 중요한 단어는 강조&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;붙어있는 단어는 연음&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;듣고 따라하기&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;절대로 외국어 소리를 모국어로 옮겨적어서 외우면 안된다.&lt;/p&gt;

&lt;p&gt;듣는 것 또한 굉장히 중요하다. 들리지않으면 발음할 수가 없다. 따라하고싶은 사람이 말하는 것을 듣고 따라해라. ex) Donald John Trump, Robert Anthony De Niro, Jeffrey Warren Daniels&lt;/p&gt;

&lt;p&gt;이것이 바로 쉐도잉 (shadowing)&lt;/p&gt;

&lt;p&gt;강약, 속도, 말투, 표정, 몸동작을 따라하면서 마치 자신이 그 사람이 된 것처럼 연습해라.&lt;/p&gt;

&lt;h1 id=&quot;제-1원칙-정확성-accuracy&quot;&gt;제 1원칙 정확성 (Accuracy)&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;자음과 모음의 소리를 똑바로&lt;/li&gt;
  &lt;li&gt;발음을 끝까지&lt;/li&gt;
  &lt;li&gt;음절을 시켜서&lt;/li&gt;
  &lt;li&gt;강세를 살려서&lt;/li&gt;
  &lt;li&gt;장음은 장음답게&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;자음과-모음의-소리를-똑바로&quot;&gt;자음과 모음의 소리를 똑바로&lt;/h2&gt;

&lt;p&gt;한끗차이로 들릴 수 있지만, 영어 사용자에게는 아니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;B vs V&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;P vs F&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;R vs L&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;B는 입술을 모았다가 퍼지는게핵심&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;손에 바람이 안느껴지도록&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;V는 입술이 만나지 않는다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;윗니가 아랫니를 살짝 문다는 느낌으로&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;R는 혀를 뒤로가서 입천장에 닿지않음&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;입술을 살짝 앞으로 내밀어봐&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;L은 앞니를 딱 친다는 느낌&lt;/p&gt;

&lt;p&gt;th는 혀가 윗니아랫니 사이로 들어온다&lt;/p&gt;

&lt;p&gt;W는  워, 우어 이런소리&lt;/p&gt;

&lt;p&gt;Z는 모기가 윙윙거리는소리&lt;/p&gt;

&lt;p&gt;모음은 a,e,i,o,u,y이 있는데 발음하기 까다롭다. 한국어 모음발음에서 두가지정도가 섞인 발음이 나기 때문이다.&lt;/p&gt;

&lt;h2 id=&quot;끝까지-발음하자&quot;&gt;끝까지 발음하자&lt;/h2&gt;

&lt;p&gt;단어를 발음할때, 마지막 알파벳까지 전부 발음하도록&lt;/p&gt;

&lt;p&gt;Etha&lt;strong&gt;n&lt;/strong&gt;, Mo&lt;strong&gt;m&lt;/strong&gt;, Singin&lt;strong&gt;g&lt;/strong&gt;, An&lt;strong&gt;d&lt;/strong&gt;, Bac&lt;strong&gt;k&lt;/strong&gt;, Grea&lt;strong&gt;t&lt;/strong&gt;, Technolog&lt;strong&gt;y&lt;/strong&gt;등등&lt;/p&gt;

&lt;h2 id=&quot;음절을-지켜-발음하자&quot;&gt;음절을 지켜 발음하자&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Changed은 1음절. Chan/ged 아니다.
    &lt;ul&gt;
      &lt;li&gt;1음절 예시: Chris, Sprite,&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;모음의 개수에 따라 음절이 나뉜다.&lt;/p&gt;

&lt;h2 id=&quot;강세를-살려서-발음하자&quot;&gt;강세를 살려서 발음하자&lt;/h2&gt;

&lt;p&gt;강세가 없는 단어는 이 세상에 없다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;R&lt;strong&gt;i&lt;/strong&gt;ver는 첫음절에 강세&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Hot&lt;strong&gt;e&lt;/strong&gt;l, Pol&lt;strong&gt;i&lt;/strong&gt;ce, Ol&lt;strong&gt;y&lt;/strong&gt;mpic은 두번째 음절에 강세&lt;/li&gt;
  &lt;li&gt;Repres&lt;strong&gt;e&lt;/strong&gt;ntative은 세번째 음절에 강세&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;모르는 단어는 강세도 표시하면서 연습하기&lt;/p&gt;

&lt;h2 id=&quot;장음은-길게-발음하자&quot;&gt;장음은 길게 발음하자&lt;/h2&gt;

&lt;p&gt;장음이란 말그대로 긴 소리&lt;/p&gt;

&lt;p&gt;언제 길게 소리를 내야하냐면,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모음이 두개 이상일 때
    &lt;ul&gt;
      &lt;li&gt;두개인 만큼 더 길게&lt;/li&gt;
      &lt;li&gt;See, Keep, Sleeves, Peace, Soon, Cool&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;o 발음시 종종
    &lt;ul&gt;
      &lt;li&gt;o[ou] 처럼 살짝길게&lt;/li&gt;
      &lt;li&gt;Over, Phone, Cross&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;제-2원칙-유창성-fluency&quot;&gt;제 2원칙 유창성 Fluency&lt;/h1&gt;

&lt;p&gt;술술 물흐르듯이 말하는 방법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자연스러운 연음&lt;/li&gt;
  &lt;li&gt;적절한 끊어읽기&lt;/li&gt;
  &lt;li&gt;적당한 속도&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;자연스러운-연음&quot;&gt;자연스러운 연음&lt;/h2&gt;

&lt;p&gt;글자와 글자, 단어와 단어, 문장과 문장을 이어서 말한다. 외워서하는게 아니라 그냥 자연스럽게 매끄럽게 하면된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Hityou withthat DDu-Du DDu-Du Du&lt;/li&gt;
  &lt;li&gt;I&lt;strong&gt;mo&lt;/strong&gt;nly one cal&lt;strong&gt;la&lt;/strong&gt;way&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;적절히-끊어읽기&quot;&gt;적절히 끊어읽기&lt;/h2&gt;

&lt;p&gt;적절하게 쉬어가면서 말하는게 더 유창하고 매력적이다. 의미별로, 구별로, 문장별로 끊어읽는다.&lt;/p&gt;

&lt;h2 id=&quot;적당한-속도&quot;&gt;적당한 속도&lt;/h2&gt;

&lt;p&gt;연습해야된다. 아무리 문장구조가 좋아도 속도가 너무 느리면 유창하게 느껴지지 않는다. 새로운 문장을 왠만한 속도로 읽을 수 있도록 연습해야한다. 물흐르듯이 계속반복, 생각하지않고도 입이 먼저 움직일때까지 연습해라.&lt;/p&gt;

&lt;h1 id=&quot;제-3원칙-전달력-delivery&quot;&gt;제 3원칙 전달력 Delivery&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;매력적인&lt;/strong&gt;에 해당하는 부분이다.&lt;/p&gt;

&lt;p&gt;전달력의 두가지 핵심&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;중요한 말은 강조해서 말하기
    &lt;ul&gt;
      &lt;li&gt;성량의 변화&lt;/li&gt;
      &lt;li&gt;속도&lt;/li&gt;
      &lt;li&gt;어조의 변화&lt;/li&gt;
      &lt;li&gt;쉬는 박자의 변화&lt;/li&gt;
      &lt;li&gt;표정과 제스쳐의 변화&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;감정을 강조하자&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;중요한-말을-강조하자&quot;&gt;중요한 말을 강조하자&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;성량의 변화
    &lt;ul&gt;
      &lt;li&gt;중요한 단어에서 성량에 변화를 준다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;속도
    &lt;ul&gt;
      &lt;li&gt;중요한 곳은 천천히 강조하면서 말하기&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;어조의 변화
    &lt;ul&gt;
      &lt;li&gt;말하고자 하는곳은 조금 더 올리거나 내려서 강조&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;쉬는 박자의 변화
    &lt;ul&gt;
      &lt;li&gt;강조할려고하는건 앞에서 한번 쉬고 말하기&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;표정과 제스쳐의 변화
    &lt;ul&gt;
      &lt;li&gt;난 못해&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;중요한지 아닌지는 품사가 결정하는게 아니라, 의미가 결정하는 것이다.&lt;/p&gt;

&lt;p&gt;I was in the second building.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;나를 강조하려면 I에 강조&lt;/li&gt;
  &lt;li&gt;과거에 있던 일이라는 걸 강조하려면 was에 강조&lt;/li&gt;
  &lt;li&gt;Building 안에 있었다는 걸 강조하려면 in에 강조&lt;/li&gt;
  &lt;li&gt;등등등..&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;감정을-강조하자&quot;&gt;감정을 강조하자&lt;/h2&gt;

&lt;p&gt;감정을 담아서 진심으로 이야기해라. 내가 내 이야기를 해야 매력적이다. 청자가 꼭 들었으면 좋겠다는 생각으로 말해라.&lt;/p&gt;

&lt;p&gt;Donald John Trump 연설 중..&lt;/p&gt;

&lt;p&gt;Thank you Klaus very much. It’s a privilege to be here at this forum where leaders in business, science, art, diplomacy and world affairs have gathered for many many years to discuss how we can advance prosperity, security and peace. I’m here today to represent the interests of the american people and to affirm America’s friendship and partnership in building a better world, like all nations represented at this great forum.&lt;/p&gt;

&lt;p&gt;[Vocabulary] 1. Privilege : a special advantage that is given only to one person or group of people 2. Diplomacy : The job or activity of managing the relationships between countries 3. Affirm : to strengthen a feeling, belief, or idea&lt;/p&gt;</content><author><name>고중범</name></author><category term="English" /><summary type="html">Aran님의 유튜브 발음시리즈</summary></entry><entry><title type="html">OS Lecture 6</title><link href="http://localhost:4000/os/2020/04/28/OS6-post/" rel="alternate" type="text/html" title="OS Lecture 6" /><published>2020-04-28T21:00:00+09:00</published><updated>2020-04-28T21:00:00+09:00</updated><id>http://localhost:4000/os/2020/04/28/OS6-post</id><content type="html" xml:base="http://localhost:4000/os/2020/04/28/OS6-post/">&lt;p&gt;유튜브 &lt;a href=&quot;https://www.youtube.com/channel/UCHvXywxOtwLedY5OX-Teg5w&quot;&gt;HPC Lab. KOREATECH 채널&lt;/a&gt;, 김덕수 교수님의 OS 강의를 보고 정리한 내용입니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;lecture-6&quot;&gt;Lecture 6&lt;/h1&gt;

&lt;h1 id=&quot;process-synchronization&quot;&gt;Process Synchronization&lt;/h1&gt;

&lt;p&gt;다중 프로그래밍 시스템 환경 (Multi-Programming)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Process가 여러개이다.&lt;/li&gt;
  &lt;li&gt;Process들은 서로 독립적으로, 동시에 동작한다.&lt;/li&gt;
  &lt;li&gt;공유 자원 또는 데이터가 있을 때, 문제가 발생한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;다중프로그램 시스템 환경에서 Error가 발생하지 않으려면 프로세스끼리의 ‘대화’ 또는 ‘협약’이 필요하다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;-&amp;gt; 동기화가 필요하다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Synchronization (동기화)&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스들이 서로 동작을 맞추는 것&lt;/li&gt;
  &lt;li&gt;프로세스들이 서로 정보를 공유하는 것&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;asynchronous-and-concurrent-ps&quot;&gt;Asynchronous and Concurrent P’s&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Asynchronous&lt;/strong&gt; (비동기화)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스들이 서로 대화를 안하고 개인행동하는 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Concurrent&lt;/strong&gt; (병행)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;여러 프로세스들이 동시에 동작하는 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;‘병행’ 수행중인 ‘비동기적’인 프로세스들이 공유 자원에 동시에 접근하면 문제 발생&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;-&amp;gt; 프로세스간의 대화없이 같은 공간에 작업하게 되면 문제가 발생한다. (위에서 말했던 에러가 발생하는 원인)&lt;/p&gt;

&lt;h2 id=&quot;terminologies&quot;&gt;Terminologies&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Shared data (공유 데이터)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;여러 프로세스들이 공유하는 데이터&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Critical section (CS, 임계 영역)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Shared data를 접근하는 코드 영역&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Mutual exclusion (상호배제)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;둘 이상의 프로세스가 동시에 CS에 진입하지 못하도록 막는 것&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;critical-section&quot;&gt;Critical Section&lt;/h2&gt;

&lt;p&gt;사용자가 작성한 Code는 Compiler에 의해 &lt;strong&gt;Machine instruction (기계어 명령)&lt;/strong&gt;로 바뀐다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Machine Instructions are commands or programs written in machine code of a machine (computer) that it can recognize and execute.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Atomicity&lt;/strong&gt; : 쪼갤 수 없다. 중간에 방해할 수 없다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Individible&lt;/strong&gt; : 분리가 불가능하다&lt;/p&gt;

    &lt;p&gt;-&amp;gt; 명령 실행 도중에 Interrupt를 받지 않는것이 보장된다. (Non-preemption)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;예를 들어, 2개의 Process가 shared data에 동시에 1을 더하려고 할 때, &lt;strong&gt;결과는 기계어 명령 수행 과정에 따라서 1또는 2로 달라질 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;-&amp;gt; 이런 상태를 &lt;strong&gt;Race condition&lt;/strong&gt;이라고 한다. (동시에 접근할 때 자료의 일관성을 해치는 결과가 나타날 수 있다.)&lt;/p&gt;

&lt;h2 id=&quot;mutual-exclusion-상호배제&quot;&gt;Mutual Exclusion (상호배제)&lt;/h2&gt;

&lt;p&gt;: 한 Process가 Critical section에 대해서 실행되는 동안, 다른 Process가 못들어오게 막는 것이다. (항상 원하는 결과를 도출하기 위해 지켜져야하는 규칙 중 하나!)&lt;/p&gt;

&lt;h2 id=&quot;mutual-exclusion-methods&quot;&gt;Mutual Exclusion Methods&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Mutual exclusion primitives&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;enterCS() primitive&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Critical section 진입 전 검사 (안에 다른 Process가 있는지 검사한다.)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;exitCS( primitive)&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Critical section을 벗어났음을 시스템에 알린다. (후처리 과정)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;primitives란 보통 가장 기본이 되는 연산을 의미한다. 위 연산들을 구현해야하는데, 조건이 있다.&lt;/p&gt;

&lt;h3 id=&quot;requirements-for-me-primitives&quot;&gt;Requirements for ME primitives&lt;/h3&gt;

&lt;p&gt;구현을 할 때, 만족해야할 조건 3가지가 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Mutual exclusion (상호배제)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;CS에 있으면 못들어오게 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Progress (진행)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;CS에 아무도 없으면 들어갈 수 있도록 해야된다. (방해하면 안된다.)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Bounded waiting (한정대기)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;제한시간 내에 CS로 들어갈 수 있어야 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;sw-solutions&quot;&gt;SW Solutions&lt;/h2&gt;

&lt;h3 id=&quot;two-process-mutual-exclusion&quot;&gt;Two Process Mutual Exclusion&lt;/h3&gt;

&lt;h4 id=&quot;첫번째-시도&quot;&gt;&lt;strong&gt;첫번째 시도&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;: Turn을 사용해서 구현한다. (유희왕, 하스스톤같은 게임의 Turn하고 똑같음)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Process A, Process B가 있다.&lt;/li&gt;
  &lt;li&gt;Turn이 0이면  A의 차례, Turn이 1이면 B의 차례다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;자신의 차례가 오면 일을하고, 나올때 상대에게 차례를 넘겨준다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위와 같은 순서로 진행된다.&lt;/p&gt;

&lt;p&gt;조건을 만족하는지 체크해보면, &lt;strong&gt;Progress의 조건을 만족하지 못한다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Process A가 뻉뻉돌다가 죽어버리면 Turn을 넘겨받지 못해서 CS가 비었음에도 들어가지 못하게 된다.
    &lt;ul&gt;
      &lt;li&gt;상대에게 차례를 넘겨주지 못할 때&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;한 Process가 두 번 연속 CS에 진입 불가하다. (다른 프로세스에게 Turn을 넘겨받아야만 하기 때문이다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;아쉽게도 조건을 위배한다.&lt;/p&gt;

&lt;h4 id=&quot;두번째-시도&quot;&gt;&lt;strong&gt;두번째 시도&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;: Flag를 사용하여 구현한다.&lt;/p&gt;

&lt;p&gt;CS에 들어갈꺼면 깃발을 들고, 나왔으면 깃발을 내린다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;2개의 Process가 있다.&lt;/li&gt;
  &lt;li&gt;상대편의 깃발을 본다
    &lt;ul&gt;
      &lt;li&gt;들려있으면? -&amp;gt; 기다린다.&lt;/li&gt;
      &lt;li&gt;내려가있으면? -&amp;gt; 들어간다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;내 일이 끝나면 깃발을 내리고 나온다.&lt;/li&gt;
  &lt;li&gt;상대편이 내려간 내 깃발을 보고 들어온다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위와 같은 순서로 진행된다.&lt;/p&gt;

&lt;p&gt;조건을 만족하는지 체크해보면, 내 깃발은 내려가 있는 상태고, 상대 깃발이 내려가 있는걸 보고 깃발을 들려고 하는데 Preemption된 경우에&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;상대가 와서 내 깃발이 내려가있는걸 보고 먼저 CS로 들어간다.&lt;/li&gt;
  &lt;li&gt;나는 다시 자원할당받아서 하려던거 마저 하기위해 CS로 들어간다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;-&amp;gt; Mutual exclusion 조건에 위배한다.&lt;/p&gt;

&lt;p&gt;상대 깃발을 체크하고, CS에 들어가기 직전에 깃발을 들어서 문제가 된다.&lt;/p&gt;

&lt;p&gt;여기서 착각하면 안되는 것은, 위에서 Machine instruction이 Atomicity한 특성을 가지고 있고, 중간에 Preemption이 일어날 수 없다고 했는데, Code의 줄 사이사이에서 Preemption이 일어난다. 예를들어,&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Preemption 발생
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 Code가 있다고 했을 때, a=3을 수행하고, b=4를 수행하려는데 Preemption이 발생할 수도 있다는 것이다.&lt;/p&gt;

&lt;h4 id=&quot;세번째-시도&quot;&gt;&lt;strong&gt;세번째 시도&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;: 두번째와 비슷한데 순서가 다르다. 이번에는 들어갈거라고 먼저 깃발을 든다. (깃발을 먼저 들고, 상대를 체크하는 순서로 바뀌었다.)&lt;/p&gt;

&lt;p&gt;Progress, Bounded waiting 조건을 위반한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;2개의 프로세스가 동시에 왔다가 서로 깃발을 올린것을 보고 아무도 안들어갈 수도 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mutual-exclusion-solutions&quot;&gt;Mutual Exclusion Solutions&lt;/h3&gt;

&lt;h4 id=&quot;dekkers-algorithm&quot;&gt;Dekker’s Algorithm&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Process가 2개일 때, Mutual exclusion을 보장하는 최초의 알고리즘이다.&lt;/li&gt;
  &lt;li&gt;Flag와 Turn을 동시에 쓴다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;순서&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;2개의 Process가 있다.&lt;/li&gt;
  &lt;li&gt;Process 하나가 깃발을 든다.
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;상대가 깃발을 안 들고 있다면 바로 CS로 들어간다.&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;상대가 깃발을 들었다면 Turn을 체크한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Turn을 체크한 다음 내 Turn이 아니면 깃발을 내리고 Turn이 돌아오기를 기다린다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;일을 하고나서 CS에서 빠져나오면서 Turn을 넘긴다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;나머지 Process가 들어가서 일한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;앞선 시도와 다른점은 상대가 깃발을 안 들고 있었음에도 불구하고 못들어가는 문제가 있었었는데, 상대가 깃발을 안 들고 있다면 바로 CS로 들어가게 함으로써 이 문제를 해결했다.&lt;/p&gt;

&lt;h4 id=&quot;petersons-algorithm&quot;&gt;Peterson’s Algorithm&lt;/h4&gt;

&lt;p&gt;: Dekker의 알고리즘을 간단하게 만든 것이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;순서&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;2개의 Process가 있다.&lt;/li&gt;
  &lt;li&gt;Process 하나가 깃발을 들고, &lt;strong&gt;Turn을 양보한다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;상대가 깃발을 들고있고, 상대방 Turn이면 기다린다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Turn을 넘겨주는게 아니라, 양보한다는 것이 Dekker’s algorithm과 다른점이다.&lt;/p&gt;

&lt;h3 id=&quot;n-process-mutual-exclusion-solutions&quot;&gt;N-Process Mutual Exclusion Solutions&lt;/h3&gt;

&lt;p&gt;Process가 여러개 있을 때의 Mutual Exclusion를 만족하기위한 해결책들&lt;/p&gt;

&lt;h4 id=&quot;dijkstra-algorithm-다익스트라-알고리즘&quot;&gt;Dijkstra Algorithm (다익스트라 알고리즘)&lt;/h4&gt;

&lt;p&gt;대단한 분이라서 이분 이름을 딴 알고리즘이 많다.&lt;/p&gt;

&lt;p&gt;지금은 Mutual exclusion에 대한 다익스트라 알고리즘을 다룬다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;마찬가지로 Turn과 Flag를 사용하는데, Flag의 state가 3개&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;idle&lt;/strong&gt; (CS 진입을 시도하고 있지 않는 단계)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;want-in&lt;/strong&gt; (CS 진입을 하고 싶은 의사를 밝히는 단계)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;in-CS&lt;/strong&gt; (CS 진입을 하기 직전의 단계)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;want-in(1단계)과 in-CS(2단계)를 둘다 통과해야 CS에 들어갈 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Want-in 단계 과정&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$P_i$가 CS에 들어가고 싶다고 말한다. (flag state를 want-in으로)&lt;/li&gt;
  &lt;li&gt;자기 Turn이 아니면 상대의 State가 idle이 될 때까지 체크하면서 기다린다.&lt;/li&gt;
  &lt;li&gt;상대의 일이 끝나는 순간 Turn을 자기껄로 뺏어오고, in-CS State로 진입한다.
    &lt;ul&gt;
      &lt;li&gt;이 과정에서 여러 Process들이 Turn가지고 싸운다. 뺏고 뺏기고 난리치면서 여러개의 Process가  2단계로 진입&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;In-CS 단계 과정&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;flag state를 in-CS로 바뀐다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;j라는 반복를 위한 변수을 사용하여 while문을 돌린다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Case 1. j &amp;lt; n(Process의 수) - 1&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;반복문이 끝까지 다 돌았을 때&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Case 2. (j == i) or (flag[j] != in-CS)
        &lt;ul&gt;
          &lt;li&gt;j가 i 가 아니고, flag[j] 가 in-CS state일 경우&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;in-CS state인 Process가 나보다 먼저 있음&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;Case 2의 경우에는 다시 처음으로 돌아간다. Case 1의 경우에는 CS로 $P_i$가 들어간다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;여기까지가 Softeware적으로 Mutual Exclusion을 구현하기위한 방법이었다. 단점은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;속도가 느리다.&lt;/li&gt;
  &lt;li&gt;구현이 복잡하다.&lt;/li&gt;
  &lt;li&gt;Code 실행 중간에 Preemption 될 수 있다.
    &lt;ul&gt;
      &lt;li&gt;OS가 도와줘서 interrupt를 막을 수 있지만 overhead가 발생한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;아무것도 안하면서 기다리는게 아니라 뺑뺑돌면서 기다린다. (Busy waiting)
    &lt;ul&gt;
      &lt;li&gt;Busy waiting은 비효율적이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;hw-solution&quot;&gt;HW solution&lt;/h2&gt;

&lt;p&gt;SW solution을 썻는데 비효율적이었다. 그래서 Hardware적 차원에서 도움을 받아 새로운 Solution을 만들었다.&lt;/p&gt;

&lt;h3 id=&quot;testandset-tas-instruction&quot;&gt;TestAndSet (TAS) instruction&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Test와 Set을 한번에 수행하는 “기계어” -&amp;gt; &lt;strong&gt;수행중에 interrupt를 받지 않는것이 보장된다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Busy waiting&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;앞에서 Machine instruction은 atomicity하고 individible이었지만,&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;코드의 줄 사이에서 개입이 일어날 수 있다고 했다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;여기서 TestAndSet instruction은 여러줄의 Machine instruction을 묶어서 한번에 수행하도록 만든 것 같은 느낌..&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TestAndSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// target에 temp 기록
&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 포인터로 temp를 true로 설정
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// return true
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;여러줄의 Machine instructions가 한번에 수행되도록 만들어놨기 때문에, 중간에 Interrupt가 없어서, Mutual Exclusion이 간단하게 구현되었다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;me-with-tas-instruction&quot;&gt;ME with TAS instruction&lt;/h3&gt;

&lt;p&gt;Mutual exclusion은 쉽게 해결을 했지만, 프로세스가 3개 이상이 될 경우 Bounded waiting 조건을 위배한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;프로세스 여러개가 있다. {1,2,3,…}&lt;/li&gt;
  &lt;li&gt;1번이 CS에 들어가서 일을 하고 있고, 2번3번은 뺑뺑 돌고있다.&lt;/li&gt;
  &lt;li&gt;1번이 일을 다 마치고 나간다.&lt;/li&gt;
  &lt;li&gt;3번이 먼저 들어와서 일하는 도중에 4번이 들어와서 2번과 같이 뺑뺑 돈다.&lt;/li&gt;
  &lt;li&gt;3번이 끝나고 나갔는데 4번이 먼저 들어가서 일을 한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;위처럼 운이 나쁘면 못들어가서 Bounded waiting조건을 위배하게 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그래도 의미있는건 TAS라는 구조로 Mutual exclusion이 쉽게 해결되었다는것 이다.&lt;/p&gt;

&lt;p&gt;그렇다면 3개 이상의 Process가 있는 환경에서 모든 조건을 부합하려면 어떻게 해야할까?&lt;/p&gt;

&lt;p&gt;-&amp;gt; &lt;strong&gt;waiting이라는 새로운 변수를 사용한다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;기다려야하면 True, 기다리지 않아도 되면 False&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;내가 CS에서 일을 마치고 나오면 while문으로 내 뒤에 &lt;strong&gt;대기중인 프로세스를 찾는다.&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Process i 의 진입 영역
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;waiting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;waiting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TestAndSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;waiting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Critical section
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;waiting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 대기중인 프로세스를 찾는다.
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		   &lt;span class=&quot;c1&quot;&gt;// i 뒤로 순서대로 검사
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 					   &lt;span class=&quot;c1&quot;&gt;// 대기중인 프로세스가 없을 때, j는 i와 같을 것이다.
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;waiting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;구현이 간단하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;Busy waiting
        &lt;ul&gt;
          &lt;li&gt;TAS안에서 뺑뺑 돌고있어야 한다는 문제가 있다. (여기서도 역시나 Busy waiting 문제)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;os-supported-sw-solution&quot;&gt;OS supported SW solution&lt;/h2&gt;

&lt;p&gt;이번에는 OS의 도움을 받아 Mutual Exclusion을 구현하는 방법을 살펴보자.&lt;/p&gt;

&lt;h3 id=&quot;spinlock&quot;&gt;Spinlock&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;정수형 변수 S를 사용한다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;S에는 초기화, P(), V() operation으로만 접근이 가능하다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;위 연산들은 Atomicity한 특성을 가지고 있음
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;OS가 이 연산들의 Atomicity를 보장한다.&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;TAS처럼 여러 Machine instructions가 한번에 수행된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;각각 네덜란드어로 Proberen(시도), Verhogen(증가)의 의미를 가지고 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// P()는 물건의 개수 or 자물쇠를 거는 것
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 물건이 없다면, 물건이 생기기를 while문 안에서 기다린다.
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;endwhile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 물건이 있어서 while문을 빠져나왔다면, 물건을 하나 가져간다. -&amp;gt; S-1
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// V()는 물건을 집어넣는 것 or 자물쇠를 푸는 것
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 물건을 집어넣는다 -&amp;gt; S+1
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;OS가 서포트해주는 Spinlock이라는 Operation으로 Mutual exclusion이 간단하게 구현된다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CS에 들어갈 때 P()로 문을 잠근다.&lt;/li&gt;
  &lt;li&gt;CS에 V()로 문을 열어두고 나온다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;P()와 V()는 Atomicity가 보장되기 때문에,&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;중간에 Preemption되지 않아서, 동시에 들어가거나 아무도 못들어가는 문제는 발생하지 않는다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;-&amp;gt; OS가 도와주니까 쉽게 구현할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Spinlock의 문제점&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Multi-processor 환경에서만 가능하다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;ex)&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;CPU가 하나일 때, Pi가 CS에 들어와서 일을 한다. S는 1에서 0이 되었다.&lt;/li&gt;
      &lt;li&gt;Pi가 CS에서 멈췄다.&lt;/li&gt;
      &lt;li&gt;PJ가 CPU를 할당받았지만, Pi가 V() operation을 수행하지 못해서 Pj는 P()에서 계속 뻉뻉 돌아야한다.&lt;/li&gt;
      &lt;li&gt;결국 Pi와 Pj 둘 다 일을 못하게 된다.&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;-&amp;gt; CPU가 여러개가 있어야 Pi와 Pj가 동시에 돌아가야 Logic이 성립한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;여전히 Busy waiting 문제가 있다.&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;semaphore&quot;&gt;Semaphore&lt;/h3&gt;

&lt;p&gt;1965년에 Dijkstra가 제안 (이분 또 나오시네)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이번에도 S를 사용하는데, &lt;strong&gt;S는 이번에는 음이 아닌 정수형 변수!&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;임의의 S변수 하나에 Ready queue하나가 할당 된다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;이게 어떤 역할을 할지 중점적으로 보자.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;두가지 종류의 Semaphore가 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Binary Semaphore&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;S가 0또는 1, 두 종류의 값만 갖는다.&lt;/li&gt;
      &lt;li&gt;Mutual exclusion문제에 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Counting Semaphore&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;S가 0이상의 정수값을 갖는다.&lt;/li&gt;
      &lt;li&gt;Producer-Consumer문제 등을 해결하기 위해 사용한다.(?)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Spinlock과 무엇이 다를지 코드와 함께 살펴보자.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
        &lt;span class=&quot;c1&quot;&gt;//여기서 queue가 대기실 역할을 한다. Busy waiting 문제해결
&lt;/span&gt;	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Q_s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//Queue안에 대기하는 Process가 있으면
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Q_s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wakeup&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;one&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;them&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Spinlock과 다른점은 Busy waiting문제가 없다는점! 각각의 S 하나마다 대기실(Ready queue)를 할당했기 때문이다.이런식으로 여러 Synchronization문제를 해결할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;process-synchronization-with-semaphore&quot;&gt;Process Synchronization with Semaphore&lt;/h4&gt;

&lt;p&gt;Process들의 실행순서를 맞출 수 있다. P()와 V()를 이용해서 프로세스간의 순서를 결정한다.&lt;/p&gt;

&lt;h4 id=&quot;producer-consumer-problem-with-semaphore&quot;&gt;Producer-Consumer Problem with Semaphore&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Producer는 Data를 생산해내는 녀석들 (Buffer에 쌓아둠)
    &lt;ul&gt;
      &lt;li&gt;프린터 드라이버&lt;/li&gt;
      &lt;li&gt;컴파일러&lt;/li&gt;
      &lt;li&gt;어셈블러&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Consumer들은 이 Data를 가져다가 쓰는 녀석들&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Producer가 생산해내는 Data는 Buffer에 저장된다. 여러개의 Producer와 Consumer가 있기때문에 Buffer에 접근하는것에 대해서 동기화가 필요하다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ex) Single bufer에서의 Producer-Consumer Problem&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Buffer에는 한번에 한 녀석만 접근해야된다. 2개의 Semaphore 변수를 선언해서 사용한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Consumed (소비되었니?)&lt;/li&gt;
  &lt;li&gt;Produced (생산되었니?)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Producer 입장에서&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;생산자가 Buffer에 Data를 넣을때 Buffer가 비었는지(소비되었는지) 체크 (Semaphore &amp;lt;- 0)
    &lt;ul&gt;
      &lt;li&gt;비었으면 생산하고 Produce했다고 표시한다. (Semaphore &amp;lt;- 1)&lt;/li&gt;
      &lt;li&gt;비어있지 않으면 대기실에서 기다린다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Consumer 입장에서&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Buffer에 물건이 있는지(생산되었는지) 체크 (Semaphore &amp;lt;- 1)
    &lt;ul&gt;
      &lt;li&gt;비었으면 대기실에서 기다린다. (생산이 되면 Producer가 깨워줌)&lt;/li&gt;
      &lt;li&gt;비어있지 않으면 들어가서 Data를 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;ex) N개의 buffer에서의 Producer-Consumer Problem&lt;/strong&gt;에서,&lt;/p&gt;

&lt;p&gt;생산자도 여러명이고 소비자도 여러명, Buffer도 여러개일때는?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이중으로 P()와 V()를 사용&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;겉부분의 P()와 V()
    &lt;ul&gt;
      &lt;li&gt;mutexP : 다른 Producer가 있는지 확인하기 위한 변수&lt;/li&gt;
      &lt;li&gt;mutexC : 다른 Consumer가 있는지 확인하기 위한 변수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;안부분의 P()와 V()
    &lt;ul&gt;
      &lt;li&gt;nrfull : Consumer입장에서 buffer가 얼만큼 차있는지 확인하기 위한 변수&lt;/li&gt;
      &lt;li&gt;nrempty : Producer입장에서 buffer에 자리가 얼마만큼 있는지 확인하기 위한 변수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;reader-writer-problem-with-semaphore&quot;&gt;Reader-Writer Problem with Semaphore&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Reader는 데이터에 대해 읽기 연산만 수행&lt;/li&gt;
  &lt;li&gt;Writer는 데이터에 대해 갱신 연산을 수행&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Read같은 경우 동시에 같은 데이터에 접근해도 문제가 없다. 하지만 Write는 별다른 Synchronization없이 여러명이서 쓰면 난리가 난다. 그러므로 Data의 Consistency 보장이 필요하다.&lt;/p&gt;

&lt;dl&gt;
  &lt;dt&gt;&lt;strong&gt;해결법&lt;/strong&gt;&lt;/dt&gt;
  &lt;dd&gt;
    &lt;p&gt;Reader/Writer에 대한 우선권을 부여한다.&lt;/p&gt;
  &lt;/dd&gt;
&lt;/dl&gt;

&lt;ul&gt;
  &lt;li&gt;Reader가 우선권을 가지는 경우
    &lt;ul&gt;
      &lt;li&gt;3가지 변수를 사용
        &lt;ul&gt;
          &lt;li&gt;wmutex : 다른 Writer가 있는지 확인하기 위한 변수&lt;/li&gt;
          &lt;li&gt;rmutex : 다른 Reader가 있는지 확인하기 위한 변수&lt;/li&gt;
          &lt;li&gt;nreaders : Reader의 수를 표현하기 위한 변수&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Reader가 없을때 Read하기 위해 들어갈때는 Writer가 못들어오도록 막고 시작한다.&lt;/li&gt;
      &lt;li&gt;Read를 마치고 나가려고할때, 마지막 Reader라면 Wrtier가 들어올 수 있도록 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Writer가 우선권을 가지는 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Semaphore의 효과&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;No busy waiting
    &lt;ul&gt;
      &lt;li&gt;대기실을 만들어서 해결했다. (각 S변수 하나마다 Ready queue가 할당되었었다.)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Semaphore queue에 대한 wake-up순서는 비결정적이다.
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Starvation problem이 있다.&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;eventcount--sequencer&quot;&gt;Eventcount / Sequencer&lt;/h3&gt;

&lt;p&gt;은행업무와 비교해서 생각하면 쉬운 개념!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Sequencer&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;정수형 변수&lt;/li&gt;
      &lt;li&gt;생성시 0으로 초기화하고 감소하지 않는다.&lt;/li&gt;
      &lt;li&gt;순서를 유지하고 ticket() operation으로만 접근 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ticket(S)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;현재까지 ticket() Operation이 호출 된 횟수 반환 (번호표)&lt;/li&gt;
      &lt;li&gt;Indivisible Operation&lt;/li&gt;
      &lt;li&gt;0에서 시작해서 번호표를 뽑을 때마다 번호가 계속 +1씩 증가한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Eventcount&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;정수형 변수&lt;/li&gt;
      &lt;li&gt;생성시 0으로 초기화하고 감소하지 않는다.&lt;/li&gt;
      &lt;li&gt;특정사건의 발생 횟수를 기록 (은행으로 치면 지금까지 업무처리가 끝난 번호까지)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;read(E), advance(E), await(E,v) operation&lt;/strong&gt;으로만 접근 가능
        &lt;ul&gt;
          &lt;li&gt;read는 현재 번호가 몇번인지 보고있는 것&lt;/li&gt;
          &lt;li&gt;advance는 은행원이 다음번호로 넘기는 행위 (기다리고있는 프로세스를 깨운다.)&lt;/li&gt;
          &lt;li&gt;await(E,v)에서 v는 번호표, E는 현재 번호 -&amp;gt; 내 번호가 더 크면 대기실에서 기다린다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;순서&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Process가 와서 번호표를 뽑는다. (ticket(S))&lt;/li&gt;
  &lt;li&gt;내 차례가 올때까지 대기실에서 기다린다 (await(E,v))&lt;/li&gt;
  &lt;li&gt;일을 끝내고 기다리고 있는 다른 Process를 깨운다 (advance(E))&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위와같은 순서로 진행된다.&lt;/p&gt;

&lt;p&gt;이 방법으로 Producer-Consumer Problem을 풀어보자. (강의에서 확인하자)&lt;/p&gt;

&lt;h2 id=&quot;language-level-solution&quot;&gt;Language-Level Solution&lt;/h2&gt;

&lt;p&gt;여전히 구현이 어렵고, 에러가 생길 가능성이 높다. 그래서 이번에는 Programming language수준에서 Mutual exclusion 문제를 해결해보자!&lt;/p&gt;

&lt;h3 id=&quot;high-level-mechanism&quot;&gt;High-Level Mechanism&lt;/h3&gt;

&lt;p&gt;프로그래밍언어가 Mutual exclusion을 Support하자!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용이 쉽다.&lt;/li&gt;
  &lt;li&gt;Object-Oriented concept과 유사하다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;앞에서 했던 방법들(Low-level mechanisms)은 Flexible했지만, 많이 복잡했고, 쓰기도 힘들었다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Error 발생 확률이 높았다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그러니까 우리가 쓰는 High level의 Program language로 쉽게 Solution을 만들보자! Monitor, Path expression, Serializers등등 여러가지가 있지만 Monitor만 살펴보도록 하자.&lt;/p&gt;

&lt;h3 id=&quot;monitor&quot;&gt;Monitor&lt;/h3&gt;

&lt;p&gt;책방에 대입해서 생각해보자.&lt;/p&gt;

&lt;p&gt;Critical Data와 Critical Section을 모아논 하나의 방이라고 생각하면된다. (한번에 한명만 들어올 수 있는 책방)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Critical data: 내가 빌리고싶은 책&lt;/li&gt;
  &lt;li&gt;Critical section: 내가 대출하거나 반납하기위해서 들리는 카운터&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 외에도 Conditional variable과 wait(), signal() operation들이 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Monitor의 구조&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Entry queue (진입큐)
    &lt;ul&gt;
      &lt;li&gt;한번에 하나만 들어가도록하는 queue&lt;/li&gt;
      &lt;li&gt;Function마다 하나씩 존재&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Mutual exclusion
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Monitor내에는 항상 하나의 Process만 진입가능&lt;/strong&gt; (Programming language로 보장)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Information hiding (정보 은폐)
    &lt;ul&gt;
      &lt;li&gt;Ciritical data에는 모니터 내의 프로세스만 접근가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Condition queue (조건 큐)
    &lt;ul&gt;
      &lt;li&gt;모니터 내의 특정 이벤트를 기다리는 프로세스들의 대기실&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Signaler queue (신호제공자 큐)
    &lt;ul&gt;
      &lt;li&gt;모니터에는 항상 하나의 신호제공자 큐가 존재&lt;/li&gt;
      &lt;li&gt;전화부스라고 생각하면 된다.&lt;/li&gt;
      &lt;li&gt;signal을 보내기위해 잠깐 들어가는 공간&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;자원할당이라는 문제로 동작을 살펴보자. (자원을 책이라고 가정한다.)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;책을 요청하는 function과, 책을 반납하는 function이 존재한다.
    &lt;ul&gt;
      &lt;li&gt;release and request&lt;/li&gt;
      &lt;li&gt;각각의 Function은 Entry queue를 가지게 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Conditon queue이라는 대기실이 존재한다.&lt;/li&gt;
  &lt;li&gt;대기실의 Process를 깨우는 공간인 Signaler queue가 존재한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//기존의 방식과는 다르게 생각한대로 짜면됨&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;requestR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_Available&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;R_Free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//책이 없으면 기다려라&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;R_Available&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;releaseR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;R_Available&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//반납했으니까 true로 바꾼다.&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;R_Free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Condition queue에 기다렸던놈 나와라.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런식으로 그냥 생각하는대로 쉽게 짤 수가 있다. 여기서 주의해서 생각해야할 것은&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Monitor에는 한번에 한명만 들어갈 수 있다.&lt;/li&gt;
  &lt;li&gt;Release와 Request가 각각 나뉘어져있어서 Release를 마치고 signaler queue에서 Condition queue에서 기다리고있는 사람을 불렀을 때, Monitor에는 한명만 들어갈 수있기 때문에, Monitor에서 나와야한다.&lt;/li&gt;
  &lt;li&gt;위의 코드는 간단하게 짠거라서 없지만, release의 경우 자원을 반납하고나서, 마무리 작업이 남아있기 때문에 Condition queue안의 대기하고 있는 사람을 부르고나서 signaler queue에 들어가있다가 다시 Monitor로 들어가서 남은일을 하고 나온다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;procuder-consumer-problem-with-monitor&quot;&gt;Procuder-Consumer Problem with Monitor&lt;/h4&gt;

&lt;p&gt;이번에는 Producer-Consumer Problem을 Monitor로 해결해보자.&lt;/p&gt;

&lt;p&gt;Variables&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ValidBufs: 물건의 개수&lt;/li&gt;
  &lt;li&gt;in, out: Data가 들어갈 공간&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Procedure&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;fillBuf(): Producer가 사용할 Procedure&lt;/li&gt;
  &lt;li&gt;emptyBuf(): Consumer가 사용할 Procedure&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Condition queue&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;bufHasData: Buffer에 ‘데이터’가 있는지 (Consumer가 기다리는 공간)&lt;/li&gt;
  &lt;li&gt;bufHasSpace: Buffer에 ‘공간’이 있는지 (Producer가 기다리는 공간)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위와 같은 구성으로, 코드를 작성해보면&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//Producer&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fillBuff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//물건의 수가 N이다? -&amp;gt; 꽉찼다. 그러니까 기다려라&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;validBufs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bufHasSpace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;validBufs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;validBufs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;bufHasData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//물건을 기다리는 Consumer가 있으면 깨운다.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//Consumer&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;emptyBuf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//물건의 수가 0이다? -&amp;gt; 데이터가 없다. 그러니까 기다려라&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;validBufs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bufHasData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;validBuf&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;validBuf&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;bufHasSpace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//공간을 기다리는 Producer가 있으면 깨운다.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;reader-writer-problem-with-monitor&quot;&gt;&lt;strong&gt;Reader-Writer Problem with Monitor&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;read같은 경우는 한번에 여러명이 할 수 있었지만, write같은 경우는 한번에 여러명이 할 경우 큰일난다고 위에서 말했었다. 위에서만 Semaphore를 이용해서 했었지만, 이번에는 Monitor를 이용해서 좀더 간단하게 만들어보자.&lt;/p&gt;

&lt;p&gt;Variables&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;nReader: Reader의 수&lt;/li&gt;
  &lt;li&gt;writing: writer의 존재유무&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Procedure&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;beginRead: Reader가 사용할 Procedure&lt;/li&gt;
  &lt;li&gt;finishRead: Reader가 사용할 Procedure2&lt;/li&gt;
  &lt;li&gt;beginWrite: Writer가 사용할 Procedure&lt;/li&gt;
  &lt;li&gt;finishWrite: Writer가 사용할 Procedure2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Condition queue&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;waitWrite: Writer가 기다리는 공간&lt;/li&gt;
  &lt;li&gt;waitRead: Writer가 이미 Monitor내에 있을 경우 Reader가 기다리는 공간&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;beginReading&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writing&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;waitWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;waitRead&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;nReader&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nReader&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;waitRead&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;waitRead&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;finishReading&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;nReader&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nReader&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;waitWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;beginWriting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writing&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nReader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;waitWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;writing&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;finishWriting&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;writing&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;waitRead&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;waitRead&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;waitWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런식으로 짜면 된다. (솔직히 procedure 4개 나올줄은 몰랐습니다.)&lt;/p&gt;

&lt;h4 id=&quot;dining-philosopher-problem-with-monitor&quot;&gt;Dining Philosopher Problem with Monitor&lt;/h4&gt;

&lt;p&gt;이번에는 Dining philosopher problem&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;5명의 철학자&lt;/li&gt;
  &lt;li&gt;하는일은 생각하는일, 스파게티 먹는일을 반복함&lt;/li&gt;
  &lt;li&gt;공유자원: 스파게티 포크&lt;/li&gt;
  &lt;li&gt;스파게티를 먹기위해서는 좌우 포크2개를 모두 들어야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Variables&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;numForks[0~4]: 철학자들이 쓸 수 있는 포크의 개수&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Procedure&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;pickUp: 스파게티를 먹을 사람이 포크를 드는 것&lt;/li&gt;
  &lt;li&gt;putDown: 생각하는 사람이 포크를 내려놓는 것&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Condition queue&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;room[0~4]: 철학자들의 방 5개&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pickUp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;me&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numForks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;room&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;me&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//내 양쪽사람이 쓸수 있는 포크는 1개씩 줄어든다.&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;numForks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;me&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numForks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;me&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;numForks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;me&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numForks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;me&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;procedure&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;putDown&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;me&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;numForks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;me&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numForks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;me&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;numForks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;me&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numForks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;me&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numForks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;me&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;room&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;me&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numForks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;me&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]=&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;room&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;me&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Reader-Writer Problem이랑 비슷하게 풀릴 줄 알고 Procedure를 처음에 4개를 준비했었었는데, 필요 없었습니다ㅠ&lt;/p&gt;

&lt;p&gt;이렇게 여러가지 문제를 Monitor를 이용해서 쉽게 해결할 수 있었다.&lt;/p&gt;

&lt;p&gt;장점과 단점을 살펴보면,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;사용이 쉽다.&lt;/li&gt;
      &lt;li&gt;Deadlock과 Error의 발생 가능성이 낮다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;Monitor를 지원하는 언어에서만 사용 가능&lt;/li&gt;
      &lt;li&gt;Compiler가 OS를 이해하고 있어야한다.
        &lt;ul&gt;
          &lt;li&gt;Critical section 접근을 위한 코드 생성&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>고중범</name></author><category term="OS" /><summary type="html">김덕수 교수님의 OS강의 Lecture 6</summary></entry><entry><title type="html">Covariance (공분산)</title><link href="http://localhost:4000/information/2020/04/23/Covariance-post/" rel="alternate" type="text/html" title="Covariance (공분산)" /><published>2020-04-23T21:00:00+09:00</published><updated>2020-04-23T21:00:00+09:00</updated><id>http://localhost:4000/information/2020/04/23/Covariance-post</id><content type="html" xml:base="http://localhost:4000/information/2020/04/23/Covariance-post/">&lt;h1 id=&quot;covariance-공분산&quot;&gt;Covariance (공분산)&lt;/h1&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Cov(x,y) = E\{(X-m_x)(Y-m_y)\} = E(XY) -m_xm_y&lt;/script&gt;

&lt;p&gt;The &lt;em&gt;Covariance&lt;/em&gt; is a measure of how much the values of each of two &lt;strong&gt;correlated&lt;/strong&gt; random variables determines the other.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Covariance는 두 확률변수의 관계를 나타내는것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;독립적인 관계&lt;/li&gt;
  &lt;li&gt;양의 선형관계&lt;/li&gt;
  &lt;li&gt;음의 선형관계&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;먼저 $ E(X-m_x) $에 대해 생각해보자. (X에 대해서만 1차원적으로 생각해보자.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/About Covariance/1.png&quot; width=&quot;800px&quot; height=&quot;200px&quot; align=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 X축 위에 3개의 숫자가 있다. 각각 A=1, B=2, C=3이다.&lt;/p&gt;

&lt;p&gt;이때 X = [A,B,C]라고 했을때 X의 Expected Value, 즉 기대값은 E(X) = 2이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/About Covariance/2.png&quot; width=&quot;800px&quot; height=&quot;200px&quot; align=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 $ X - m_x = [A-2, B-2, C-2]$가 된다.&lt;/p&gt;

&lt;p&gt;X라는 확률변수의 축이 2만큼 이동한 형태로 바뀐다.&lt;/p&gt;

&lt;p&gt;Covariance라는건 위에서 말했던 것 처럼 두 확률변수의 관계를 나타내는 것이다.&lt;/p&gt;

&lt;p&gt;2개의 확률변수 X, Y는 다음과 같다.&lt;/p&gt;

&lt;p&gt;X = [0, 0.5, 1, 1.5, 2]&lt;/p&gt;

&lt;p&gt;Y = [0, 0.5, 1, 1.5, 2]&lt;/p&gt;

&lt;p&gt;두가지 확률변수 값들을 2차원 좌표평면에 나타내보면&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/About Covariance/3-4.png&quot; width=&quot;800px&quot; height=&quot;400px&quot; align=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 왼쪽 그래프와 같은 산점도가 그려진다.&lt;/p&gt;

&lt;p&gt;여기서 X와 Y의 평균(기대값)을 축으로 표현하면 오른쪽 그래프와 같다.&lt;/p&gt;

&lt;p&gt;Covariance 수식으로 돌아와서 살펴보면&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;$ Cov(x,y) = E\{(X-m_x)(Y-m_y)\} $&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$X-m_x = [-1,\ -0.5,\ 0,\ 0.5,\ 1]$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$Y-m_y = [-1,\ -0.5,\ 0,\ 0.5,\ 1]$&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 값을 이용해서 $(X-m_x) * (Y-m_y)$를 구하면,&lt;/p&gt;

&lt;p&gt;$(X-m_x) * (Y-m_y) = [1,\ 0.25,\ 0,\ 2.5,\ 1]$가 된다.&lt;/p&gt;

&lt;p&gt;결국 $X-m_x, \ Y-m_y$의 &lt;strong&gt;평균은 0이지만,&lt;/strong&gt; $ E{(X-m_x)(Y-m_y)} $는 &lt;strong&gt;양의 값을 가지게 된다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이때&lt;strong&gt;, 양의 값을 가지는 Covariance&lt;/strong&gt;를 근거로 두 확률변수가&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;양의 선형관계를 가지고있다&lt;/strong&gt;고 말할 수 있는 것이다. (점들이 주로 제 1,3사분면에 분포)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;반대로&lt;/strong&gt; X와 Y의 산점도가 위와 다르게 점들이 제 2,4사분면에 주로 분포를 한다면,&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;두 확률변수가 음의 선형관계를 가지고있는 것이고 Covariance는 음의 값을 가진다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Covariance의 값이 0일 경우 두 확률변수는 독립적인 관계에 있는 것이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;(선형관계일때만 해당한다. &lt;a href=&quot;#covariance의-약점&quot;&gt;Covariance의 약점&lt;/a&gt;에서 다룬다.)&lt;/p&gt;

&lt;p&gt;위의 내용을 정리하면,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Covariance &amp;gt; 0&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;두 확률변수는 양의 선형관계&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Covariance &amp;lt; 0&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;두 확률변수는 음의 선형관계&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Covariance = 0&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;두 확률변수는 독립적인 관계&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;covariance의-약점&quot;&gt;Covariance의 약점&lt;/h2&gt;

&lt;p&gt;하지만 Covariance에는 약점이 있다!&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Covariance는 선형적인 관계만 파악할 수 있다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;확률변수들의 단위의 크기에 영향을 받는다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;첫번째-약점&quot;&gt;첫번째 약점&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/About Covariance/5-6.png&quot; width=&quot;800px&quot; height=&quot;400px&quot; align=&quot;center&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예를들어, 위 그래프와 같이 2차함수의 모양으로 분포되어 있다고 할 때,&lt;/p&gt;

&lt;p&gt;이런식으로 표현이 되는데, X와 Y는 2차함수의 관계를 가지지만,&lt;/p&gt;

&lt;p&gt;Covariance를 계산하면 0에 가깝게 나오기 때문에&lt;/p&gt;

&lt;p&gt;실제로 그렇진 않지만 해석상으로 두 변수는 독립적인 관계를 가진것이 된다.&lt;/p&gt;

&lt;p&gt;이처럼 선형관계 말고는 파악할 수 없다는 약점이 있다.&lt;/p&gt;

&lt;h3 id=&quot;두번째-약점&quot;&gt;두번째 약점&lt;/h3&gt;

&lt;p&gt;Covariance는 단위의 크기에 영향을 받는다.&lt;/p&gt;

&lt;p&gt;예를들어 시험점수와 공부시간의 관계를 Covariance로 나타낸다고 할때,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;10점이 만점인 국어시험&lt;/li&gt;
  &lt;li&gt;100점이 만점인 영어시험&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;각각의 시험과 공부시간의 관계는 실질적으로 비슷하다고 하더라도&lt;/p&gt;

&lt;p&gt;영어시험과 공부시간의 관계를 나타내는 Covariance가 더 큰 값을 가지게 된다.&lt;/p&gt;

&lt;p&gt;이러한 결과를 방지하기 위해 Correlation(상관계수)를 사용한다.&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\rho = {Cov(X,Y)\over \sqrt{Var(X)Var(Y)}}&lt;/script&gt;
​&lt;/p&gt;

&lt;p&gt;Correlation은 $\rho$라는 기호를 사용해서 표현한다.&lt;/p&gt;

&lt;p&gt;이렇게 Covariance에 두 변수의 표준편차를 나눠줌으로써&lt;/p&gt;

&lt;p&gt;Correlation는 $-1\le \rho \le 1 $의 범위를 가진다.&lt;/p&gt;

&lt;p&gt;이렇게 함으로써 단위의 크기에 의한 오류을 없앨 수 있다.&lt;/p&gt;</content><author><name>고중범</name></author><category term="Information" /><summary type="html">공분산이란?</summary></entry><entry><title type="html">Data Structure week6</title><link href="http://localhost:4000/data%20structure/2020/04/12/Data_structure_week6-post/" rel="alternate" type="text/html" title="Data Structure week6" /><published>2020-04-12T21:00:00+09:00</published><updated>2020-04-12T21:00:00+09:00</updated><id>http://localhost:4000/data%20structure/2020/04/12/Data_structure_week6-post</id><content type="html" xml:base="http://localhost:4000/data%20structure/2020/04/12/Data_structure_week6-post/">&lt;hr /&gt;

&lt;h1 id=&quot;data-structure-week-6&quot;&gt;Data Structure Week 6&lt;/h1&gt;

&lt;p&gt;KAIST 산업및시스템공학과 문일철 교수님의&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.edwith.org/datastructure-2019s/joinLectures/21992&quot;&gt;데이터 구조 및 분석: Linear Structure and Dynamic Programming&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.edwith.org/&quot;&gt;edwith&lt;/a&gt; 강의를 보고 정리한 내용입니다.&lt;/p&gt;

&lt;h2 id=&quot;weekly-objectives&quot;&gt;Weekly Objectives&lt;/h2&gt;

&lt;p&gt;This week, we study the tree data structure. Particularly, we will focus on the structure and the operation of the binary search tree.&lt;/p&gt;

&lt;p&gt;Objectives are&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Memorizing the definitions, the terminologies and the characteristics of trees&lt;/li&gt;
  &lt;li&gt;Understanding the structures of trees&lt;/li&gt;
  &lt;li&gt;Understanding the structure and the operations of a binary search tree
    &lt;ul&gt;
      &lt;li&gt;Insert, search, delete operations&lt;/li&gt;
      &lt;li&gt;Tree traversing operations
        &lt;ul&gt;
          &lt;li&gt;Depth first search
            &lt;ul&gt;
              &lt;li&gt;In-order, post-order, pre-order sequences&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Breadth first search&lt;/li&gt;
          &lt;li&gt;Level order search&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Understanding the performance of binary search tree&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tree Structure 중에서 BST (Binary Search Tree)에 대해 배웁니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;detour-abstract-data-types&quot;&gt;Detour: Abstract Data Types&lt;/h2&gt;

&lt;p&gt;An ADT specifies:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Data stored&lt;/li&gt;
  &lt;li&gt;Operation&lt;/li&gt;
  &lt;li&gt;Error response&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;(3주차에서 다뤘었습니다.)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;사실 Tree도 일종의 ADT이다.&lt;/p&gt;

&lt;p&gt;upside down 형태의 ADT (마치 나무가 거꾸로 된 형태)&lt;/p&gt;

&lt;p&gt;Tree&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;일종의 ADT다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Data가 tree structure로 저장되어 있다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;operations&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;기본적인 Data structure라면 지원하는 OP들은 다 지원한다. (ex) LinkedList의 insert, delete, search&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Special searching approaches for trees and networks&lt;/p&gt;

        &lt;p&gt;-&amp;gt; 일직선의 구조가 아니기때문에 다양한 traverse가 정의된다.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;why-do-we-use-trees&quot;&gt;Why do we use trees&lt;/h2&gt;

&lt;p&gt;현실의 Tree Structure Example&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;조직도&lt;/li&gt;
  &lt;li&gt;Group bank accounts&lt;/li&gt;
  &lt;li&gt;Command&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Tree structure는 왜 쓰는가?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;A clear approach of Divide and Conquer&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Data의 특성을 반영하여 Divide하고, 저장하는 문제를 풀어나가는 방식이 쓰여진 Structure&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;LinkedList같은 Data structure보다 더 적은 retrieval 만으로도 필요한 data를 search할 수 있다.&lt;/p&gt;

    &lt;p&gt;(뒤에서 자세히 이야기 합니다.)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Recursion도 마찬가지로 Divide and Conquer방식으로 Top-down으로 문제를 줄여나갔었다.&lt;/p&gt;

&lt;p&gt;Tree structure를 다룰때도 Recursion를 많이 활용하게 될 것이다.&lt;/p&gt;

&lt;h2 id=&quot;structure-of-stored-data&quot;&gt;Structure of stored data&lt;/h2&gt;

&lt;p&gt;Linked List같은 경우는 object + Next를 가진 하나의 Node로 표현해서 사용했었다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;object가 가진 value에 대한 reference&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다음 노드를 가리키는 reference&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이런 LinkedList를 세로로 세웠다고 생각해보자.&lt;/p&gt;

&lt;p&gt;Tree구조와 유사하지만 다른점이 있다.&lt;/p&gt;

&lt;p&gt;Tree구조에서 네모하나를 Node(tree node)라고 할 때,&lt;/p&gt;

&lt;p&gt;LinkedList같은 경우, Next는 하나밖에 없었는데, &lt;strong&gt;Tree structure의 경우 Next가 여러개이다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Each node has multiple next nodes&lt;/li&gt;
  &lt;li&gt;Particularly, this structure maintains the next “nodes” as an array or variables&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tree Structure는 점점 커지게 되고, 그에 따라서 데이터를 저장할 공간이 점점 커지게 되는 것&lt;/p&gt;

&lt;p&gt;문제는 Next가 여러개이기 때문에, 여러 Next중에 어떤 Next를 선택해야할지가 햇갈릴 수 있는데,&lt;/p&gt;

&lt;p&gt;그런것에 대한 룰을 잘 세우는것이 Tree를 관리하는 기법이 됨&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;terminologies-of-tress-structure&quot;&gt;Terminologies of tress structure&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Edge&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;하나의 Next reference를 Edge (화살표)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Node&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;하나의 Next reference가 가리키는 것, object하나와 4개의 reference를 가지고 있는 Instance&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Root&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;맨 위에 있는 Node (마치 LinkedList의 head)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Parent and Child&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;두개의 Node가 edge로 연결되어 있을 때, 상위 Level의 Node가 Parent&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;하위 Level의 Node가 Child&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Siblings&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;같은 Level에 있는 (동일한 parent를 가진) Node&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Terminal Node and Internal Node&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Terminal Node는 Child가 없는 노드&lt;/li&gt;
      &lt;li&gt;Internal Node는 Terminal Node의 반대&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Descendants and Ancestors&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Node A의 Child, Child의 Child같이 Node A와 연결된 모든 하위 Level의 Node를 지칭한다.&lt;/li&gt;
      &lt;li&gt;parent를 따라가다보면 A를 만나게 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Ancestors는 Descendant의 반대, 조상님을 의미&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Path to E&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;매우 중요한 path개념&lt;/li&gt;
      &lt;li&gt;Root위치에서 특정 Node까지 edge를 통해 갈 수 있는 최단거리의 길을 path라고 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Depth and Level of B&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;B라는 노드에 대한 path는 1이 된다. -&amp;gt; B의 Depth는 1이다.&lt;/li&gt;
      &lt;li&gt;Depth = Path length&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Height of tree&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Maximum path length = Height of tree&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Degree of B Node&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;특정노드의 Degree는 B가 가질 수 있는 Child의 수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Size of tree&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Tree에 있는 Node의 개수 (저장되어있는 데이터의 개수)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Full Tree&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Leaf가 모두 동일레벨&lt;/li&gt;
      &lt;li&gt;Internal Node에는 모든 Next들이 fully하게 다음 Node를 가리키고 있음&lt;/li&gt;
      &lt;li&gt;삼각형 모양&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Complete Tree&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;바로 직전 Depth까지는 full tree structure인데, 맨 왼쪽부터 하나하나 채워나가는 과정 (순서대로)중이면 Complete tree (Filled from left)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;characteristics-of-trees&quot;&gt;Characteristics of trees&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Num of edges =  (Num of nodes) - 1&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Depth of root = 0&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Height of root = height of tree = Maximum path length&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Maximum num of nodes at level i with degree d&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;$d^i$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Maximum num of leaves with height h and degree d&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;$d^h$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Maximum size of a tree with height h and degree d&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;$= d^0 + d^1 + d^2 + .. + d^h = d^(h+1) -1 / (d-1)$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Height of a complete tree with size s and degree d&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;위의 식을 LOG로 바꿔서 전개&lt;/li&gt;
      &lt;li&gt;log는 실수형, Height는 정수형이라서 올림을 해줌&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;binary-search-tree-bst&quot;&gt;Binary Search Tree (BST)&lt;/h2&gt;

&lt;p&gt;Binary tree = Degree가 2인 Tree&lt;/p&gt;

&lt;p&gt;Binary “search” tree&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Degree가 2인 tree&lt;/li&gt;
  &lt;li&gt;저장된 데이터에 대해서 빠르게 search가 가능하게 디자인되었다.&lt;/li&gt;
  &lt;li&gt;빠르게 search가 가능하도 데이터의 특성을 활용해서 구조를 만들어야한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ex) 건물에서 화장실을 찾으려고 함&lt;/p&gt;

&lt;p&gt;화장실을 찾아가려면 어떻게해야할까?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;직원에게 물어보기&lt;/li&gt;
  &lt;li&gt;무작정 걷기&lt;/li&gt;
  &lt;li&gt;Sign을 찾기&lt;/li&gt;
  &lt;li&gt;짐작해서 찾아보기 (Guess)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;보통 4번째으로도 화장실을 찾을 수 있는 이유는?&lt;/p&gt;

&lt;p&gt;-&amp;gt; 건물의 설계에는 일정한 패턴을 가지고 있기 때문 (귀퉁이에 있다던지, 엘리베이터 옆에 있다던지)&lt;/p&gt;

&lt;p&gt;-그래서 1,2,3을 하지 않아도 짐작으로 화장실을 찾아갈 수 있는데&lt;/p&gt;

&lt;p&gt;이런식으로 데이터도 &lt;strong&gt;일정한 패턴을 가지도록 만든다면, 빠른 search가 가능하다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;a-scenario-of-using-binary-search-tree&quot;&gt;A scenario of using binary search tree&lt;/h3&gt;

&lt;p&gt;1001부터 시작되는 Account ID에서 1004를 찾는다고 할때&lt;/p&gt;

&lt;p&gt;LinkedList라면 1001부터 4번의 retrieval을 해서 1004를 찾아가야함&lt;/p&gt;

&lt;p&gt;binary search tree는 2개의 Next가 있는데&lt;/p&gt;

&lt;p&gt;왼쪽에는 더 작은값을 저장하고, 오른쪽에는 더 큰 값을 저장한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이런 방식으로 했을 때에 규칙이 있기때문에 더 적은 retrieval만으로도 원하는 데이터를 찾을 수가 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;implementation-of-tree-node&quot;&gt;Implementation of Tree Node&lt;/h3&gt;

&lt;p&gt;먼저 Tree의 Node를 만들어야 함&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Member Variable&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Left hand side node
    &lt;ul&gt;
      &lt;li&gt;Lower than its own value&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Right hand side node
    &lt;ul&gt;
      &lt;li&gt;higher than its own value&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;parent node&lt;/li&gt;
  &lt;li&gt;value&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;-&amp;gt; 4개의 reference를 가진다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Member function&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;simple get/set methods (encapsulation)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# Member variable&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;nodeLHS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;nodeRHS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;nodeParent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodeParent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    	&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;
    	&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodeParent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodePraent&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# Simple get methods&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getParent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodeParent&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodeLHS&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getRHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodeRHS&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# Simple set methods&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    	&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setParent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodeParent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodeParent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodeParent&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodeLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodeLHS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodeLHS&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setRHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodeRHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodeRHS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodeRHS&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;implementation-of-bst&quot;&gt;Implementation of BST&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Member Variable&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;root에 대한 reference만 가지고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Member function&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;insert&lt;/li&gt;
  &lt;li&gt;search&lt;/li&gt;
  &lt;li&gt;delete&lt;/li&gt;
  &lt;li&gt;findmax&lt;/li&gt;
  &lt;li&gt;findmin&lt;/li&gt;
  &lt;li&gt;traverselevelnorder&lt;/li&gt;
  &lt;li&gt;traverseInorder&lt;/li&gt;
  &lt;li&gt;traversepreOrder&lt;/li&gt;
  &lt;li&gt;traversePostOrder&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;insert-operation-of-binary-search-tree&quot;&gt;Insert operation of binary search tree&lt;/h4&gt;

&lt;p&gt;어떻게 규칙을 지켜가며 LHS, RHS에 정확하게 data를 저장할 수 있을까?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;기본적으로 Recursion을 사용한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;insert할 떄 특정한 Node or Root를 받아오게 됨&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Case 1. root가 비어있다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;root에 그 데이터를 저장한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Case 2. 이미 insert하려고하는값이 저장되있다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;중복된 insert는 안하고 return&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Case 3. 현재 Node의 value가 저장하려고하는 value보다 작을 경우&lt;/strong&gt; (My value &amp;lt; Node’s value)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;현재 Node의 RHS에 저장
    &lt;ul&gt;
      &lt;li&gt;RHS에 이미 value가 있다면?
        &lt;ul&gt;
          &lt;li&gt;RHS와 또다시 비교 (반복)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;현재 Node의 value가 더 크다면?
    &lt;ul&gt;
      &lt;li&gt;LHS에 저장&lt;/li&gt;
      &lt;li&gt;LHS에 이미 value가 있다면?
        &lt;ul&gt;
          &lt;li&gt;LHS와 또다시 비교 (반복)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BinarySearchTree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;
        
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# 초기화 구문&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# root가 비어있다면, root에 저장한다.    &lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;# TreeNode(value, nodeParent)&lt;/span&gt;
            &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# 같은 value가 있다면 insert하지 않고 return한다.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# Value가 현 Node의 value보다 작을 경우&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getvalue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;c&quot;&gt;# Recursion&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getvalue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setRHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;c&quot;&gt;# Recursion&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;search-operation-off-binary-search-tree&quot;&gt;Search operation off binary search tree&lt;/h4&gt;

&lt;p&gt;Search하려는 value가 있으면 True를 return한다.&lt;/p&gt;

&lt;p&gt;찾으려는 value가 그 Node의 Value보다 작다면 (My value &amp;lt; Node’s value)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;if there is a node in the right hand side, then move to the RHS node (recursion)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;더이상 RHS가 없다면 False를 Return&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;다음번에는 LHS로 찾아가야함 (RHS쪽은 생각도 안해도 됨)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;value가 Node보다 크다면 (My value &amp;gt; Node’s value)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;if there is a node in the left hand-side, then move to the LHS node (recursion)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;RHS로 찾아가야함 (LHS쪽은 생각도 안해도 됨)&lt;/li&gt;
  &lt;li&gt;더이상 LHS가 없다면 False를 Return&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;찾을 영역이 계속해서 줄어든다.&lt;/p&gt;

&lt;p&gt;-&amp;gt; Recursion을 이용해서 서서히 찾아간다.&lt;/p&gt;

&lt;p&gt;LinkedList같은 경우는 Chain을 계속 따라가서 찾아야함 (n개가 있다면 n개를 다 봐야함)&lt;/p&gt;

&lt;p&gt;Tree구조는 그럴 필요없이 Height만큼 or Depth만큼만 찾아보면 된다.&lt;/p&gt;

&lt;p&gt;-&amp;gt; LinkedList에 비해 상대적으로 Search 성능이 더 좋다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BinarySearchTree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# 초기화 구문&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# Value와 같다면 True를 return, escape routine&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# Value가 현 Node의 value보다 작다면 LHS에서 search, LHS가 없다면 False를 return&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# Recursion&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# Value가 현 Node의 value보다 크다면 RHS에서 search, RHS가 없다면 False를 return&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# Recursion&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;delete-operation-of-binary-search-tree&quot;&gt;Delete operation of binary search tree&lt;/h4&gt;

&lt;p&gt;Tree structure에서 Delete는 매우 복잡하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;값을 삭제한 후에 트리에 생기는 여파가 크기 때문이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Node를 하나 없애는 것인데,&lt;/p&gt;

&lt;p&gt;Node가 Child가 없는 Node라면 딱히 복잡하지 않다.&lt;/p&gt;

&lt;p&gt;그러나 Child가 하나라도 있다면 복잡해진다. (child는 그대로두고, parent node만 없애야하기 때문)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Three Deletion Case&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Deleting a node with no children&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;그다지 어렵지 않음. parent node로 가서 reference만 끊어주면 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Deleting a node with one child&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Replace the node with the child. Child가 parent node의 자리를 대체하면 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Deleting a node with two children&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;해법들의 concept은 어떤 node를 그 자리에 올리는 것이다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;child Node를 올리면 규칙을 위반할 수도 있기 때문에,&lt;/p&gt;

        &lt;p&gt;지우려는 value에 가장 가까운 Node를 찾아야 한다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Find either&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;A maximum in the LHS or A minimum in the RHS (중간에 가까운걸 찾는 두가지 방식)&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;substitute the node to delete with the found value&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Delete the found node in the LHS or the RHS&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tree structure는 그대로 둔 상태에서 &lt;strong&gt;가장 가까운 Node&lt;/strong&gt;를 그 자리에 copy한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이때 이 노드는 반복적으로 RHS면 RHS, LHS면 LHS을 지속적으로 추적하다가,&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;더이상 LHS나 RHS가 없을 때의 Node를 가져온 것이기 때문에 Child가 많아봤자 1개이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;앞에서 다룬 2가지의 케이스를 적용해서 그 값을 삭제&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BinarySearchTree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;
    
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;c&quot;&gt;# findMin method는 뒤에서 findMax method와 함께 정의합니다.&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;nodeMin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;findMin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
                &lt;span class=&quot;c&quot;&gt;# 그 자리에 가장 가까운 node를 copy&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodeMin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
                &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nodeMin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
            	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;# 지금 이 Node가 Parent의 LHS인지 RHS인지 확인하기 위한 Instance&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getParent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;# 현 node가 RHS는 없고, LHS만 있을 때 &lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                &lt;span class=&quot;c&quot;&gt;# 현 node가 parent의 LHS에 있을 때&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setParent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;c&quot;&gt;# 현 node가 parent의 RHS에 있을 때&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setParent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;# 현 node가 LHS는 없고, RHS만 있을 때 &lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                &lt;span class=&quot;c&quot;&gt;# 현 node가 parent의 LHS에 있을 때&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setParent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;c&quot;&gt;# 현 node가 parent의 RHS에 있을 때&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setParent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;# 현 node가 LHS도 없고, RHS도 없는 경우&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;minimum-and-maximum-in-binary-search-tree&quot;&gt;Minimum and maximum in Binary search tree&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Find Minimum
    &lt;ul&gt;
      &lt;li&gt;계속 LHS로만 찾아가면 Minimum을 찾을 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Find Maximum
    &lt;ul&gt;
      &lt;li&gt;계속 RHS로만 찾아가면 Maximum을 찾을 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;언제까지?&lt;/p&gt;

&lt;p&gt;Recursion을 이용해서 더이상 LHS 또는 RHS가 없을 때까지 찾는다.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BinarySearchTree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# RHS로만 keep moving하면 최대값을 찾을 수 있다.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findMax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;findMax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# LHS로만 keep moving하면 최소값을 찾을 수 있다.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;findMin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;findMin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# 언제까지? 더이상 없을 때 까지&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;tree-traversing&quot;&gt;Tree traversing&lt;/h4&gt;

&lt;p&gt;LinkedList, Stack, Queue같은 경우는 선형적인 Data structure&lt;/p&gt;

&lt;p&gt;이런 경우 그냥 순서에 따라 출력하면 되는데&lt;/p&gt;

&lt;p&gt;Tree같은 경우는 어떤 규칙에 따라서 출력을 해야할까?&lt;/p&gt;

&lt;p&gt;Tree&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Complicated than a list&lt;/li&gt;
  &lt;li&gt;데이터 전체를 출력하는 여러가지 방법이 있다.
    &lt;ul&gt;
      &lt;li&gt;List라면
        &lt;ul&gt;
          &lt;li&gt;순서에 따라서 처음부터 끝까지 보여주면 된다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;BST라면?
        &lt;ul&gt;
          &lt;li&gt;어떤식으로 보여줄지 정해야 한다.
            &lt;ul&gt;
              &lt;li&gt;LHS&lt;/li&gt;
              &lt;li&gt;RHS&lt;/li&gt;
              &lt;li&gt;The value that you have&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;depth-first-traverse&quot;&gt;Depth First Traverse&lt;/h5&gt;

&lt;p&gt;value, LHS, RHS 이 세가지를 출력할 순서를 정해야 한다.&lt;/p&gt;

&lt;p&gt;Value를 언제 출력하냐에 따라 3가지로 나뉨&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Pre-order traverse
    &lt;ul&gt;
      &lt;li&gt;Value를 먼저 출력&lt;/li&gt;
      &lt;li&gt;순서 : Current, LHS, RHS in &lt;strong&gt;Recursion&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;In-order traverse
    &lt;ul&gt;
      &lt;li&gt;LHS와 RHS 사이에&lt;/li&gt;
      &lt;li&gt;순서 : LHS, Current, RHS in &lt;strong&gt;Recursion&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;Sorting되어있는 결과와 동일함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Post-order traverse
    &lt;ul&gt;
      &lt;li&gt;LHS와 RHS 뒤에&lt;/li&gt;
      &lt;li&gt;순서 : LHS, RHS, Current in &lt;strong&gt;Recursion&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;일반적으로 LHS를 RHS보다 먼저 출력함 (LHS가 더 작은 값이니까)&lt;/p&gt;

&lt;p&gt;Current의 LHS와 RHS에서도 그들의 LHS, RHS에 대해서 똑같은 방법으로 &lt;strong&gt;Recursion&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;(smaller scale에서 같은 algorithm으로 처리 -&amp;gt; recursion)&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BinarySearchTree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;traverseInOrder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        	&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# Append LHS first&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;traverseInOrder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# Append current second&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# Append RHS third&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;traverseInOrder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;traversePreOrder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# Append current first&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# Append LHS second&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;traversePreOrder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# Append RHS third&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRHS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;traversePreOrder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;traversePost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
         &lt;span class=&quot;c&quot;&gt;# Append LHS first&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;traversePreOrder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# Append RHS second&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRHS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;traversePreOrder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# Append current third&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h5 id=&quot;breadth-first-traverse&quot;&gt;Breadth First Traverse&lt;/h5&gt;

&lt;p&gt;Recursion는 Stackframe을 사용했었다. (Top-down, LIFO)&lt;/p&gt;

&lt;p&gt;하지만 Breadth First traverse는 Queue-based level-order traverse&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Enqueue the root
    &lt;ul&gt;
      &lt;li&gt;while until queue is empty&lt;/li&gt;
      &lt;li&gt;Print current&lt;/li&gt;
      &lt;li&gt;current의 LHS가 존재한다
        &lt;ul&gt;
          &lt;li&gt;Enqueue current LHS&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;current의 RHS가 존재한다
        &lt;ul&gt;
          &lt;li&gt;Enqueue current RHS&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;BinarySearchTree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# Queue를 이용한 traversing 방법&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;traverseLevelOrder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enqueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# Queue가 비워질 때까지 반복&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# Dequeue되는 Node의 LHS,RHS를 거치면서 없을 때 까지 반복한다.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isEmpty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dequeue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;# Append current first&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;# LHS가 있으면 Append&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enqueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getLHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;# RHS가 있으면 Append&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;Q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enqueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getRHS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;performance-of-binary-search-tree&quot;&gt;Performance of Binary Search Tree&lt;/h3&gt;

&lt;p&gt;장점&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;규칙에 따라 데이터를 저장함으로써 검사를 안해도 되는 영역이 넓어진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하지만 Depth height만 높은 Tree는 이런 장점이 사라지게 된다.&lt;/p&gt;</content><author><name>고중범</name></author><category term="Data Structure" /><category term="Tree" /><category term="BST" /><summary type="html">문일철 교수님의 데이터 구조 및 분석 Linear Structure and Dynamic Programming edwith 강의를 보고 정리한 내용입니다.</summary></entry><entry><title type="html">test</title><link href="http://localhost:4000/test/2020/04/10/test-post/" rel="alternate" type="text/html" title="test" /><published>2020-04-10T21:00:00+09:00</published><updated>2020-04-10T21:00:00+09:00</updated><id>http://localhost:4000/test/2020/04/10/test-post</id><content type="html" xml:base="http://localhost:4000/test/2020/04/10/test-post/">&lt;p&gt;Here is one mermaid diagram:&lt;/p&gt;
&lt;div class=&quot;mermaid&quot;&gt;
  graph TD
  A[Client] --&amp;gt; B[Load Balancer]
  B --&amp;gt; C[Server1]
  B --&amp;gt; D[Server2]
&lt;/div&gt;

&lt;p&gt;And here is another:&lt;/p&gt;
&lt;div class=&quot;mermaid&quot;&gt;
  graph TD
  A[Client] --&amp;gt;|tcp_123| B(Load Balancer)
  B --&amp;gt;|tcp_456| C[Server1]
  B --&amp;gt;|tcp_456| D[Server2]
&lt;/div&gt;
&lt;p&gt;This formula $f(x) = x^2$ is an example&lt;/p&gt;

&lt;p&gt;This formula $f(x) = x^2$ is an example.&lt;/p&gt;

&lt;p&gt;This formula $f(x) = x^2$ is an example&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$$
\lim_{x\to 0}{\frac{e^x-1}{2x}}
\overset{\left[\frac{0}{0}\right]}{\underset{\mathrm{H}}{=}}
\lim_{x\to 0}{\frac{e^x}{2}}={\frac{1}{2}}
$$
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;mermaid&quot;&gt;
  graph TD
  A[Company] --&amp;gt; |150| B[Human Resource Department]
  A --&amp;gt; |300| C[Sales Department]
  A --&amp;gt; |150| D[Development Department]
  C --&amp;gt; |100| E(Seoul Store)
  C --&amp;gt; |100| F(Incheon Store)
  C --&amp;gt; |100| H(Bucheon Store)
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph TD
  A[&quot;회사&quot;] --&amp;gt; |150| B[&quot;인사부&quot;]
  A --&amp;gt; |300| C[&quot;영업부&quot;]
  A --&amp;gt; |150| D[&quot;개발부&quot;]
  C --&amp;gt; |100| E(&quot;서울점&quot;)
  C --&amp;gt; |100| F(&quot;인천점&quot;)
  C --&amp;gt; |100| H(&quot;부천점&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&quot;mermaid&quot;&gt;
  graph TD
  A[(Company)] --&amp;gt; B[(Human Resource Department)]
  A --&amp;gt; C[(Sales Department)]
  A --&amp;gt; D[(Development Department)]
  C --&amp;gt; E(Seoul Store)
  C --&amp;gt; F(Incheon Store)
  C --&amp;gt; H(Bucheon Store)
&lt;/div&gt;

&lt;pre&gt;&lt;code class=&quot;language-mermaid&quot;&gt;graph BT 
subgraph Stackframe
	subgraph A
		1-1(&quot;F(4)&quot;) --- 101(&quot;Top&quot;) 
	end
	subgraph two
		2-1(&quot;F(4)&quot;) --- 2-2(&quot;F(3)&quot;) --- 102(&quot;Top&quot;) 
	end 
	subgraph three
		3-1(&quot;F(4)&quot;) --- 3-2(&quot;F(3)&quot;) --- 3-3(&quot;F(2)&quot;) --- 103(&quot;Top&quot;) 
	end 
	subgraph four
		4-1(&quot;F(4)&quot;) --- 4-2(&quot;F(3)&quot;) --- 4-3(&quot;F(2)&quot;) --- 4-4(&quot;F(1)&quot;) --- 104(&quot;Top&quot;) 
  end 
  subgraph five
	  5-1(&quot;F(4)&quot;) --- 5-2(&quot;F(3)&quot;) --- 5-3(&quot;F(2)&quot;) --- 5-4(&quot;F(0)&quot;) --- 105(&quot;Top&quot;) 
  end 
  subgraph six
	  6-1(&quot;F(4)&quot;) --- 6-2(&quot;F(3)&quot;) --- 6-3(&quot;F(2)&quot;) --- 106(&quot;Top&quot;) 
  end 
  subgraph seven
	  7-1(&quot;F(4)&quot;) --- 7-2(&quot;F(3)&quot;) --- 107(&quot;Top&quot;) 
  end 
  subgraph eight
	  8-1(&quot;F(4)&quot;) --- 108(&quot;Top&quot;) 
  end
  subgraph nine 
	  109(&quot;Top&quot;) 
  end
end 
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&quot;mermaid&quot;&gt;
  graph TD
  A[(Company)] --- B[(test)]
&lt;/div&gt;

&lt;div class=&quot;mermaid&quot;&gt;
  graph LR
  id1[(Database)]
&lt;/div&gt;</content><author><name>고중범</name></author><category term="test" /><summary type="html">test</summary></entry><entry><title type="html">OS Lecture 5</title><link href="http://localhost:4000/os/2020/04/07/OS5-post/" rel="alternate" type="text/html" title="OS Lecture 5" /><published>2020-04-07T21:00:00+09:00</published><updated>2020-04-07T21:00:00+09:00</updated><id>http://localhost:4000/os/2020/04/07/OS5-post</id><content type="html" xml:base="http://localhost:4000/os/2020/04/07/OS5-post/">&lt;p&gt;유튜브 &lt;a href=&quot;https://www.youtube.com/channel/UCHvXywxOtwLedY5OX-Teg5w&quot;&gt;HPC Lab. KOREATECH 채널&lt;/a&gt;, 김덕수 교수님의 OS 강의를 보고 정리한 내용입니다.&lt;/p&gt;

&lt;h1 id=&quot;lecture-5&quot;&gt;Lecture 5&lt;/h1&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;process-scheduling&quot;&gt;Process Scheduling&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;여러개의 Process&lt;/strong&gt;가 &lt;strong&gt;시스템(Kernel) 내 존재&lt;/strong&gt;하고, (다중프로그래밍 환경)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CPU라는 Resource을 나눠서 사용&lt;/strong&gt;해야함&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;스케줄링&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;:자원을 할당 할 프로세스를 선택하는것&lt;/p&gt;

&lt;p&gt;자원관리&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Time sharing 관리
    &lt;ul&gt;
      &lt;li&gt;하나의 자원(Processor)을 여러 Thread들이 번갈아 가며 활용&lt;/li&gt;
      &lt;li&gt;Process scheduling (이번 시간에 배울거)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Space sharing 관리
    &lt;ul&gt;
      &lt;li&gt;하나의 자원(Memory)를 분할하여 동시에 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;goal-of-scheduling&quot;&gt;Goal of Scheduling&lt;/h1&gt;

&lt;p&gt;: 시스템의 &lt;strong&gt;Performance&lt;/strong&gt;를 높이는 것&lt;/p&gt;

&lt;p&gt;여기서 Performance(성능)라는것은 &lt;strong&gt;모호한 표현&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;-&amp;gt; 기준이 무엇인가에 따라서 바뀔 수 있다.&lt;/p&gt;

&lt;p&gt;System Performance의 대표적 지표 (index)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Response time (응답시간)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;작업요청(submission)으로부터 응답을 받을때까지의 시간&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Throughput (작업 처리량)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;단위 시간 동안 완료된 작업의 수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Resource utilization (자원 활용도)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;주어진 시간동안 자원이 활용된 시간&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;전부 중요한 지표이며, &lt;strong&gt;목적에 따라&lt;/strong&gt; 그 중요도가 달라진다.&lt;/p&gt;

&lt;p&gt;-&amp;gt; &lt;strong&gt;목적에 맞는 지표를 고려&lt;/strong&gt;해서 Scheduling 기법을 선택해야함&lt;/p&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자 대화형 시스템, Real time system -&amp;gt; Response time이 제일 중요!&lt;/li&gt;
  &lt;li&gt;Batch system -&amp;gt; Throughput이 제일 중요!&lt;/li&gt;
  &lt;li&gt;비싼 장비 -&amp;gt; Resource utilization이 제일 중요!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그 외에도 많은 지표들이 있음&lt;/p&gt;

&lt;p&gt;+++&lt;/p&gt;

&lt;h1 id=&quot;waiting-time-response-time-turn-around-time-대기시간-응답시간-반환시간&quot;&gt;Waiting time, Response time, Turn-around time (대기시간, 응답시간, 반환시간)&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Waiting time&lt;/strong&gt; : Process가 실행을 &lt;strong&gt;기다리는 시간&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Response time&lt;/strong&gt; : &lt;strong&gt;첫번째 출력&lt;/strong&gt;까지 걸린 시간&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Turn-around time&lt;/strong&gt; : 원하는 일이 &lt;strong&gt;모두 끝날 때까지의 시간&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;dl&gt;
      &lt;dt&gt;Normalized Turn-around time = (Turn-around time) / (Burst time)&lt;/dt&gt;
      &lt;dd&gt;
        &lt;p&gt;동일한 기준으로 평가하고 싶을 때 사용함 (절대적인 시간이 아닌 &lt;strong&gt;상대적인 시간&lt;/strong&gt;이라고 보면 됨)&lt;/p&gt;
      &lt;/dd&gt;
    &lt;/dl&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Burst time&lt;/strong&gt; : 실제로 Process가 &lt;strong&gt;실행된 시간&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;scheduling-criteria-and-levels-스케줄링-기준-및-단계&quot;&gt;Scheduling Criteria and Levels (스케줄링 기준 및 단계)&lt;/h1&gt;

&lt;h2 id=&quot;scheduling-criteria&quot;&gt;Scheduling Criteria&lt;/h2&gt;

&lt;p&gt;: &lt;strong&gt;스케줄링 기법이 고려하는 항목들&lt;/strong&gt; -&amp;gt; 기준&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Process의 특성&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Compute bounded or I/O bounded
        &lt;ul&gt;
          &lt;li&gt;Compute bounded :  CPU를 더 많이 쓰는 Program&lt;/li&gt;
          &lt;li&gt;I/O bounded :  I/O가 더 많은 Program&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;시스템 특성&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Batch system or interactive system (목적에 따라 달라지게 됨)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Process의 긴급성 (Urgency)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Hard or soft real time, non-real time systems&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Process Priority&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Total Process Service time&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;cpu-burst-vs-io-burst&quot;&gt;CPU burst vs I/O burst&lt;/h2&gt;

&lt;p&gt;Process 수행 = (cpu 사용 + I/O 대기) 를 반복&lt;/p&gt;

&lt;p&gt;어떤 Program은 CPU를 더 많이 쓸 수도있고, 어떤 Program은 I/O를 더 많이 할 수도 있다.&lt;/p&gt;

&lt;p&gt;이때 CPU를 더 많이 쓰는 Program -&amp;gt; Compute-bounded Process&lt;/p&gt;

&lt;p&gt;반면 I/O가 더 많은 Program -&amp;gt; I/O bounded Process&lt;/p&gt;

&lt;h1 id=&quot;scheduling-level&quot;&gt;Scheduling Level&lt;/h1&gt;

&lt;p&gt;: &lt;strong&gt;발생하는 빈도&lt;/strong&gt; &lt;strong&gt;및 할당 자원&lt;/strong&gt;에 따른 구분&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Long-term Scheduling (가끔)&lt;/li&gt;
  &lt;li&gt;Mid-term Scheduling (종종)&lt;/li&gt;
  &lt;li&gt;Short-term Scheduling (자주)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;long-term-scheduling&quot;&gt;Long-term Scheduling&lt;/h2&gt;

&lt;p&gt;: 긴 시간에 한번씩 일어나는 schduling&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Job scheduling&lt;/strong&gt;이 속함  (Process라는 건 job이 커널에 등록된 것이라는 거 기억!)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;어떤 Job을 Kernel에 등록할지 결정&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다중프로그래밍의 정도(Degree) 조절&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;다중프로그래밍의 정도 : 시스템 내의 프로세스의 수&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;ex) 있는 프로세스를 다 등록해놔도 상관없겠지만 관리하기 쉽도록 조절&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;그래서 많은 Process 중에 어떤 Process을 먼저 올려줄 것 인가?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I/O-bounded와 compute-bounded 프로세스중에 선택해야한다면?&lt;/p&gt;

&lt;p&gt;-&amp;gt; 잘 섞어서 선택해야 한다. 왜?&lt;/p&gt;

&lt;p&gt;-&amp;gt; 시스템 입장에서 하나가 논다는것은 비효율적이니까, &lt;strong&gt;I/O와 프로세서가 둘다 열심히 일하는게 효율적임&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;시분할 시스템(Time-sharing)에서는 모든 Job을 시스템에 등록&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Long-term scheduling이 상대적으로 덜 중요함&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;mid-term-scheduling&quot;&gt;Mid-term Scheduling&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Memory allcation&lt;/strong&gt; 결정&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ex) Swapping&lt;/li&gt;
  &lt;li&gt;Intermediate-level scheduling&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;short-term-scheduling&quot;&gt;Short-term Scheduling&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Process scheduling&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Processor를 할당받을 Process를 결정&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Processor scheduler, dispatcher(ready state -&amp;gt; running state) 라고도 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;가장 빈번하게 발생&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;매우 빨라야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;scheduling-policy&quot;&gt;Scheduling Policy&lt;/h1&gt;

&lt;p&gt;Policy : 뭔가를 &lt;strong&gt;수행하기 위한 방법? or 기준?&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Preemptive vs Non-preemptive&lt;/strong&gt; (선점 vs 비선점)&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Priority&lt;/strong&gt; (우선순위)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;preemptive--non-preemptive-scheduling&quot;&gt;Preemptive / Non-preemptive scheduling&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Preemptive&lt;/strong&gt;(선점) : 누가와서 &lt;strong&gt;빼앗을 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Non-preemptive&lt;/strong&gt;(비선점) : 누가와서 &lt;strong&gt;빼앗을 수 없다.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;non-preemptive-scheduling&quot;&gt;Non-preemptive scheduling&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Process가 &lt;strong&gt;스스로 반납할 때 까지&lt;/strong&gt; 사용 (안 뺏김)&lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Context switch overhead가 적음&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;우선순위가 높은 걸 먼저 처리 못하는 &lt;strong&gt;우선순위 역전현상&lt;/strong&gt;이 일어남&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;평균 응답시간 증가&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;preemptive-scheduling&quot;&gt;Preemptive scheduling&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;자원을 뺏길 수 있음
    &lt;ul&gt;
      &lt;li&gt;할당시간 종료, 우선순위가 높은 프로세스 등장&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;Time-sharing system, real-time system에 적합 -&amp;gt; 응답성이 높다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;Process가 자주 바뀌어서 &lt;strong&gt;Context switch overhead가 커짐&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;priority&quot;&gt;Priority&lt;/h2&gt;

&lt;p&gt;: 우선순위&lt;/p&gt;

&lt;h3 id=&quot;static-priority&quot;&gt;Static priority&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;: 프로세스 생성시 결정된 Priority가 유지됨&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;구현이 쉽다.&lt;/li&gt;
  &lt;li&gt;Context switch &lt;strong&gt;overhead가 적다&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;환경변화에 대한 대응을 잘 못함&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dynamic-priority&quot;&gt;Dynamic priority&lt;/h3&gt;

&lt;p&gt;: &lt;strong&gt;프로세스의 상태변화에 따라 변경&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;구현이 복잡하다.&lt;/li&gt;
  &lt;li&gt;Context switch &lt;strong&gt;overhead가 크다&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;환경변화에 대한 &lt;strong&gt;유연한 대처&lt;/strong&gt; 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;여기까지-요약&quot;&gt;여기까지 요약&lt;/h1&gt;

&lt;p&gt;System에는 Process가 많으니까 (Multi-Programming),&lt;/p&gt;

&lt;p&gt;Scheduling이 필요하고,&lt;/p&gt;

&lt;p&gt;그 목적은 Performance을 높이는 것이고,&lt;/p&gt;

&lt;p&gt;Performance에는 다양한 Index가 있고,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Response time&lt;/li&gt;
  &lt;li&gt;Throughput&lt;/li&gt;
  &lt;li&gt;Resource utilization&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Scheduling에는 다양한 Criteria가 있고,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Feature of Process&lt;/li&gt;
  &lt;li&gt;Feature of System&lt;/li&gt;
  &lt;li&gt;Urgency of Process&lt;/li&gt;
  &lt;li&gt;Process Priority&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Scheduling은 빈도에 따라 Level이 나뉘고,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Long term&lt;/li&gt;
  &lt;li&gt;Mid-term&lt;/li&gt;
  &lt;li&gt;Short-term&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Scheduling은 다양한 Policy이 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Preemptive / Non-preemptive&lt;/li&gt;
  &lt;li&gt;Priority&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;basic-scheduling-algorithms-기본-스케줄링-알고리즘들&quot;&gt;Basic scheduling algorithms (기본 스케줄링 알고리즘들)&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;FCFS&lt;/li&gt;
  &lt;li&gt;RR&lt;/li&gt;
  &lt;li&gt;SPN&lt;/li&gt;
  &lt;li&gt;STRN&lt;/li&gt;
  &lt;li&gt;HRRN&lt;/li&gt;
  &lt;li&gt;MLQ&lt;/li&gt;
  &lt;li&gt;MFQ&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;엄청 많네&lt;/p&gt;

&lt;h2 id=&quot;fcfs-first-come-first-service&quot;&gt;FCFS (First-Come-First-Service)&lt;/h2&gt;

&lt;p&gt;: 선착순&lt;strong&gt;, **먼저 오는 Process에게 먼저 Processor를 할당해줄거다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Non-preemptive scheduling (내 일이 끝날 때까지.)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;스케줄링의 기준 (Criteria)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;도착시간 기준 (Ready queue 기준)&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;자원을 &lt;strong&gt;효율적으로 사용&lt;/strong&gt; 가능
        &lt;ul&gt;
          &lt;li&gt;불필요한 &lt;strong&gt;Overhead없어서 자원을 계속계속 사용&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Batch system에 적합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;긴 평균 응답시간 (Interactive system에 부적합)
        &lt;ul&gt;
          &lt;li&gt;먼저온 Process 실행 끝날때까지 기다려야해서 Response를 바로바로 받을 수가 없음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Convoy effect
        &lt;ul&gt;
          &lt;li&gt;먼저온 Process가 끝나길 기다리느라 다른 Process들도 긴 대기시간을 갖게 됨 &lt;strong&gt;(대기시간 » 실행시간)&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=r1JVA7yOPAM&amp;amp;t=623s&quot;&gt;실습영상&lt;/a&gt; 6분 30초 확인&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;rr-round-robin&quot;&gt;RR (Round-Robin)&lt;/h2&gt;

&lt;p&gt;: “일정시간만큼 돌아가면서 쓰자” 라는 기법 (원형탁상위에서 돌면서 하는 scheduling 연상 )&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Preemptive scheduling&lt;/li&gt;
  &lt;li&gt;스케줄링의 기준 (Criteria)
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;도착시간 기준 (Ready queue 기준)&lt;/strong&gt; -&amp;gt; 먼저 도착한 프로세스부터&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Resource 사용 &lt;strong&gt;제한시간&lt;/strong&gt;이 있음 (&lt;strong&gt;Time quantum&lt;/strong&gt;)
    &lt;ul&gt;
      &lt;li&gt;System parameter&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Process는 할당된 시간이 지나면 자원 반납 (Timer-runout)&lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;자원 독점을 방지&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;자꾸 프로세스를 바꿔야하니까 &lt;strong&gt;Overhead가 큼&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Interactive system과 Time-sharing system에 적합&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Time quantum이 System의 Performance를 결정하는 핵심요소&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;만약 &lt;strong&gt;Time quantum이 크다?&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;-&amp;gt; FCFS와 비슷한 효과&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;만약 &lt;strong&gt;Time quantum이 0이 작다?&lt;/strong&gt; (0에 수렴한다?)&lt;/p&gt;

    &lt;p&gt;-&amp;gt; Process를 동시에 여러개 쓰고있는 느낌&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;하지만 Processor 체감 성능은 실제 프로세서의 성능의 1/n. 그리고 Overhead도 크다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;한번 실행된 Process는 &lt;strong&gt;맨 뒤로 가서 다시 줄을 선다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;(&lt;strong&gt;Arrival time&lt;/strong&gt;도 있으니 그것도 고려해야함 (Ready queue기준 빨리온 순서!))&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=r1JVA7yOPAM&amp;amp;t=623s&quot;&gt;실습영상&lt;/a&gt; 21분 58초 확인&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;spn-shortest-process-next&quot;&gt;SPN (Shortest-Process-Next)&lt;/h2&gt;

&lt;p&gt;: &lt;strong&gt;Burst time이 가장 작은 프로세스를 먼저 처리하자!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;위에서 나온 FCFS에서의 문제점?&lt;/p&gt;

&lt;p&gt;-&amp;gt; 빨리 끝내고 나갈 수 있는 Process가 &lt;strong&gt;오래 기다려야 한다는 것&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Non-preemptive scheduling&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Scheduling Criteria&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Burst time 기준&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;SJF(Shortest Job First) scheduling&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;장점&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;평균 대기시간(WT) 최소화&lt;/li&gt;
      &lt;li&gt;시스템 내 프로세스 수 최소화
        &lt;ul&gt;
          &lt;li&gt;부하 감소, 메모리 절약&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;많은 프로세스들에게 &lt;strong&gt;빠른 응답시간 제공&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;단점&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;Starvation 현상 발생 (무한대기 현상)&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;-&amp;gt; Burst time이 긴 프로세스는 무한으로 대기해야할 수도 있음&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;정확한 실행시간을 알 수 없음&lt;/strong&gt;&lt;/p&gt;

        &lt;p&gt;-&amp;gt; SPN을 사용하려면 &lt;strong&gt;실행시간을 알아야 Scheduling을 할 수 있는데&lt;/strong&gt;,&lt;/p&gt;

        &lt;p&gt;​    &lt;strong&gt;실행해보기 전까지 얼마나 걸리는지는 알 수가 없음&lt;/strong&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;실행시간 예측 기법이 필요하다&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;마트에 있는 소량계산대랑 비슷하게 보면 될 것 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=keY9Wi7scEs&quot;&gt;실습영상&lt;/a&gt; 5분 40초&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;srtn-shortest-remaning-time-next&quot;&gt;SRTN (Shortest Remaning Time Next)&lt;/h2&gt;

&lt;p&gt;: SPN의 변형버전, 남은 실행시간이 가장 적은 Process부터 실행시키는 기법&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Preemptive scheduling&lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;SPN 장점 극대화&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;시스템 내 프로세스 수 최소화, 평균 대기시간 최소화&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;실행시간 예측의 어려움&lt;/li&gt;
      &lt;li&gt;잔여 실행시간을 계속 추적해야함&lt;/li&gt;
      &lt;li&gt;Overhead&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;구현 및 사용이 비현실적임&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;hrrn-high-response-ratio-next&quot;&gt;HRRN (HIgh-Response-Ratio-Next)&lt;/h2&gt;

&lt;p&gt;: SPN의 변형, Process의 대기시간을 고려한 기법&lt;/p&gt;

&lt;p&gt;SPN에서의 문제는 &lt;strong&gt;starvation 현상&lt;/strong&gt;이 문제 (무한대기)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Non-preemptive scheduling&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;SPN + Aging concepts
    &lt;ul&gt;
      &lt;li&gt;Aging concepts이란?
        &lt;ul&gt;
          &lt;li&gt;노약자를 배려하자 -&amp;gt; &lt;strong&gt;Waiting time을 고려하라&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Scheduling Criteria
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Response ratio가 높은 Process 우선&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Response ratio = {WT + BT}/\ {BT}&lt;/script&gt;

&lt;p&gt;​															필요한 BT(실행시간) 대비 얼마나 WT(대기시간)했는가가 기준이 됨&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;SPN의 장점 + Starvation 현상 제거&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;실행시간 예측이 필요&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=keY9Wi7scEs&quot;&gt;실습영상 &lt;/a&gt;13분 40초&lt;/p&gt;

&lt;p&gt;지금까지의 Scheduling algorithm을 정리해보면&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;공평성(Fairness)가 목적&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;FCFS&lt;/li&gt;
  &lt;li&gt;RR&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Efficiency/Performance가 목적&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SPN&lt;/li&gt;
  &lt;li&gt;SRTN&lt;/li&gt;
  &lt;li&gt;HRRN&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;아래있는 Algorithm들의 문제점은 &lt;strong&gt;실행시간을 예측&lt;/strong&gt;해야 한다는것&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;mlq-multi-level-queue&quot;&gt;MLQ (Multi-level Queue)&lt;/h2&gt;

&lt;p&gt;위의 SPN를 변형한 알고리즘들의 문제점인 “실행시간 예측”&lt;/p&gt;

&lt;dl&gt;
  &lt;dt&gt;&lt;strong&gt;실행시간 예측하지 않고 비슷한 효과를 내보자!&lt;/strong&gt; 라는 컨셉&lt;/dt&gt;
  &lt;dd&gt;
    &lt;p&gt;&lt;strong&gt;Ready Queue를 여러개&lt;/strong&gt;를 가지고 &lt;strong&gt;각Queue마다 작업(or 우선순위)를 배정&lt;/strong&gt;하겠다.&lt;/p&gt;
  &lt;/dd&gt;
&lt;/dl&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;최초 배정 된 Queue를 벗어나지 못함&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;각각의 Queue는 자신만의 Scheduling algorithm 사용&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Queue사이에는&lt;/strong&gt; &lt;strong&gt;우선순위 기반&lt;/strong&gt;의 Scheduling 사용&lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;우선순위가 높은 Queue에 있는 Process 처리는 빠름&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;여러개의 Queue 관리하는 것 자체가 힘듬&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;우선순위가 낮은 Queue에는 Starvation 현상이 일어난다.&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;mfq-multi-level-feedback-queue&quot;&gt;MFQ (Multi-level Feedback Queue)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;MLQ의 경우, 최초 배정된 Queue를 벗어나지 못했다.&lt;/strong&gt;&lt;/p&gt;

&lt;dl&gt;
  &lt;dt&gt;-&amp;gt; 변화에 적응할 수가 없다.&lt;/dt&gt;
  &lt;dd&gt;
    &lt;p&gt;그래서 MFQ는 &lt;strong&gt;Feedback을 통해&lt;/strong&gt; Priority를 조정&lt;/p&gt;
  &lt;/dd&gt;
&lt;/dl&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Dynamic priority&lt;/strong&gt; (우선순위 조정에 현재까지의 Processor 사용 정보를 활용)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Preemptive scheduling&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;장점
    &lt;ul&gt;
      &lt;li&gt;BT(Burst time)를 예상하지 않아도 됨&lt;/li&gt;
      &lt;li&gt;Queue 사이를 이동할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단점
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;복잡하다.&lt;/strong&gt; (우선순위 조정, Queue와 Queue사이 이동..)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Overhead가 크다.&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;우선순위 낮은 Queue의 Process들은 &lt;strong&gt;Starvation 현상&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;변형
    &lt;ul&gt;
      &lt;li&gt;Queue마다 시간 할당량을 다르게 배정
        &lt;ul&gt;
          &lt;li&gt;Process 특성에 맞는 형태로 시스템 운영&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;I/O bounded Process을 상위 단계 Queue로 이동
        &lt;ul&gt;
          &lt;li&gt;평균 응답시간을 줄임, 작업분산으로 Utilization 극대화&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Starvation을 방지하기 위해 &lt;strong&gt;Aging기법&lt;/strong&gt;으로 오래 기다린 Process를 상위 Queue로 이동&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Parameters for MFQ scheduling
    &lt;ul&gt;
      &lt;li&gt;Queue의 수&lt;/li&gt;
      &lt;li&gt;Queue별 스케줄링 알고리즘&lt;/li&gt;
      &lt;li&gt;우선순위 조정기준&lt;/li&gt;
      &lt;li&gt;…&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다양한 Parameter를 줘서  목적에 맞게 사용&lt;/p&gt;</content><author><name>고중범</name></author><category term="OS" /><summary type="html">김덕수 교수님의 OS강의 Lecture 5</summary></entry><entry><title type="html">Github 블로그 기능추가</title><link href="http://localhost:4000/information/2020/04/06/add_utility-post/" rel="alternate" type="text/html" title="Github 블로그 기능추가" /><published>2020-04-06T21:00:00+09:00</published><updated>2020-04-06T21:00:00+09:00</updated><id>http://localhost:4000/information/2020/04/06/add_utility-post</id><content type="html" xml:base="http://localhost:4000/information/2020/04/06/add_utility-post/">&lt;hr /&gt;

&lt;h1 id=&quot;github-blog에-댓글-기능-만들기-jekyll-utterances&quot;&gt;Github Blog에 댓글 기능 만들기 (Jekyll, utterances)&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://madplay.github.io/post/jekyll-blog-comments-with-utterances&quot;&gt;MadPlay’s MadLife님 블로그 참고&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;과정&quot;&gt;과정&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;utterances-다운로드&quot;&gt;utterances 다운로드&lt;/h3&gt;

    &lt;ul&gt;
      &lt;li&gt;https://utteranc.es/&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;새로운-repository-생성-optional&quot;&gt;새로운 Repository 생성 (Optional)&lt;/h3&gt;

    &lt;ul&gt;
      &lt;li&gt;그냥 같은 repository에다가 해도 상관없음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;utterances에서-빈칸을-채우고-매핑방법-선택&quot;&gt;utterances에서 빈칸을 채우고 매핑방법 선택&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;만들어진-스크립트-코드를-복사해서-포스트-레이아웃에-include&quot;&gt;만들어진 스크립트 코드를 복사해서 포스트 레이아웃에 include&lt;/h4&gt;

    &lt;ul&gt;
      &lt;li&gt;스트립트 코드의 repo 항목이 내가 선택한 repository가 맞는지 확인&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;웹프로그래밍을 아예 모르다보니 어디다가 붙여넣기 해야하는지 햇갈렸는데 겨우 찾았다.&lt;/p&gt;

&lt;p&gt;테마마다 다를수도 있음.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;/_includes 에 아래와 같은 코드를 가진 comments.html 파일을 만든다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;-comments.html-&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://utteranc.es/client.js&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;repo=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Kojungbeom/-wareHouse&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;issue-term=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;pathname&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;theme=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;github-light&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;crossorigin=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;anonymous&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;/_layouts/post.html 맨 아랫줄에 다음과 같은 코드를 추가한다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;hr&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://utteranc.es/client.js&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;repo=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Kojungbeom/kojungbeom.github.io&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;issue-term=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;title&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;theme=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;github-light&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;crossorigin=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;anonymous&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;async&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;github-blog에-카테고리와-테마-추가하기&quot;&gt;Github Blog에 카테고리와 테마 추가하기&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;[https://devyurim.github.io/development%20environment/github%20blog/2018/08/07/blog-6.html](https://devyurim.github.io/development environment/github blog/2018/08/07/blog-6.html)&quot;&gt;devYurim님 블로그 참고&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;위 블로그에서는 category.html, index.html 파일을 수정해야 한다고 하셨는데,&lt;/p&gt;

&lt;p&gt;저같은 경우는 그냥 아무것도 안하고 글에&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;categories:
  - Information
tags:
  - Information
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그냥 이런식으로 해주니까 나왔습니다.&lt;/p&gt;

&lt;p&gt;Jekyll 자체가 워낙 잘되있어서 그런듯하지만, 테마마다 다를 수 있으므로 위 블로그를 참고하세요.&lt;/p&gt;</content><author><name>고중범</name></author><category term="Information" /><category term="Jekyll" /><summary type="html">까먹었다면 여기로</summary></entry></feed>