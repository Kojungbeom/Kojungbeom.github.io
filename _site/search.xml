<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[How to install SCALA]]></title>
      <url>/installation/2020/09/02/how_to_install_scala/</url>
      <content type="text"><![CDATA[INSTALL SCALA1. Download tar.gz filehttps://www.scala-lang.org/download/install.html2. Extract File$ tar xvf scala-2.x.x.tgz3. Move Scala folder$ mv scala-2.x.x /usr/local/share/scala4. Set Environment Variable$ vim .bashrc$ export SCALA_HOME=/usr/local/share/scala$ export PATH=$PATH:$SCALA_HOME/bin$ source .bashrc5. Restart Terminal and Check version$ scala --version]]></content>
      <categories>
        
          <category> Installation </category>
        
      </categories>
      <tags>
        
          <tag> Installation </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Ubuntu 18.04 LTS 네트워크 설정]]></title>
      <url>/ubuntu/2020/09/02/ubuntu_network/</url>
      <content type="text"><![CDATA[Ubuntu 18.04 LTS 네트워크 설정DNS 확인$ nslookup server$ nslookup&gt; serverHostname 설정설정파일로 변경$ hostname$ sudo vim /etc/hostname$ sudo reboot  hostname을 변경명령어로 변경하기$ hostnamectl set-hostname "Host_name"$ sudo reboot고정 IP설정$ sudo vim /etc/netplan/*.yaml# Let NetworkManager manage all devices on this systemnetwork:  ethernets:      enp0s31f6:              dhcp4: no              dhcp6: no              #optional: true              addresses: [192.x.x.x/xx]              gateway4 : 192.x.x.x              nameservers:                      addresses: [8.8.8.8,8.8.4.4]  version: 2$ sudo netplan apply$ ip addr$ ip route$ ifconfig서브넷 계산표자동 IP설정# Let NetworkManager manage all devices on this systemnetwork:    ethernets:        enp0s3:            addresses: []            dhcp4: true            optional: true    version: 2$ sudo netplan apply$ ip addr$ ip route$ ifconfigRoute 확인$ route -nroute$ route$ route -nnetstat -r$ netstat -r$ netstat -rnipip route list]]></content>
      <categories>
        
          <category> Ubuntu </category>
        
      </categories>
      <tags>
        
          <tag> Ubuntu </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[GCC란]]></title>
      <url>/installation/2020/08/20/gcc/</url>
      <content type="text"><![CDATA[이 글은 내가 편하게 보겠다고 만든 요약본입니다. 본문 링크1. gcc세상에서 가장 뛰어난 C compiler 중 하나이다. C언어는 컴퓨터 세상의 만국공통어이고, gcc는 리눅스와 일심동체라고 봐도 무방하다고 한다. (여기서 그랬음..) 저 링크에서 보면 도스/윈도우 환경에서 배운 C가 엉터리라고 하는데, 요즘 Ubuntu환경에서 C++ 프로그래밍을 하다보면 진짜 맞는거 같다. 도스/윈도우 환경에서 했던거는 하기 쉽게 잘 만들어놔서 코드말고는 신경쓸게 없었다면, 리눅스 환경에서 하려면 Compile과정에 대한 이해도 필요하기 때문이다. 지금까지 C는 할 줄 안다고 생각했던게 좀 부끄러워진다. 하지만 이제부터 잘하면 될 일, C의 “ 정통사용법”에 대해서 익혀보자.  gcc = 1종 보통 수동 스틱방식, 정통 소림권법, 3대째 내려오는 비법 떡갈비집2. gcc 에 대한 기본 이해$ gcc -version  gcc version 출력하기gcc 나도 처음에는 그냥 패키지로 깔 필요도 없이 먼저 깔려있었던 거 같은데, 소스코드로 부터 설치해보면 구조를 파악할 수 있다니 한번 따라가보자./usr/lib/gcc-lib/xxxx/xxxx/cc1/usr/lib/gcc-lib/xxxx/xxxx/cpp/usr/lib/gcc-lib/xxxx/xxxx/include/*.h/usr/lib/gcc-lib/xxxx/xxxx/libgcc.a/usr/lib/gcc-lib/xxxx/xxxx/specs폴더안을 살펴보면 이러한 구조로 되어있는데, cc1이 C compiler의 본체라고 한다.  C++ compiler는 cc1plus, Objective C compiler는 cc1obj아무것도 안해보고 구조를 보면 봐도 뭔지 모를텐데, (사실 지금도 모른다.) gcc는 C랑 C++ 코드를 구분하고 Link 작업도 하고, 소스를 만들고 하는 선행되어야하는 것들을 해주는 녀석이다.gcc 사용하기역시 시작은 Hello, World.인가보다.// hello.c#include &lt;stdio.h&gt;intmain ( void ){  printf("Hello, World.");  return 0;}$ gcc hello.c 이렇게 입력하고, 아무 메세지도 안나오면 성공이다. 대신, 해당 폴더에 hello라는 파일 하나가 만들어져 있을 것이다. 아래와 같이 입력하면 터미널에 Hello, World가 출력될 것이다.$ ./hello-o 옵션gcc에는 여러가지 옵션들이 많이 있다. -o옵션은 Output 파일명을 정하는 옵션이다.$ gcc -o &lt;원하는 파일명&gt; &lt;코드 파일명&gt;$ gcc &lt;코드 파일명&gt; -o &lt;원하는 파일명&gt;위에 처럼 해주면 내가 지정한 파일명으로 실행파일이 만들어 질 것이다. (위 두개 방법중 선택하면 된다.)-c  옵션오로지 Compile 작업만 하고 싶은 경우에 사용한다.$ gcc -c hello.c이때 만들어지는 파일은 .o확장자가 붙어서 Object file, 즉 목적파일 이라고 부른다. (hello.o) 나중에 코드가 많아지고 복잡해지면, 여러개로 나누어서 모듈화를 잘해서 프로그램을 만들게 되는데, 이때 이 많은 코드들 중에서 하나에서만 main 함수를 가져야한다.$ gcc -o baz foo.c bar.c$ gcc -c foo.c &amp; gcc -c bar.c$ gcc -c foo.c bar.c$ gcc -o baz foo.o bar.o위와 같이 여러가지 방식으로 만들 수 있다. 여기서 잠깐 .o파일이 무엇인지 집고 넘어가자. C언어가 실행파일을 만들어내는 과정을 생각해보면, .c파일을 .o파일로 만들고, .o파일을 실행파일로 만든다.  이때, .c파일이 .o파일로 만드는 과정이 Compile 과정이고, .o파일을 실행파일로 만드는 과정을 Link라고 한다. 이때 Compile 과정은 gcc에서 cc1이 담당하는 일이고, Link 과정은 ld라는 Linker가 담당한다. 즉! gcc란 Compiler와 Linker를 관리하는 외부업체라고 보면 될 것 같다.-l 옵션#include 문장에서 지정한 Header file이 들어있는 곳을 정하는 옵션이다. (보기만 해도 중요하고 자주 사용하게 될 것 같다.)  &lt;&gt;를 쓴 경우는 시스템표준 헤더가 있는 곳을 기준으로 파일을 찾는다. ""를 쓰는 경우는 현재 디렉토리를 기준으로 Header file을 찾는다. 예를 들어 살펴보자.$ gcc -c myprog1.c -I..$ gcc -c myprog1.c -Iinclude  위에꺼는 헤더파일이 (..), 즉 하위폴더에 있다는 의미  아래꺼는 include라는 폴더에 있다는 의미여러번 쓸 수 있고, 순서대로 Header file을 찾는다고 한다. 주의해야 할 것은 폴더명은 -l다음에 띄어쓰기를 하지 않고 바로 써줘야 한다.-l 옵션과 -L 옵션라이브러리가 뭔지 집고 넘어가자. 지금까지는 그냥 단순하게 함수 창고라고 생각하고 구성이 어떤지는 생각안해봤으니까 이번에 해봐야지. Library file의 확장자는 .a이다. Archive라는 의미일 것으로 추측된다. 이런 Library file은 .o확장자를 가진 Object file들을 모아서 관리하는 도서관이라고 할 수 있다. 단순히 모아논게 아니라 체계적으로 정리를 해놨기 때문이다. 프로그래밍에 있어서 뭔가 정리가 되어있고, 순서가 있다면 빠짐없이 나오는 index를 이용해서 정리되어있다. 어떤 Library file이 있다면, 그 안에 어떤 Object file들이 있는지 아래의 명령어로 알 수가 있다.$ ar t libc.a이제는 Library file을 만드는 방법을 마찬가지로 예시를 들어서 이해해보자. 그전에 다시한번 좋은 글을 써주신 이 글 저자분께 감사합니다.// myfunc.hextern void say_hello ( void );// myfunc.c#include &lt;stdio.h&gt;#include "myfunc.h"void say_hello ( void ){  printf ( "Hello, Linux guys!\n" );}// hello.c#include "myfunc.h"intmain ( void ){  say_hello ();  return 0;}$ gcc -c myfunc.c$ ar r libmylib.a myfunc.o // r옵션: 새로운 object file이면 추가, 있던거면 치환$ ar s libmylib.a // Archive index를 생성$ ar t libmylib.a // Archive에 있는 file list를 출력myfunc.o$ gcc -o say_linux hello.c -lmylib일단 이렇게하면 실패한다. 아래서 어떻게해야 할지 방법을 찾아보자. ar 명령어 관련 내용은 여기-l 옵션이 녀석은 위에서는 Header file 경로를 나타내는 용도로 사용했었는데, Link할 Library를 명시해주는 용도로도 쓰인다. 마찬가지로 띄어쓰기 없이 바짝 붙여서 사용한다. 위에서 우리가 libmylib.a라는 파일을 만들어놨는데, -l 옵션하고 같이 사용할 때는 보면 -lmylib처럼 lib와 .a를 떼고 명시해준다.-L 옵션-L과 -l의 다른점을 보면, -l은 Link할 라이브러리를 명시하는 거라면, -L은 라이브러리의 위치를 정해주는 옵션이다. Linker에게 라이브러리 위치를 알려주는 역할을 한다.$ gcc -o say_linux hello.c -lmylib -L.&lt;디렉토리 경로&gt;$ gcc -o say_linux hello.c -lmylib -L. // 현재 디렉토리에서 찾아라이렇게 두 옵션을 사용하면 성공적으로 컴파일 될 것이다.3. Make위에서 gcc를 이용해서 소스코드를 컴파일하고, Link하고, 실행파일로 만드는 법을 알아봤다. 하지만 프로젝트가 커지게되면 소스코드를 엄청나게 많아지게 되는데, 이럴때마다 gcc로 노가다 뛰는 것은 별로 하고싶지 않을 것이다. 그래서 이런 과정을 효율적으로 관리하기 위해 Makefile이라는 형식을 사용한다. Opencv install 할 때도 그렇고, Darknet setup할 때도 그렇고, make명령을 사용했던 기억이 있는데, 이 명령이Makefile에서 내용을 읽어와서 Object file을 만들어내는 것 이다.하여튼 결국에 이 Makefile은 효율적이고 일관성있게 코드들을 관리하기 위해서 사용하는 만큼 그 안에 여러가지 규칙들이 있는데, 이런 규칙들을 잘 따라서 작성하는게 중요하다.역시 또 예시를 들어서 Makefile을 어떻게 만들어야 하는지 알아보자. (아래 명령어들은 Terminal에서의 make 명령어 종류들이다.)$ make config           /* 설정 작업을 한다 */$ make dep              /* 화일 의존성을 검사한다 */$ make clean            /* 만든 화일들을 지우고 깨긋한 상태로 만든다 */$ make zImage           /* zImage(압축커널)를 만든다 */$ make zlilo            /* 커널을 만들고 LILO를 설정한다 */$ make bzImage          /* bzImage(비대압축커널)를 만든다 */$ make modules          /* 커널 모듈을 만든다 */$ make modules_install  /* 커널 모듈을 인스톨한다 */$ make$ make all$ make installMakefile 작성$ gcc -o foo foo.c bar.c이 명령어를 치면 무슨 일이 일어나는지 이제는 안다. foo.c랑 bar.c로 foo라는 Object file을 만드는 것 이다. 이걸 이제 Makefile로 옮겨 작성해보자.목표:	   목표를 만드는데 필요한 것들		목표를 달성하기 위한 명령 1		목표를 달성하기 위한 명령 2=================================foo:	foo.o bar.o		gcc -o foo foo.o bar.ofoo.o:	foo.c		gcc -c foo.cbar.o: 	bar.c		gcc -c bar.c이런 규칙에 따라서 작성을 해야하고, 실수가 있으면 안된다.  각 요소 구분은 콤마가 아니라 띄어쓰기로 한다.  다음 줄로 넘어가서는 키를 눌러야한다. (스페이스나 다른 키는 사용하면 안된다.)          명령에 해당하는 줄은 키로 시작해야한다. 매우 중요!      근데 순서를 보면 신기하게도 역순으로 진행되는 꼴이라는 걸 알 수 있다.  Makefile에서는 사실 이미 있는걸 다시 만들 필요가 없는 구조로 작동하는 것이다. (변화가 있는 파일은 똑똑하게도 Makefile이 알아서 갱신한다.)// 첫번째 make 명령어$ makegcc -c foo.cgcc -c bar.cgcc -o foo foo.o bar.o// foo.c를 고치고 다시 make 명령어$ makegcc -c foo.cgcc -o foo foo.o bar.ofoo를 만들기 위해서는 foo.o, bar.o가 필요한데, 그럼 foo.o는 foo.c를 가지고 gcc -c foo.c를 해야하고, bar.o는 bar.c를 가지고 gcc -c bar.c를 해야하고 이런식으로 되는 것이다.make clean만약 깔끔하게 코드빼고 다 지우고 싶다면 make clean명령을 사용하면 된다. 그리고 이게 정상적으로 작동하기 위해서는 Makefile에 명령을 더 추가해줘야한다.clean:		rm-f foo foo.o bar.o추가해주고 Terminal에서 make clean명령을 해주면 다음과 같은 결과가 나온다.$ make cleanrm -f foo foo.o bar.o$ makegcc -c foo.cgcc -c bar.cgcc -o foo foo.o bar.omake allmake all 명령만 입력하면 깔끔하게 모든 파일 전부 컴파일하도록 만든다. 가장 맨 윗줄에 다음을 추가한다.all: foo$ make allgcc -c foo.cgcc -c bar.cgcc -o foo foo.o bar.o일반적으로 사람들이 이렇게 많이 하고, 직관적이니까 편의를 위해 이렇게 만들어주는 것도 고려하자.꼬리말 규칙, 패턴 규칙Makefile에 보면 다음과 같은 표현을 자주 볼 것 이다. (아직 안 뜯어봐서 잘 모르겠지만..).c.o:		gcc -c ${CFLAGS} $&lt;여기서 .c.o의 의미는 “.c를 입력 파일로 받고, .o파일로 만든다.”라는 의미를 가지고 있다. $&lt;는 redirection을 의미한다고 하는데, 뭔지는 잘 모르겠지만 .c.o 에서 .c부분을 의미하게 되는 것 이다.GNU make 확장 기능위에 꼬리말, 패턴 규칙보다 더 논리적인 확장 문법이다.%.o: %.c        gcc -c -o $@ ${CFLAGS} $&lt;:의 오른쪽이 입력파일(.c), 왼쪽이 Object file(.o)이 된다. 파일명 대신 %기호를 사용하는데, 예를들어 foo.c라는 입력파일이 들어오면 %가 foo를 나타내는 식으로 작동하게 된다.기호를 정리하면 다음과 같다.  (감사합니다. 링크) $&lt;     입력 화일을 의미합니다. 콜론의 오른쪽에 오는 패턴을 치환합니다. $@     출력 화일을 의미합니다. 콜론의 왼쪽에 오는 패턴을 치환합니다. $*     입력 화일에서 꼬리말(.c, .s 등)을 떼넨 화일명을 나타냅니다.Macro일단 Macro에 대해 간단하게 이야기하면, 변수화한다고 생각하면 될 것 같다. (상수화 일수도 있는데 조금 헷갈린다.) 예를 들면 다음과 같다.ROOT = /usr/localHEADERS = $(ROOT)/includeSOURCES = $(ROOT)/src그럼 앞에서 나온 ${CFLAGS}는 뭘 의미하고 있는걸까? 써있는 그대로 Flag와 비슷한거 같은데, 설정값이라고 보면 될 것 같다. Terminal에서 해당 설정값을 make할 때 넘겨주고 그것을 받아 처리하는 방식이라고 생각하고 넘어가자. (유닉스 쉘에서 {}은 변수값을 알아낼 때 쓰는 표현이라고 한다. 이것도 알고 넘어가자.)마무리일단 여기까지가  gcc와 Makefile에 대한 내용이었고, 다른 내용들도 훨씬 많다고 하니 필요할 경우 찾아보며 진행하면 될 것 같다. 본문에는 마지막 부분에 주의사항이 있으니 한번씩 읽어보고, 이정도면 일단은 될 것 같다.]]></content>
      <categories>
        
          <category> Installation </category>
        
      </categories>
      <tags>
        
          <tag> Installation </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Aran님의 유튜브 발음시리즈]]></title>
      <url>/english/2020/05/21/English_Conversation-post/</url>
      <content type="text"><![CDATA[Youtube Aran TV 발음시리즈매끄럽고 매력적인 말하기의 3가지 원칙언어란 문화 어휘 문법 발음으로 이루어져있다.소통을 하기위해선 발음이 중요하다.외국인들이 너의 언어를 잘 알아듣지 못하는 이유  발음자체가 문제  1음절 단어를 2음절로 발음  2음절에 강세가 있는 단어를 1음절에 강세를 주는 경우-&gt; 언어는 약속이고, 발음에는 정답이 있다. (복수정답이 있다.)존중해야하는건 억양이다.(Accent, 말투) 정답이 없다!발음과 억양을 바꾸려면 [듣기 - 연습 - 녹음 - 교정]외국인처럼 하려면 어떻게 해야할까?      문장에서 중요한 단어는 강조        붙어있는 단어는 연음        듣고 따라하기  절대로 외국어 소리를 모국어로 옮겨적어서 외우면 안된다.듣는 것 또한 굉장히 중요하다. 들리지않으면 발음할 수가 없다. 따라하고싶은 사람이 말하는 것을 듣고 따라해라. ex) Donald John Trump, Robert Anthony De Niro, Jeffrey Warren Daniels이것이 바로 쉐도잉 (shadowing)강약, 속도, 말투, 표정, 몸동작을 따라하면서 마치 자신이 그 사람이 된 것처럼 연습해라.제 1원칙 정확성 (Accuracy)  자음과 모음의 소리를 똑바로  발음을 끝까지  음절을 시켜서  강세를 살려서  장음은 장음답게자음과 모음의 소리를 똑바로한끗차이로 들릴 수 있지만, 영어 사용자에게는 아니다.      B vs V        P vs F        R vs L  B는 입술을 모았다가 퍼지는게핵심  손에 바람이 안느껴지도록V는 입술이 만나지 않는다.  윗니가 아랫니를 살짝 문다는 느낌으로R는 혀를 뒤로가서 입천장에 닿지않음  입술을 살짝 앞으로 내밀어봐L은 앞니를 딱 친다는 느낌th는 혀가 윗니아랫니 사이로 들어온다W는  워, 우어 이런소리Z는 모기가 윙윙거리는소리모음은 a,e,i,o,u,y이 있는데 발음하기 까다롭다. 한국어 모음발음에서 두가지정도가 섞인 발음이 나기 때문이다.끝까지 발음하자단어를 발음할때, 마지막 알파벳까지 전부 발음하도록Ethan, Mom, Singing, And, Back, Great, Technology등등음절을 지켜 발음하자  Changed은 1음절. Chan/ged 아니다.          1음절 예시: Chris, Sprite,      모음의 개수에 따라 음절이 나뉜다.강세를 살려서 발음하자강세가 없는 단어는 이 세상에 없다.      River는 첫음절에 강세    Hotel, Police, Olympic은 두번째 음절에 강세  Representative은 세번째 음절에 강세모르는 단어는 강세도 표시하면서 연습하기장음은 길게 발음하자장음이란 말그대로 긴 소리언제 길게 소리를 내야하냐면,  모음이 두개 이상일 때          두개인 만큼 더 길게      See, Keep, Sleeves, Peace, Soon, Cool        o 발음시 종종          o[ou] 처럼 살짝길게      Over, Phone, Cross      제 2원칙 유창성 Fluency술술 물흐르듯이 말하는 방법  자연스러운 연음  적절한 끊어읽기  적당한 속도자연스러운 연음글자와 글자, 단어와 단어, 문장과 문장을 이어서 말한다. 외워서하는게 아니라 그냥 자연스럽게 매끄럽게 하면된다.  Hityou withthat DDu-Du DDu-Du Du  Imonly one callaway적절히 끊어읽기적절하게 쉬어가면서 말하는게 더 유창하고 매력적이다. 의미별로, 구별로, 문장별로 끊어읽는다.적당한 속도연습해야된다. 아무리 문장구조가 좋아도 속도가 너무 느리면 유창하게 느껴지지 않는다. 새로운 문장을 왠만한 속도로 읽을 수 있도록 연습해야한다. 물흐르듯이 계속반복, 생각하지않고도 입이 먼저 움직일때까지 연습해라.제 3원칙 전달력 Delivery매력적인에 해당하는 부분이다.전달력의 두가지 핵심  중요한 말은 강조해서 말하기          성량의 변화      속도      어조의 변화      쉬는 박자의 변화      표정과 제스쳐의 변화        감정을 강조하자중요한 말을 강조하자  성량의 변화          중요한 단어에서 성량에 변화를 준다        속도          중요한 곳은 천천히 강조하면서 말하기        어조의 변화          말하고자 하는곳은 조금 더 올리거나 내려서 강조        쉬는 박자의 변화          강조할려고하는건 앞에서 한번 쉬고 말하기        표정과 제스쳐의 변화          난 못해      중요한지 아닌지는 품사가 결정하는게 아니라, 의미가 결정하는 것이다.I was in the second building.  나를 강조하려면 I에 강조  과거에 있던 일이라는 걸 강조하려면 was에 강조  Building 안에 있었다는 걸 강조하려면 in에 강조  등등등..감정을 강조하자감정을 담아서 진심으로 이야기해라. 내가 내 이야기를 해야 매력적이다. 청자가 꼭 들었으면 좋겠다는 생각으로 말해라.Donald John Trump 연설 중..Thank you Klaus very much. It’s a privilege to be here at this forum where leaders in business, science, art, diplomacy and world affairs have gathered for many many years to discuss how we can advance prosperity, security and peace. I’m here today to represent the interests of the american people and to affirm America’s friendship and partnership in building a better world, like all nations represented at this great forum.[Vocabulary] 1. Privilege : a special advantage that is given only to one person or group of people 2. Diplomacy : The job or activity of managing the relationships between countries 3. Affirm : to strengthen a feeling, belief, or idea]]></content>
      <categories>
        
          <category> English </category>
        
      </categories>
      <tags>
        
          <tag> English </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[OS Lecture 6]]></title>
      <url>/os/2020/04/28/OS6-post/</url>
      <content type="text"><![CDATA[유튜브 HPC Lab. KOREATECH 채널, 김덕수 교수님의 OS 강의를 보고 정리한 내용입니다.Lecture 6Process Synchronization다중 프로그래밍 시스템 환경 (Multi-Programming)  Process가 여러개이다.  Process들은 서로 독립적으로, 동시에 동작한다.  공유 자원 또는 데이터가 있을 때, 문제가 발생한다.다중프로그램 시스템 환경에서 Error가 발생하지 않으려면 프로세스끼리의 ‘대화’ 또는 ‘협약’이 필요하다.-&gt; 동기화가 필요하다.Synchronization (동기화)  프로세스들이 서로 동작을 맞추는 것  프로세스들이 서로 정보를 공유하는 것Asynchronous and Concurrent P’sAsynchronous (비동기화)  프로세스들이 서로 대화를 안하고 개인행동하는 경우Concurrent (병행)  여러 프로세스들이 동시에 동작하는 경우‘병행’ 수행중인 ‘비동기적’인 프로세스들이 공유 자원에 동시에 접근하면 문제 발생-&gt; 프로세스간의 대화없이 같은 공간에 작업하게 되면 문제가 발생한다. (위에서 말했던 에러가 발생하는 원인)Terminologies  Shared data (공유 데이터)          여러 프로세스들이 공유하는 데이터        Critical section (CS, 임계 영역)          Shared data를 접근하는 코드 영역        Mutual exclusion (상호배제)          둘 이상의 프로세스가 동시에 CS에 진입하지 못하도록 막는 것      Critical Section사용자가 작성한 Code는 Compiler에 의해 Machine instruction (기계어 명령)로 바뀐다.  Machine Instructions are commands or programs written in machine code of a machine (computer) that it can recognize and execute.      Atomicity : 쪼갤 수 없다. 중간에 방해할 수 없다.        Individible : 분리가 불가능하다    -&gt; 명령 실행 도중에 Interrupt를 받지 않는것이 보장된다. (Non-preemption)  예를 들어, 2개의 Process가 shared data에 동시에 1을 더하려고 할 때, 결과는 기계어 명령 수행 과정에 따라서 1또는 2로 달라질 수 있다.-&gt; 이런 상태를 Race condition이라고 한다. (동시에 접근할 때 자료의 일관성을 해치는 결과가 나타날 수 있다.)Mutual Exclusion (상호배제): 한 Process가 Critical section에 대해서 실행되는 동안, 다른 Process가 못들어오게 막는 것이다. (항상 원하는 결과를 도출하기 위해 지켜져야하는 규칙 중 하나!)Mutual Exclusion Methods  Mutual exclusion primitives          enterCS() primitive                  Critical section 진입 전 검사 (안에 다른 Process가 있는지 검사한다.)                    exitCS( primitive)                  Critical section을 벗어났음을 시스템에 알린다. (후처리 과정)                    primitives란 보통 가장 기본이 되는 연산을 의미한다. 위 연산들을 구현해야하는데, 조건이 있다.Requirements for ME primitives구현을 할 때, 만족해야할 조건 3가지가 있다.  Mutual exclusion (상호배제)          CS에 있으면 못들어오게 한다.        Progress (진행)          CS에 아무도 없으면 들어갈 수 있도록 해야된다. (방해하면 안된다.)        Bounded waiting (한정대기)          제한시간 내에 CS로 들어갈 수 있어야 된다.      SW SolutionsTwo Process Mutual Exclusion첫번째 시도: Turn을 사용해서 구현한다. (유희왕, 하스스톤같은 게임의 Turn하고 똑같음)  Process A, Process B가 있다.  Turn이 0이면  A의 차례, Turn이 1이면 B의 차례다.  자신의 차례가 오면 일을하고, 나올때 상대에게 차례를 넘겨준다.위와 같은 순서로 진행된다.조건을 만족하는지 체크해보면, Progress의 조건을 만족하지 못한다.  Process A가 뻉뻉돌다가 죽어버리면 Turn을 넘겨받지 못해서 CS가 비었음에도 들어가지 못하게 된다.          상대에게 차례를 넘겨주지 못할 때        한 Process가 두 번 연속 CS에 진입 불가하다. (다른 프로세스에게 Turn을 넘겨받아야만 하기 때문이다.)아쉽게도 조건을 위배한다.두번째 시도: Flag를 사용하여 구현한다.CS에 들어갈꺼면 깃발을 들고, 나왔으면 깃발을 내린다.  2개의 Process가 있다.  상대편의 깃발을 본다          들려있으면? -&gt; 기다린다.      내려가있으면? -&gt; 들어간다.        내 일이 끝나면 깃발을 내리고 나온다.  상대편이 내려간 내 깃발을 보고 들어온다.위와 같은 순서로 진행된다.조건을 만족하는지 체크해보면, 내 깃발은 내려가 있는 상태고, 상대 깃발이 내려가 있는걸 보고 깃발을 들려고 하는데 Preemption된 경우에  상대가 와서 내 깃발이 내려가있는걸 보고 먼저 CS로 들어간다.  나는 다시 자원할당받아서 하려던거 마저 하기위해 CS로 들어간다.-&gt; Mutual exclusion 조건에 위배한다.상대 깃발을 체크하고, CS에 들어가기 직전에 깃발을 들어서 문제가 된다.여기서 착각하면 안되는 것은, 위에서 Machine instruction이 Atomicity한 특성을 가지고 있고, 중간에 Preemption이 일어날 수 없다고 했는데, Code의 줄 사이사이에서 Preemption이 일어난다. 예를들어,a = 3;// Preemption 발생b = 4;이런 Code가 있다고 했을 때, a=3을 수행하고, b=4를 수행하려는데 Preemption이 발생할 수도 있다는 것이다.세번째 시도: 두번째와 비슷한데 순서가 다르다. 이번에는 들어갈거라고 먼저 깃발을 든다. (깃발을 먼저 들고, 상대를 체크하는 순서로 바뀌었다.)Progress, Bounded waiting 조건을 위반한다.  2개의 프로세스가 동시에 왔다가 서로 깃발을 올린것을 보고 아무도 안들어갈 수도 있다.Mutual Exclusion SolutionsDekker’s Algorithm  Process가 2개일 때, Mutual exclusion을 보장하는 최초의 알고리즘이다.  Flag와 Turn을 동시에 쓴다.순서  2개의 Process가 있다.  Process 하나가 깃발을 든다.          상대가 깃발을 안 들고 있다면 바로 CS로 들어간다.      상대가 깃발을 들었다면 Turn을 체크한다.        Turn을 체크한 다음 내 Turn이 아니면 깃발을 내리고 Turn이 돌아오기를 기다린다.  일을 하고나서 CS에서 빠져나오면서 Turn을 넘긴다.  나머지 Process가 들어가서 일한다.앞선 시도와 다른점은 상대가 깃발을 안 들고 있었음에도 불구하고 못들어가는 문제가 있었었는데, 상대가 깃발을 안 들고 있다면 바로 CS로 들어가게 함으로써 이 문제를 해결했다.Peterson’s Algorithm: Dekker의 알고리즘을 간단하게 만든 것이다.순서  2개의 Process가 있다.  Process 하나가 깃발을 들고, Turn을 양보한다.  상대가 깃발을 들고있고, 상대방 Turn이면 기다린다.Turn을 넘겨주는게 아니라, 양보한다는 것이 Dekker’s algorithm과 다른점이다.N-Process Mutual Exclusion SolutionsProcess가 여러개 있을 때의 Mutual Exclusion를 만족하기위한 해결책들Dijkstra Algorithm (다익스트라 알고리즘)대단한 분이라서 이분 이름을 딴 알고리즘이 많다.지금은 Mutual exclusion에 대한 다익스트라 알고리즘을 다룬다.  마찬가지로 Turn과 Flag를 사용하는데, Flag의 state가 3개          idle (CS 진입을 시도하고 있지 않는 단계)      want-in (CS 진입을 하고 싶은 의사를 밝히는 단계)      in-CS (CS 진입을 하기 직전의 단계)      want-in(1단계)과 in-CS(2단계)를 둘다 통과해야 CS에 들어갈 수 있다.Want-in 단계 과정  $P_i$가 CS에 들어가고 싶다고 말한다. (flag state를 want-in으로)  자기 Turn이 아니면 상대의 State가 idle이 될 때까지 체크하면서 기다린다.  상대의 일이 끝나는 순간 Turn을 자기껄로 뺏어오고, in-CS State로 진입한다.          이 과정에서 여러 Process들이 Turn가지고 싸운다. 뺏고 뺏기고 난리치면서 여러개의 Process가  2단계로 진입      In-CS 단계 과정      flag state를 in-CS로 바뀐다.        j라는 반복를 위한 변수을 사용하여 while문을 돌린다.                  Case 1. j &lt; n(Process의 수) - 1                  반복문이 끝까지 다 돌았을 때                    Case 2. (j == i) or (flag[j] != in-CS)                  j가 i 가 아니고, flag[j] 가 in-CS state일 경우                    in-CS state인 Process가 나보다 먼저 있음        Case 2의 경우에는 다시 처음으로 돌아간다. Case 1의 경우에는 CS로 $P_i$가 들어간다.  여기까지가 Softeware적으로 Mutual Exclusion을 구현하기위한 방법이었다. 단점은 다음과 같다.  속도가 느리다.  구현이 복잡하다.  Code 실행 중간에 Preemption 될 수 있다.          OS가 도와줘서 interrupt를 막을 수 있지만 overhead가 발생한다.        아무것도 안하면서 기다리는게 아니라 뺑뺑돌면서 기다린다. (Busy waiting)          Busy waiting은 비효율적이다.      HW solutionSW solution을 썻는데 비효율적이었다. 그래서 Hardware적 차원에서 도움을 받아 새로운 Solution을 만들었다.TestAndSet (TAS) instruction  Test와 Set을 한번에 수행하는 “기계어” -&gt; 수행중에 interrupt를 받지 않는것이 보장된다.  Busy waiting앞에서 Machine instruction은 atomicity하고 individible이었지만,코드의 줄 사이에서 개입이 일어날 수 있다고 했다.여기서 TestAndSet instruction은 여러줄의 Machine instruction을 묶어서 한번에 수행하도록 만든 것 같은 느낌..boolean TestAndSet(boolean *target){	boolean temp = *target; // target에 temp 기록	*target = true; // 포인터로 temp를 true로 설정	return temp; // return true}여러줄의 Machine instructions가 한번에 수행되도록 만들어놨기 때문에, 중간에 Interrupt가 없어서, Mutual Exclusion이 간단하게 구현되었다.ME with TAS instructionMutual exclusion은 쉽게 해결을 했지만, 프로세스가 3개 이상이 될 경우 Bounded waiting 조건을 위배한다.  프로세스 여러개가 있다. {1,2,3,…}  1번이 CS에 들어가서 일을 하고 있고, 2번3번은 뺑뺑 돌고있다.  1번이 일을 다 마치고 나간다.  3번이 먼저 들어와서 일하는 도중에 4번이 들어와서 2번과 같이 뺑뺑 돈다.  3번이 끝나고 나갔는데 4번이 먼저 들어가서 일을 한다.  위처럼 운이 나쁘면 못들어가서 Bounded waiting조건을 위배하게 된다.그래도 의미있는건 TAS라는 구조로 Mutual exclusion이 쉽게 해결되었다는것 이다.그렇다면 3개 이상의 Process가 있는 환경에서 모든 조건을 부합하려면 어떻게 해야할까?-&gt; waiting이라는 새로운 변수를 사용한다.      기다려야하면 True, 기다리지 않아도 되면 False        내가 CS에서 일을 마치고 나오면 while문으로 내 뒤에 대기중인 프로세스를 찾는다.  // Process i 의 진입 영역do{	waiting[i] = true;    key = true;    while(waiting[i] &amp;&amp; key)        key = TestAndSet(&amp;lock);    waiting[i] = false;    // Critical section    j = (i + 1) % n;    while((j != i) &amp;&amp; !waiting[j]) // 대기중인 프로세스를 찾는다.        j = (j + 1) % n;		   // i 뒤로 순서대로 검사    if(j=i) 					   // 대기중인 프로세스가 없을 때, j는 i와 같을 것이다.        lock = false;    else        waiting[j] = false;}while(true);  장점          구현이 간단하다.        단점          Busy waiting                  TAS안에서 뺑뺑 돌고있어야 한다는 문제가 있다. (여기서도 역시나 Busy waiting 문제)                    OS supported SW solution이번에는 OS의 도움을 받아 Mutual Exclusion을 구현하는 방법을 살펴보자.Spinlock  정수형 변수 S를 사용한다.  S에는 초기화, P(), V() operation으로만 접근이 가능하다.          위 연산들은 Atomicity한 특성을 가지고 있음                  OS가 이 연산들의 Atomicity를 보장한다.          TAS처럼 여러 Machine instructions가 한번에 수행된다.                    각각 네덜란드어로 Proberen(시도), Verhogen(증가)의 의미를 가지고 있다.      // P()는 물건의 개수 or 자물쇠를 거는 것P(S){    // 물건이 없다면, 물건이 생기기를 while문 안에서 기다린다.    while(S&lt;=0)do     endwhile;    // 물건이 있어서 while문을 빠져나왔다면, 물건을 하나 가져간다. -&gt; S-1    S &lt;- S-1;}// V()는 물건을 집어넣는 것 or 자물쇠를 푸는 것V(S){    // 물건을 집어넣는다 -&gt; S+1    S &lt;- S+1;}OS가 서포트해주는 Spinlock이라는 Operation으로 Mutual exclusion이 간단하게 구현된다.  CS에 들어갈 때 P()로 문을 잠근다.  CS에 V()로 문을 열어두고 나온다.P()와 V()는 Atomicity가 보장되기 때문에,중간에 Preemption되지 않아서, 동시에 들어가거나 아무도 못들어가는 문제는 발생하지 않는다.-&gt; OS가 도와주니까 쉽게 구현할 수 있다.Spinlock의 문제점      Multi-processor 환경에서만 가능하다.    ex)          CPU가 하나일 때, Pi가 CS에 들어와서 일을 한다. S는 1에서 0이 되었다.      Pi가 CS에서 멈췄다.      PJ가 CPU를 할당받았지만, Pi가 V() operation을 수행하지 못해서 Pj는 P()에서 계속 뻉뻉 돌아야한다.      결국 Pi와 Pj 둘 다 일을 못하게 된다.        -&gt; CPU가 여러개가 있어야 Pi와 Pj가 동시에 돌아가야 Logic이 성립한다.        여전히 Busy waiting 문제가 있다.  Semaphore1965년에 Dijkstra가 제안 (이분 또 나오시네)  이번에도 S를 사용하는데, S는 이번에는 음이 아닌 정수형 변수!  임의의 S변수 하나에 Ready queue하나가 할당 된다.          이게 어떤 역할을 할지 중점적으로 보자.      두가지 종류의 Semaphore가 있다.  Binary Semaphore          S가 0또는 1, 두 종류의 값만 갖는다.      Mutual exclusion문제에 사용한다.        Counting Semaphore          S가 0이상의 정수값을 갖는다.      Producer-Consumer문제 등을 해결하기 위해 사용한다.(?)      Spinlock과 무엇이 다를지 코드와 함께 살펴보자.P(S){	if(S&gt;0)		then S &lt;- S-1;         //여기서 queue가 대기실 역할을 한다. Busy waiting 문제해결	else wait on the queue Q_s; }V(S){    //Queue안에 대기하는 Process가 있으면    if(Q_s)        then wakeup one of them;    else S &lt;- S+1;}Spinlock과 다른점은 Busy waiting문제가 없다는점! 각각의 S 하나마다 대기실(Ready queue)를 할당했기 때문이다.이런식으로 여러 Synchronization문제를 해결할 수 있다.Process Synchronization with SemaphoreProcess들의 실행순서를 맞출 수 있다. P()와 V()를 이용해서 프로세스간의 순서를 결정한다.Producer-Consumer Problem with Semaphore  Producer는 Data를 생산해내는 녀석들 (Buffer에 쌓아둠)          프린터 드라이버      컴파일러      어셈블러        Consumer들은 이 Data를 가져다가 쓰는 녀석들Producer가 생산해내는 Data는 Buffer에 저장된다. 여러개의 Producer와 Consumer가 있기때문에 Buffer에 접근하는것에 대해서 동기화가 필요하다.ex) Single bufer에서의 Producer-Consumer ProblemBuffer에는 한번에 한 녀석만 접근해야된다. 2개의 Semaphore 변수를 선언해서 사용한다.  Consumed (소비되었니?)  Produced (생산되었니?)Producer 입장에서  생산자가 Buffer에 Data를 넣을때 Buffer가 비었는지(소비되었는지) 체크 (Semaphore &lt;- 0)          비었으면 생산하고 Produce했다고 표시한다. (Semaphore &lt;- 1)      비어있지 않으면 대기실에서 기다린다.      Consumer 입장에서  Buffer에 물건이 있는지(생산되었는지) 체크 (Semaphore &lt;- 1)          비었으면 대기실에서 기다린다. (생산이 되면 Producer가 깨워줌)      비어있지 않으면 들어가서 Data를 사용한다.      ex) N개의 buffer에서의 Producer-Consumer Problem에서,생산자도 여러명이고 소비자도 여러명, Buffer도 여러개일때는?이중으로 P()와 V()를 사용  겉부분의 P()와 V()          mutexP : 다른 Producer가 있는지 확인하기 위한 변수      mutexC : 다른 Consumer가 있는지 확인하기 위한 변수        안부분의 P()와 V()          nrfull : Consumer입장에서 buffer가 얼만큼 차있는지 확인하기 위한 변수      nrempty : Producer입장에서 buffer에 자리가 얼마만큼 있는지 확인하기 위한 변수      Reader-Writer Problem with Semaphore  Reader는 데이터에 대해 읽기 연산만 수행  Writer는 데이터에 대해 갱신 연산을 수행Read같은 경우 동시에 같은 데이터에 접근해도 문제가 없다. 하지만 Write는 별다른 Synchronization없이 여러명이서 쓰면 난리가 난다. 그러므로 Data의 Consistency 보장이 필요하다.  해결법      Reader/Writer에 대한 우선권을 부여한다.    Reader가 우선권을 가지는 경우          3가지 변수를 사용                  wmutex : 다른 Writer가 있는지 확인하기 위한 변수          rmutex : 다른 Reader가 있는지 확인하기 위한 변수          nreaders : Reader의 수를 표현하기 위한 변수                    Reader가 없을때 Read하기 위해 들어갈때는 Writer가 못들어오도록 막고 시작한다.      Read를 마치고 나가려고할때, 마지막 Reader라면 Wrtier가 들어올 수 있도록 한다.        Writer가 우선권을 가지는 경우Semaphore의 효과  No busy waiting          대기실을 만들어서 해결했다. (각 S변수 하나마다 Ready queue가 할당되었었다.)        Semaphore queue에 대한 wake-up순서는 비결정적이다.          Starvation problem이 있다.      Eventcount / Sequencer은행업무와 비교해서 생각하면 쉬운 개념!  Sequencer          정수형 변수      생성시 0으로 초기화하고 감소하지 않는다.      순서를 유지하고 ticket() operation으로만 접근 가능        ticket(S)          현재까지 ticket() Operation이 호출 된 횟수 반환 (번호표)      Indivisible Operation      0에서 시작해서 번호표를 뽑을 때마다 번호가 계속 +1씩 증가한다.        Eventcount          정수형 변수      생성시 0으로 초기화하고 감소하지 않는다.      특정사건의 발생 횟수를 기록 (은행으로 치면 지금까지 업무처리가 끝난 번호까지)      read(E), advance(E), await(E,v) operation으로만 접근 가능                  read는 현재 번호가 몇번인지 보고있는 것          advance는 은행원이 다음번호로 넘기는 행위 (기다리고있는 프로세스를 깨운다.)          await(E,v)에서 v는 번호표, E는 현재 번호 -&gt; 내 번호가 더 크면 대기실에서 기다린다.                    순서  Process가 와서 번호표를 뽑는다. (ticket(S))  내 차례가 올때까지 대기실에서 기다린다 (await(E,v))  일을 끝내고 기다리고 있는 다른 Process를 깨운다 (advance(E))위와같은 순서로 진행된다.이 방법으로 Producer-Consumer Problem을 풀어보자. (강의에서 확인하자)Language-Level Solution여전히 구현이 어렵고, 에러가 생길 가능성이 높다. 그래서 이번에는 Programming language수준에서 Mutual exclusion 문제를 해결해보자!High-Level Mechanism프로그래밍언어가 Mutual exclusion을 Support하자!  사용이 쉽다.  Object-Oriented concept과 유사하다.앞에서 했던 방법들(Low-level mechanisms)은 Flexible했지만, 많이 복잡했고, 쓰기도 힘들었다.  Error 발생 확률이 높았다.그러니까 우리가 쓰는 High level의 Program language로 쉽게 Solution을 만들보자! Monitor, Path expression, Serializers등등 여러가지가 있지만 Monitor만 살펴보도록 하자.Monitor책방에 대입해서 생각해보자.Critical Data와 Critical Section을 모아논 하나의 방이라고 생각하면된다. (한번에 한명만 들어올 수 있는 책방)  Critical data: 내가 빌리고싶은 책  Critical section: 내가 대출하거나 반납하기위해서 들리는 카운터이 외에도 Conditional variable과 wait(), signal() operation들이 존재한다.Monitor의 구조  Entry queue (진입큐)          한번에 하나만 들어가도록하는 queue      Function마다 하나씩 존재        Mutual exclusion          Monitor내에는 항상 하나의 Process만 진입가능 (Programming language로 보장)        Information hiding (정보 은폐)          Ciritical data에는 모니터 내의 프로세스만 접근가능        Condition queue (조건 큐)          모니터 내의 특정 이벤트를 기다리는 프로세스들의 대기실        Signaler queue (신호제공자 큐)          모니터에는 항상 하나의 신호제공자 큐가 존재      전화부스라고 생각하면 된다.      signal을 보내기위해 잠깐 들어가는 공간      자원할당이라는 문제로 동작을 살펴보자. (자원을 책이라고 가정한다.)  책을 요청하는 function과, 책을 반납하는 function이 존재한다.          release and request      각각의 Function은 Entry queue를 가지게 된다.        Conditon queue이라는 대기실이 존재한다.  대기실의 Process를 깨우는 공간인 Signaler queue가 존재한다.//기존의 방식과는 다르게 생각한대로 짜면됨procedure requestR();begin    if(~R_Available)then        R_Free.wait(); //책이 없으면 기다려라    R_Available &lt;- false;end;procedure releaseR();begin    R_Available &lt;- true; //반납했으니까 true로 바꾼다.	R_Free.signal(); //Condition queue에 기다렸던놈 나와라.end;이런식으로 그냥 생각하는대로 쉽게 짤 수가 있다. 여기서 주의해서 생각해야할 것은  Monitor에는 한번에 한명만 들어갈 수 있다.  Release와 Request가 각각 나뉘어져있어서 Release를 마치고 signaler queue에서 Condition queue에서 기다리고있는 사람을 불렀을 때, Monitor에는 한명만 들어갈 수있기 때문에, Monitor에서 나와야한다.  위의 코드는 간단하게 짠거라서 없지만, release의 경우 자원을 반납하고나서, 마무리 작업이 남아있기 때문에 Condition queue안의 대기하고 있는 사람을 부르고나서 signaler queue에 들어가있다가 다시 Monitor로 들어가서 남은일을 하고 나온다.Procuder-Consumer Problem with Monitor이번에는 Producer-Consumer Problem을 Monitor로 해결해보자.Variables  ValidBufs: 물건의 개수  in, out: Data가 들어갈 공간Procedure  fillBuf(): Producer가 사용할 Procedure  emptyBuf(): Consumer가 사용할 ProcedureCondition queue  bufHasData: Buffer에 ‘데이터’가 있는지 (Consumer가 기다리는 공간)  bufHasSpace: Buffer에 ‘공간’이 있는지 (Producer가 기다리는 공간)위와 같은 구성으로, 코드를 작성해보면//Producerprocedure fillBuff();begin    //물건의 수가 N이다? -&gt; 꽉찼다. 그러니까 기다려라    if (validBufs=N)then bufHasSpace.wait();	buffer[in] &lt;- data;	validBufs &lt;- validBufs + 1;	in &lt;- (in + 1) mod N;	bufHasData.signal(); //물건을 기다리는 Consumer가 있으면 깨운다.end;//Consumerprocedure emptyBuf():begin    //물건의 수가 0이다? -&gt; 데이터가 없다. 그러니까 기다려라    if (validBufs=0)then bufHasData.wait();	data &lt;- buffer[out];	validBuf &lt;- validBuf -1;	out &lt;- (out + 1) mod N;	bufHasSpace.signal(); //공간을 기다리는 Producer가 있으면 깨운다.end;Reader-Writer Problem with Monitorread같은 경우는 한번에 여러명이 할 수 있었지만, write같은 경우는 한번에 여러명이 할 경우 큰일난다고 위에서 말했었다. 위에서만 Semaphore를 이용해서 했었지만, 이번에는 Monitor를 이용해서 좀더 간단하게 만들어보자.Variables  nReader: Reader의 수  writing: writer의 존재유무Procedure  beginRead: Reader가 사용할 Procedure  finishRead: Reader가 사용할 Procedure2  beginWrite: Writer가 사용할 Procedure  finishWrite: Writer가 사용할 Procedure2Condition queue  waitWrite: Writer가 기다리는 공간  waitRead: Writer가 이미 Monitor내에 있을 경우 Reader가 기다리는 공간procedure beginReading();begin    if (writing or queue(waitWrite))then waitRead.wait();	nReader &lt;- nReader + 1;	if (queue(waitRead))then waitRead.signal();end;procedure finishReading():begin    nReader &lt;- nReader - 1;	if(nReader=0)then waitWrite.signal();end;procedure beginWriting():begin    if (writing or nReader&gt;0)then waitWrite.wait();	writing &lt;- true;end;procedure finishWriting();begin    writing &lt;- false;	if (queue(waitRead))then waitRead.signal();	else waitWrite.signal();end;이런식으로 짜면 된다. (솔직히 procedure 4개 나올줄은 몰랐습니다.)Dining Philosopher Problem with Monitor이번에는 Dining philosopher problem  5명의 철학자  하는일은 생각하는일, 스파게티 먹는일을 반복함  공유자원: 스파게티 포크  스파게티를 먹기위해서는 좌우 포크2개를 모두 들어야한다.Variables  numForks[0~4]: 철학자들이 쓸 수 있는 포크의 개수Procedure  pickUp: 스파게티를 먹을 사람이 포크를 드는 것  putDown: 생각하는 사람이 포크를 내려놓는 것Condition queue  room[0~4]: 철학자들의 방 5개procedure pickUp(me);begin    if (numForks&lt;2)then room[me].wait();	//내 양쪽사람이 쓸수 있는 포크는 1개씩 줄어든다.	numForks[me-1] &lt;- numForks[me-1] - 1;	numForks[me+1] &lt;- numForks[me+1] - 1;end;procedure putDown(me);begin    numForks[me-1] &lt;- numForks[me-1] + 1    numForks[me+1] &lt;- numForks[me+1] + 1    if (numForks[me+1]=2)then room[me+1].signal();	if (numForks[me-1]=2)then room[me-1].signal();end;    Reader-Writer Problem이랑 비슷하게 풀릴 줄 알고 Procedure를 처음에 4개를 준비했었었는데, 필요 없었습니다ㅠ이렇게 여러가지 문제를 Monitor를 이용해서 쉽게 해결할 수 있었다.장점과 단점을 살펴보면,  장점          사용이 쉽다.      Deadlock과 Error의 발생 가능성이 낮다.        단점          Monitor를 지원하는 언어에서만 사용 가능      Compiler가 OS를 이해하고 있어야한다.                  Critical section 접근을 위한 코드 생성                    ]]></content>
      <categories>
        
          <category> OS </category>
        
      </categories>
      <tags>
        
          <tag> OS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Covariance (공분산)]]></title>
      <url>/information/2020/04/23/Covariance-post/</url>
      <content type="text"><![CDATA[Covariance (공분산)The Covariance is a measure of how much the values of each of two correlated random variables determines the other.Covariance는 두 확률변수의 관계를 나타내는것이다.  독립적인 관계  양의 선형관계  음의 선형관계먼저 $ E(X-m_x) $에 대해 생각해보자. (X에 대해서만 1차원적으로 생각해보자.)이렇게 X축 위에 3개의 숫자가 있다. 각각 A=1, B=2, C=3이다.이때 X = [A,B,C]라고 했을때 X의 Expected Value, 즉 기대값은 E(X) = 2이다.그렇다면 $ X - m_x = [A-2, B-2, C-2]$가 된다.X라는 확률변수의 축이 2만큼 이동한 형태로 바뀐다.Covariance라는건 위에서 말했던 것 처럼 두 확률변수의 관계를 나타내는 것이다.2개의 확률변수 X, Y는 다음과 같다.X = [0, 0.5, 1, 1.5, 2]Y = [0, 0.5, 1, 1.5, 2]두가지 확률변수 값들을 2차원 좌표평면에 나타내보면위의 왼쪽 그래프와 같은 산점도가 그려진다.여기서 X와 Y의 평균(기대값)을 축으로 표현하면 오른쪽 그래프와 같다.Covariance 수식으로 돌아와서 살펴보면      $ Cov(x,y) = E\{(X-m_x)(Y-m_y)\} $        $X-m_x = [-1,\ -0.5,\ 0,\ 0.5,\ 1]$        $Y-m_y = [-1,\ -0.5,\ 0,\ 0.5,\ 1]$  위의 값을 이용해서 $(X-m_x) * (Y-m_y)$를 구하면,$(X-m_x) * (Y-m_y) = [1,\ 0.25,\ 0,\ 2.5,\ 1]$가 된다.결국 $X-m_x, \ Y-m_y$의 평균은 0이지만, $ E{(X-m_x)(Y-m_y)} $는 양의 값을 가지게 된다.이때, 양의 값을 가지는 Covariance를 근거로 두 확률변수가양의 선형관계를 가지고있다고 말할 수 있는 것이다. (점들이 주로 제 1,3사분면에 분포)반대로 X와 Y의 산점도가 위와 다르게 점들이 제 2,4사분면에 주로 분포를 한다면,두 확률변수가 음의 선형관계를 가지고있는 것이고 Covariance는 음의 값을 가진다.Covariance의 값이 0일 경우 두 확률변수는 독립적인 관계에 있는 것이다.(선형관계일때만 해당한다. Covariance의 약점에서 다룬다.)위의 내용을 정리하면,  Covariance &gt; 0          두 확률변수는 양의 선형관계        Covariance &lt; 0          두 확률변수는 음의 선형관계        Covariance = 0          두 확률변수는 독립적인 관계      Covariance의 약점하지만 Covariance에는 약점이 있다!  Covariance는 선형적인 관계만 파악할 수 있다.  확률변수들의 단위의 크기에 영향을 받는다.첫번째 약점예를들어, 위 그래프와 같이 2차함수의 모양으로 분포되어 있다고 할 때,이런식으로 표현이 되는데, X와 Y는 2차함수의 관계를 가지지만,Covariance를 계산하면 0에 가깝게 나오기 때문에실제로 그렇진 않지만 해석상으로 두 변수는 독립적인 관계를 가진것이 된다.이처럼 선형관계 말고는 파악할 수 없다는 약점이 있다.두번째 약점Covariance는 단위의 크기에 영향을 받는다.예를들어 시험점수와 공부시간의 관계를 Covariance로 나타낸다고 할때,  10점이 만점인 국어시험  100점이 만점인 영어시험각각의 시험과 공부시간의 관계는 실질적으로 비슷하다고 하더라도영어시험과 공부시간의 관계를 나타내는 Covariance가 더 큰 값을 가지게 된다.이러한 결과를 방지하기 위해 Correlation(상관계수)를 사용한다.​Correlation은 $\rho$라는 기호를 사용해서 표현한다.이렇게 Covariance에 두 변수의 표준편차를 나눠줌으로써Correlation는 $-1\le \rho \le 1 $의 범위를 가진다.이렇게 함으로써 단위의 크기에 의한 오류을 없앨 수 있다.]]></content>
      <categories>
        
          <category> Information </category>
        
      </categories>
      <tags>
        
          <tag> Information </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Data Structure week6]]></title>
      <url>/data%20structure/2020/04/12/Data_structure_week6-post/</url>
      <content type="text"><![CDATA[Data Structure Week 6KAIST 산업및시스템공학과 문일철 교수님의데이터 구조 및 분석: Linear Structure and Dynamic Programmingedwith 강의를 보고 정리한 내용입니다.Weekly ObjectivesThis week, we study the tree data structure. Particularly, we will focus on the structure and the operation of the binary search tree.Objectives are  Memorizing the definitions, the terminologies and the characteristics of trees  Understanding the structures of trees  Understanding the structure and the operations of a binary search tree          Insert, search, delete operations      Tree traversing operations                  Depth first search                          In-order, post-order, pre-order sequences                                Breadth first search          Level order search                      Understanding the performance of binary search treeTree Structure 중에서 BST (Binary Search Tree)에 대해 배웁니다.Detour: Abstract Data TypesAn ADT specifies:  Data stored  Operation  Error response(3주차에서 다뤘었습니다.)사실 Tree도 일종의 ADT이다.upside down 형태의 ADT (마치 나무가 거꾸로 된 형태)Tree      일종의 ADT다.        Data가 tree structure로 저장되어 있다        operations                  기본적인 Data structure라면 지원하는 OP들은 다 지원한다. (ex) LinkedList의 insert, delete, search                    Special searching approaches for trees and networks        -&gt; 일직선의 구조가 아니기때문에 다양한 traverse가 정의된다.            Why do we use trees현실의 Tree Structure Example  조직도  Group bank accounts  CommandTree structure는 왜 쓰는가?      A clear approach of Divide and Conquer        Data의 특성을 반영하여 Divide하고, 저장하는 문제를 풀어나가는 방식이 쓰여진 Structure        LinkedList같은 Data structure보다 더 적은 retrieval 만으로도 필요한 data를 search할 수 있다.    (뒤에서 자세히 이야기 합니다.)  Recursion도 마찬가지로 Divide and Conquer방식으로 Top-down으로 문제를 줄여나갔었다.Tree structure를 다룰때도 Recursion를 많이 활용하게 될 것이다.Structure of stored dataLinked List같은 경우는 object + Next를 가진 하나의 Node로 표현해서 사용했었다.      object가 가진 value에 대한 reference        다음 노드를 가리키는 reference  이런 LinkedList를 세로로 세웠다고 생각해보자.Tree구조와 유사하지만 다른점이 있다.Tree구조에서 네모하나를 Node(tree node)라고 할 때,LinkedList같은 경우, Next는 하나밖에 없었는데, Tree structure의 경우 Next가 여러개이다.  Each node has multiple next nodes  Particularly, this structure maintains the next “nodes” as an array or variablesTree Structure는 점점 커지게 되고, 그에 따라서 데이터를 저장할 공간이 점점 커지게 되는 것문제는 Next가 여러개이기 때문에, 여러 Next중에 어떤 Next를 선택해야할지가 햇갈릴 수 있는데,그런것에 대한 룰을 잘 세우는것이 Tree를 관리하는 기법이 됨Terminologies of tress structure      Edge          하나의 Next reference를 Edge (화살표)            Node          하나의 Next reference가 가리키는 것, object하나와 4개의 reference를 가지고 있는 Instance            Root          맨 위에 있는 Node (마치 LinkedList의 head)            Parent and Child          두개의 Node가 edge로 연결되어 있을 때, 상위 Level의 Node가 Parent      하위 Level의 Node가 Child            Siblings          같은 Level에 있는 (동일한 parent를 가진) Node            Terminal Node and Internal Node          Terminal Node는 Child가 없는 노드      Internal Node는 Terminal Node의 반대            Descendants and Ancestors          Node A의 Child, Child의 Child같이 Node A와 연결된 모든 하위 Level의 Node를 지칭한다.      parent를 따라가다보면 A를 만나게 된다.            Ancestors는 Descendant의 반대, 조상님을 의미        Path to E          매우 중요한 path개념      Root위치에서 특정 Node까지 edge를 통해 갈 수 있는 최단거리의 길을 path라고 한다.            Depth and Level of B          B라는 노드에 대한 path는 1이 된다. -&gt; B의 Depth는 1이다.      Depth = Path length            Height of tree          Maximum path length = Height of tree            Degree of B Node          특정노드의 Degree는 B가 가질 수 있는 Child의 수            Size of tree          Tree에 있는 Node의 개수 (저장되어있는 데이터의 개수)            Full Tree          Leaf가 모두 동일레벨      Internal Node에는 모든 Next들이 fully하게 다음 Node를 가리키고 있음      삼각형 모양            Complete Tree          바로 직전 Depth까지는 full tree structure인데, 맨 왼쪽부터 하나하나 채워나가는 과정 (순서대로)중이면 Complete tree (Filled from left)      Characteristics of trees  Num of edges =  (Num of nodes) - 1  Depth of root = 0  Height of root = height of tree = Maximum path length  Maximum num of nodes at level i with degree d          $d^i$        Maximum num of leaves with height h and degree d          $d^h$        Maximum size of a tree with height h and degree d          $= d^0 + d^1 + d^2 + .. + d^h = d^(h+1) -1 / (d-1)$        Height of a complete tree with size s and degree d          위의 식을 LOG로 바꿔서 전개      log는 실수형, Height는 정수형이라서 올림을 해줌      Binary Search Tree (BST)Binary tree = Degree가 2인 TreeBinary “search” tree  Degree가 2인 tree  저장된 데이터에 대해서 빠르게 search가 가능하게 디자인되었다.  빠르게 search가 가능하도 데이터의 특성을 활용해서 구조를 만들어야한다.ex) 건물에서 화장실을 찾으려고 함화장실을 찾아가려면 어떻게해야할까?  직원에게 물어보기  무작정 걷기  Sign을 찾기  짐작해서 찾아보기 (Guess)보통 4번째으로도 화장실을 찾을 수 있는 이유는?-&gt; 건물의 설계에는 일정한 패턴을 가지고 있기 때문 (귀퉁이에 있다던지, 엘리베이터 옆에 있다던지)-그래서 1,2,3을 하지 않아도 짐작으로 화장실을 찾아갈 수 있는데이런식으로 데이터도 일정한 패턴을 가지도록 만든다면, 빠른 search가 가능하다.A scenario of using binary search tree1001부터 시작되는 Account ID에서 1004를 찾는다고 할때LinkedList라면 1001부터 4번의 retrieval을 해서 1004를 찾아가야함binary search tree는 2개의 Next가 있는데왼쪽에는 더 작은값을 저장하고, 오른쪽에는 더 큰 값을 저장한다.이런 방식으로 했을 때에 규칙이 있기때문에 더 적은 retrieval만으로도 원하는 데이터를 찾을 수가 있다.Implementation of Tree Node먼저 Tree의 Node를 만들어야 함Member Variable  Left hand side node          Lower than its own value        Right hand side node          higher than its own value        parent node  value-&gt; 4개의 reference를 가진다.Member function  simple get/set methods (encapsulation)class TreeNode:    # Member variable    nodeLHS = ''    nodeRHS = ''    nodeParent = ''    value = ''    def __init__(self, value, nodeParent):    	self.value = value    	self.nodeParent = nodePraent    # Simple get methods    def getValue(self):        return self.value    def getParent(self):        return self.nodeParent    def getLHS(self):        return self.nodeLHS    def getRHS(self):        return self.nodeRHS    # Simple set methods    def setValue(self,value)    	self.value = value    def setParent(self, nodeParent):        self.nodeParent = nodeParent    def setLHS(self, nodeLHS):        self.nodeLHS = nodeLHS    def setRHS(self, nodeRHS):        self.nodeRHS = nodeRHSImplementation of BSTMember Variable  root에 대한 reference만 가지고 있다.Member function  insert  search  delete  findmax  findmin  traverselevelnorder  traverseInorder  traversepreOrder  traversePostOrderInsert operation of binary search tree어떻게 규칙을 지켜가며 LHS, RHS에 정확하게 data를 저장할 수 있을까?  기본적으로 Recursion을 사용한다.insert할 떄 특정한 Node or Root를 받아오게 됨Case 1. root가 비어있다.  root에 그 데이터를 저장한다.Case 2. 이미 insert하려고하는값이 저장되있다.  중복된 insert는 안하고 returnCase 3. 현재 Node의 value가 저장하려고하는 value보다 작을 경우 (My value &lt; Node’s value)  현재 Node의 RHS에 저장          RHS에 이미 value가 있다면?                  RHS와 또다시 비교 (반복)                      현재 Node의 value가 더 크다면?          LHS에 저장      LHS에 이미 value가 있다면?                  LHS와 또다시 비교 (반복)                    class BinarySearchTree:    root = ''    def __init__(self, root=''):        self.root = root            def insert(self, value, node=''):        # 초기화 구문        if node == '':            node = self.root        # root가 비어있다면, root에 저장한다.            if self.root = '':            # TreeNode(value, nodeParent)            self.root = TreeNode(value, '')            return        # 같은 value가 있다면 insert하지 않고 return한다.        if value == node.getValue():            return        # Value가 현 Node의 value보다 작을 경우        if value &lt; node.getvalue():            if node.getLHS() == '':                node.setLHS(value)            else:                # Recursion                node.insert(value, node.getLHS)        if value &gt; node.getvalue():            if node.getRHS() == '':                node.setRHS(value)            else:                # Recursion                node.insert(value, node.getRHS)        returnSearch operation off binary search treeSearch하려는 value가 있으면 True를 return한다.찾으려는 value가 그 Node의 Value보다 작다면 (My value &lt; Node’s value)  if there is a node in the right hand side, then move to the RHS node (recursion)      더이상 RHS가 없다면 False를 Return    다음번에는 LHS로 찾아가야함 (RHS쪽은 생각도 안해도 됨)value가 Node보다 크다면 (My value &gt; Node’s value)      if there is a node in the left hand-side, then move to the LHS node (recursion)    RHS로 찾아가야함 (LHS쪽은 생각도 안해도 됨)  더이상 LHS가 없다면 False를 Return찾을 영역이 계속해서 줄어든다.-&gt; Recursion을 이용해서 서서히 찾아간다.LinkedList같은 경우는 Chain을 계속 따라가서 찾아야함 (n개가 있다면 n개를 다 봐야함)Tree구조는 그럴 필요없이 Height만큼 or Depth만큼만 찾아보면 된다.-&gt; LinkedList에 비해 상대적으로 Search 성능이 더 좋다.class BinarySearchTree:    root = ''    def __init__(self, root=''):        self.root = root        def search(self, value, node=''):        # 초기화 구문        if node == '':            node = self.root        # Value와 같다면 True를 return, escape routine        if value == node.getValue():            return True        # Value가 현 Node의 value보다 작다면 LHS에서 search, LHS가 없다면 False를 return        # Recursion        if value &lt; node.getValue():            if node.getLHS() = '':                return False            else:            	return search(value, node.getLHS())        # Value가 현 Node의 value보다 크다면 RHS에서 search, RHS가 없다면 False를 return        # Recursion        if value &gt; node.getValue():            if node.getRHS() = '':                return False            else:            	return search(value, node.getRHS())Delete operation of binary search treeTree structure에서 Delete는 매우 복잡하다.  값을 삭제한 후에 트리에 생기는 여파가 크기 때문이다.Node를 하나 없애는 것인데,Node가 Child가 없는 Node라면 딱히 복잡하지 않다.그러나 Child가 하나라도 있다면 복잡해진다. (child는 그대로두고, parent node만 없애야하기 때문)Three Deletion Case      Deleting a node with no children          그다지 어렵지 않음. parent node로 가서 reference만 끊어주면 됨            Deleting a node with one child          Replace the node with the child. Child가 parent node의 자리를 대체하면 됨            Deleting a node with two children                  해법들의 concept은 어떤 node를 그 자리에 올리는 것이다.                    child Node를 올리면 규칙을 위반할 수도 있기 때문에,        지우려는 value에 가장 가까운 Node를 찾아야 한다.                    Find either                              A maximum in the LHS or A minimum in the RHS (중간에 가까운걸 찾는 두가지 방식)                                substitute the node to delete with the found value                                Delete the found node in the LHS or the RHS                              Tree structure는 그대로 둔 상태에서 가장 가까운 Node를 그 자리에 copy한다.이때 이 노드는 반복적으로 RHS면 RHS, LHS면 LHS을 지속적으로 추적하다가,더이상 LHS나 RHS가 없을 때의 Node를 가져온 것이기 때문에 Child가 많아봤자 1개이다.앞에서 다룬 2가지의 케이스를 적용해서 그 값을 삭제class BinarySearchTree:    root = ''    def __init__(self, root=''):        self.root = root        def delete(self, value, node=''):        if node == '':            node = self.root        if value &lt; node.getValue():            return self.delete(value, node.getLHS())        if value &gt; node.getValue():            return self.delete(value, node.getRHS())        if value == node.getValue():            if node.getLHS() != '' and node.getRHS() != '':                # findMin method는 뒤에서 findMax method와 함께 정의합니다.                nodeMin = self.findMin(node.getRHS())                # 그 자리에 가장 가까운 node를 copy                node.setValue(nodeMin.getValue())                self.delete(nodeMin.getValue(), node.getRHS())            	return            # 지금 이 Node가 Parent의 LHS인지 RHS인지 확인하기 위한 Instance            parent = node.getParent()            # 현 node가 RHS는 없고, LHS만 있을 때             if node.getLHS() != '':                if node == self.root:                    self.root = node.getLHS()                # 현 node가 parent의 LHS에 있을 때                elif node == parent.getLHS():                    parent.setLHS(node.getLHS())                    node.getValue().setParent(parent)                # 현 node가 parent의 RHS에 있을 때                else:                    parent.setLHS(node.getLHS())                    node.getLHS().setParent(parent)                return            # 현 node가 LHS는 없고, RHS만 있을 때             if node.getRHS() != '':                if node == self.root:                    self.root = node.getRHS()                # 현 node가 parent의 LHS에 있을 때                elif node == parent.getLHS():                    parent.setLHS(node.getLHS())                    node.getValue().setParent(parent)                # 현 node가 parent의 RHS에 있을 때                else:                    parent.setLHS(node.getLHS())                    node.getLHS().setParent(parent)                return            # 현 node가 LHS도 없고, RHS도 없는 경우            if node == self.root:                self.root = ''            elif parent.getLHS() == node:                parent.getLHS() = ''            else parent.getRHS() == node:                parent.getRHS() = ''            returnMinimum and maximum in Binary search tree  Find Minimum          계속 LHS로만 찾아가면 Minimum을 찾을 수 있음        Find Maximum          계속 RHS로만 찾아가면 Maximum을 찾을 수 있음      언제까지?Recursion을 이용해서 더이상 LHS 또는 RHS가 없을 때까지 찾는다.class BinarySearchTree:    root = ''    def __init__(self, root=''):        self.root = root    # RHS로만 keep moving하면 최대값을 찾을 수 있다.    def findMax(self, node=''):        if node == '':            node = self.root        if node.getRHS() = '':            return node        return self.findMax(node.getRHS())    # LHS로만 keep moving하면 최소값을 찾을 수 있다.    def findMin(self, node=''):        if node == '':            node.self.root        if node.getLHS() == '':            return node        return self.findMin(node.getLHS())    # 언제까지? 더이상 없을 때 까지Tree traversingLinkedList, Stack, Queue같은 경우는 선형적인 Data structure이런 경우 그냥 순서에 따라 출력하면 되는데Tree같은 경우는 어떤 규칙에 따라서 출력을 해야할까?Tree  Complicated than a list  데이터 전체를 출력하는 여러가지 방법이 있다.          List라면                  순서에 따라서 처음부터 끝까지 보여주면 된다.                    BST라면?                  어떤식으로 보여줄지 정해야 한다.                          LHS              RHS              The value that you have                                          Depth First Traversevalue, LHS, RHS 이 세가지를 출력할 순서를 정해야 한다.Value를 언제 출력하냐에 따라 3가지로 나뉨  Pre-order traverse          Value를 먼저 출력      순서 : Current, LHS, RHS in Recursion        In-order traverse          LHS와 RHS 사이에      순서 : LHS, Current, RHS in Recursion      Sorting되어있는 결과와 동일함        Post-order traverse          LHS와 RHS 뒤에      순서 : LHS, RHS, Current in Recursion      일반적으로 LHS를 RHS보다 먼저 출력함 (LHS가 더 작은 값이니까)Current의 LHS와 RHS에서도 그들의 LHS, RHS에 대해서 똑같은 방법으로 Recursion(smaller scale에서 같은 algorithm으로 처리 -&gt; recursion)class BinarySearchTree:    root = ''    def __init__(self, root=''):        self.root = root	def traverseInOrder(self, node=''):    	if node == '':        	node = self.root        ret = []        # Append LHS first        if node.getLHS != '':            ret = ret + self.traverseInOrder(node.getLHS)        # Append current second        ret.append(node.getValue())        # Append RHS third        if node.getRHS() != '':            ret = ret + self.traverseInOrder(node.getRHS)        return ret    def traversePreOrder(self, node=''):        if node == '':            node = self.root        ret = []        # Append current first        ret.append(node.getValue())        # Append LHS second        if node.getLHS == '':            ret = ret + self.traversePreOrder(node.getLHS())        # Append RHS third        if node.getRHS == '':            ret = ret + self.traversePreOrder(node.getRHS())        return ret     def traversePost(self, node=''):        if node == '':            node = self.root        ret = []         # Append LHS first        if node.getLHS == '':            ret = ret + self.traversePreOrder(node.getLHS())        # Append RHS second        if node.getRHS == '':            ret = ret + self.traversePreOrder(node.getRHS())        # Append current third        ret.append(node.getValue())        return retBreadth First TraverseRecursion는 Stackframe을 사용했었다. (Top-down, LIFO)하지만 Breadth First traverse는 Queue-based level-order traverse  Enqueue the root          while until queue is empty      Print current      current의 LHS가 존재한다                  Enqueue current LHS                    current의 RHS가 존재한다                  Enqueue current RHS                    class BinarySearchTree:    root = ''    def __init__(self, root=''):        self.root = root    # Queue를 이용한 traversing 방법    def traverseLevelOrder(self):        ret = []        Q = Queue()        Q.enqueue(self.root)        # Queue가 비워질 때까지 반복        # Dequeue되는 Node의 LHS,RHS를 거치면서 없을 때 까지 반복한다.        while(Q.isEmpty() == False):            node = Q.dequeue()            if node = '':                continue            # Append current first            ret.append(node.getValue())            # LHS가 있으면 Append            if node.getLHS() != '':                Q.enqueue(node.getLHS())            # RHS가 있으면 Append            if node.getRHS() != '':                Q.enqueue(node.getRHS())        return retPerformance of Binary Search Tree장점  규칙에 따라 데이터를 저장함으로써 검사를 안해도 되는 영역이 넓어진다.하지만 Depth height만 높은 Tree는 이런 장점이 사라지게 된다.]]></content>
      <categories>
        
          <category> Data Structure </category>
        
      </categories>
      <tags>
        
          <tag> Data Structure </tag>
        
          <tag> Tree </tag>
        
          <tag> BST </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[test]]></title>
      <url>/test/2020/04/10/test-post/</url>
      <content type="text"><![CDATA[Here is one mermaid diagram:  graph TD  A[Client] --&gt; B[Load Balancer]  B --&gt; C[Server1]  B --&gt; D[Server2]And here is another:  graph TD  A[Client] --&gt;|tcp_123| B(Load Balancer)  B --&gt;|tcp_456| C[Server1]  B --&gt;|tcp_456| D[Server2]This formula $f(x) = x^2$ is an exampleThis formula $f(x) = x^2$ is an example.This formula $f(x) = x^2$ is an example$$\lim_{x\to 0}{\frac{e^x-1}{2x}}\overset{\left[\frac{0}{0}\right]}{\underset{\mathrm{H}}{=}}\lim_{x\to 0}{\frac{e^x}{2}}={\frac{1}{2}}$$  graph TD  A[Company] --&gt; |150| B[Human Resource Department]  A --&gt; |300| C[Sales Department]  A --&gt; |150| D[Development Department]  C --&gt; |100| E(Seoul Store)  C --&gt; |100| F(Incheon Store)  C --&gt; |100| H(Bucheon Store)graph TD  A["회사"] --&gt; |150| B["인사부"]  A --&gt; |300| C["영업부"]  A --&gt; |150| D["개발부"]  C --&gt; |100| E("서울점")  C --&gt; |100| F("인천점")  C --&gt; |100| H("부천점")  graph TD  A[(Company)] --&gt; B[(Human Resource Department)]  A --&gt; C[(Sales Department)]  A --&gt; D[(Development Department)]  C --&gt; E(Seoul Store)  C --&gt; F(Incheon Store)  C --&gt; H(Bucheon Store)graph BT subgraph Stackframe	subgraph A		1-1("F(4)") --- 101("Top") 	end	subgraph two		2-1("F(4)") --- 2-2("F(3)") --- 102("Top") 	end 	subgraph three		3-1("F(4)") --- 3-2("F(3)") --- 3-3("F(2)") --- 103("Top") 	end 	subgraph four		4-1("F(4)") --- 4-2("F(3)") --- 4-3("F(2)") --- 4-4("F(1)") --- 104("Top")   end   subgraph five	  5-1("F(4)") --- 5-2("F(3)") --- 5-3("F(2)") --- 5-4("F(0)") --- 105("Top")   end   subgraph six	  6-1("F(4)") --- 6-2("F(3)") --- 6-3("F(2)") --- 106("Top")   end   subgraph seven	  7-1("F(4)") --- 7-2("F(3)") --- 107("Top")   end   subgraph eight	  8-1("F(4)") --- 108("Top")   end  subgraph nine 	  109("Top")   endend   graph TD  A[(Company)] --- B[(test)]  graph LR  id1[(Database)]]]></content>
      <categories>
        
          <category> test </category>
        
      </categories>
      <tags>
        
          <tag> test </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[OS Lecture 5]]></title>
      <url>/os/2020/04/07/OS5-post/</url>
      <content type="text"><![CDATA[유튜브 HPC Lab. KOREATECH 채널, 김덕수 교수님의 OS 강의를 보고 정리한 내용입니다.Lecture 5Process Scheduling여러개의 Process가 시스템(Kernel) 내 존재하고, (다중프로그래밍 환경)CPU라는 Resource을 나눠서 사용해야함스케줄링:자원을 할당 할 프로세스를 선택하는것자원관리  Time sharing 관리          하나의 자원(Processor)을 여러 Thread들이 번갈아 가며 활용      Process scheduling (이번 시간에 배울거)        Space sharing 관리          하나의 자원(Memory)를 분할하여 동시에 사용      Goal of Scheduling: 시스템의 Performance를 높이는 것여기서 Performance(성능)라는것은 모호한 표현-&gt; 기준이 무엇인가에 따라서 바뀔 수 있다.System Performance의 대표적 지표 (index)  Response time (응답시간)          작업요청(submission)으로부터 응답을 받을때까지의 시간        Throughput (작업 처리량)          단위 시간 동안 완료된 작업의 수        Resource utilization (자원 활용도)          주어진 시간동안 자원이 활용된 시간      전부 중요한 지표이며, 목적에 따라 그 중요도가 달라진다.-&gt; 목적에 맞는 지표를 고려해서 Scheduling 기법을 선택해야함ex)  사용자 대화형 시스템, Real time system -&gt; Response time이 제일 중요!  Batch system -&gt; Throughput이 제일 중요!  비싼 장비 -&gt; Resource utilization이 제일 중요!그 외에도 많은 지표들이 있음+++Waiting time, Response time, Turn-around time (대기시간, 응답시간, 반환시간)Waiting time : Process가 실행을 기다리는 시간Response time : 첫번째 출력까지 걸린 시간Turn-around time : 원하는 일이 모두 끝날 때까지의 시간            Normalized Turn-around time = (Turn-around time) / (Burst time)              동일한 기준으로 평가하고 싶을 때 사용함 (절대적인 시간이 아닌 상대적인 시간이라고 보면 됨)            Burst time : 실제로 Process가 실행된 시간Scheduling Criteria and Levels (스케줄링 기준 및 단계)Scheduling Criteria: 스케줄링 기법이 고려하는 항목들 -&gt; 기준  Process의 특성          Compute bounded or I/O bounded                  Compute bounded :  CPU를 더 많이 쓰는 Program          I/O bounded :  I/O가 더 많은 Program                      시스템 특성          Batch system or interactive system (목적에 따라 달라지게 됨)        Process의 긴급성 (Urgency)          Hard or soft real time, non-real time systems        Process Priority  Total Process Service timeCPU burst vs I/O burstProcess 수행 = (cpu 사용 + I/O 대기) 를 반복어떤 Program은 CPU를 더 많이 쓸 수도있고, 어떤 Program은 I/O를 더 많이 할 수도 있다.이때 CPU를 더 많이 쓰는 Program -&gt; Compute-bounded Process반면 I/O가 더 많은 Program -&gt; I/O bounded ProcessScheduling Level: 발생하는 빈도 및 할당 자원에 따른 구분  Long-term Scheduling (가끔)  Mid-term Scheduling (종종)  Short-term Scheduling (자주)Long-term Scheduling: 긴 시간에 한번씩 일어나는 schdulingJob scheduling이 속함  (Process라는 건 job이 커널에 등록된 것이라는 거 기억!)  어떤 Job을 Kernel에 등록할지 결정다중프로그래밍의 정도(Degree) 조절  다중프로그래밍의 정도 : 시스템 내의 프로세스의 수  ex) 있는 프로세스를 다 등록해놔도 상관없겠지만 관리하기 쉽도록 조절그래서 많은 Process 중에 어떤 Process을 먼저 올려줄 것 인가?I/O-bounded와 compute-bounded 프로세스중에 선택해야한다면?-&gt; 잘 섞어서 선택해야 한다. 왜?-&gt; 시스템 입장에서 하나가 논다는것은 비효율적이니까, I/O와 프로세서가 둘다 열심히 일하는게 효율적임시분할 시스템(Time-sharing)에서는 모든 Job을 시스템에 등록  Long-term scheduling이 상대적으로 덜 중요함Mid-term SchedulingMemory allcation 결정  ex) Swapping  Intermediate-level schedulingShort-term SchedulingProcess scheduling      Processor를 할당받을 Process를 결정          Processor scheduler, dispatcher(ready state -&gt; running state) 라고도 함            가장 빈번하게 발생          매우 빨라야 함      Scheduling PolicyPolicy : 뭔가를 수행하기 위한 방법? or 기준?  Preemptive vs Non-preemptive (선점 vs 비선점)  Priority (우선순위)Preemptive / Non-preemptive schedulingPreemptive(선점) : 누가와서 빼앗을 수 있다.Non-preemptive(비선점) : 누가와서 빼앗을 수 없다.Non-preemptive scheduling  Process가 스스로 반납할 때 까지 사용 (안 뺏김)  장점          Context switch overhead가 적음        단점          우선순위가 높은 걸 먼저 처리 못하는 우선순위 역전현상이 일어남      평균 응답시간 증가      Preemptive scheduling  자원을 뺏길 수 있음          할당시간 종료, 우선순위가 높은 프로세스 등장        장점          Time-sharing system, real-time system에 적합 -&gt; 응답성이 높다.        단점          Process가 자주 바뀌어서 Context switch overhead가 커짐      Priority: 우선순위Static priority: 프로세스 생성시 결정된 Priority가 유지됨  구현이 쉽다.  Context switch overhead가 적다.  환경변화에 대한 대응을 잘 못함Dynamic priority: 프로세스의 상태변화에 따라 변경  구현이 복잡하다.  Context switch overhead가 크다.  환경변화에 대한 유연한 대처 가능여기까지 요약System에는 Process가 많으니까 (Multi-Programming),Scheduling이 필요하고,그 목적은 Performance을 높이는 것이고,Performance에는 다양한 Index가 있고,  Response time  Throughput  Resource utilizationScheduling에는 다양한 Criteria가 있고,  Feature of Process  Feature of System  Urgency of Process  Process PriorityScheduling은 빈도에 따라 Level이 나뉘고,  Long term  Mid-term  Short-termScheduling은 다양한 Policy이 있다.  Preemptive / Non-preemptive  PriorityBasic scheduling algorithms (기본 스케줄링 알고리즘들)  FCFS  RR  SPN  STRN  HRRN  MLQ  MFQ엄청 많네FCFS (First-Come-First-Service): 선착순, **먼저 오는 Process에게 먼저 Processor를 할당해줄거다.  Non-preemptive scheduling (내 일이 끝날 때까지.)      스케줄링의 기준 (Criteria)          도착시간 기준 (Ready queue 기준)        장점          자원을 효율적으로 사용 가능                  불필요한 Overhead없어서 자원을 계속계속 사용                    Batch system에 적합        단점          긴 평균 응답시간 (Interactive system에 부적합)                  먼저온 Process 실행 끝날때까지 기다려야해서 Response를 바로바로 받을 수가 없음                    Convoy effect                  먼저온 Process가 끝나길 기다리느라 다른 Process들도 긴 대기시간을 갖게 됨 (대기시간 » 실행시간)                    실습영상 6분 30초 확인RR (Round-Robin): “일정시간만큼 돌아가면서 쓰자” 라는 기법 (원형탁상위에서 돌면서 하는 scheduling 연상 )  Preemptive scheduling  스케줄링의 기준 (Criteria)          도착시간 기준 (Ready queue 기준) -&gt; 먼저 도착한 프로세스부터        Resource 사용 제한시간이 있음 (Time quantum)          System parameter        Process는 할당된 시간이 지나면 자원 반납 (Timer-runout)  장점          자원 독점을 방지        단점          자꾸 프로세스를 바꿔야하니까 Overhead가 큼      Interactive system과 Time-sharing system에 적합Time quantum이 System의 Performance를 결정하는 핵심요소      만약 Time quantum이 크다?    -&gt; FCFS와 비슷한 효과        만약 Time quantum이 0이 작다? (0에 수렴한다?)    -&gt; Process를 동시에 여러개 쓰고있는 느낌          하지만 Processor 체감 성능은 실제 프로세서의 성능의 1/n. 그리고 Overhead도 크다.      한번 실행된 Process는 맨 뒤로 가서 다시 줄을 선다.(Arrival time도 있으니 그것도 고려해야함 (Ready queue기준 빨리온 순서!))실습영상 21분 58초 확인SPN (Shortest-Process-Next): Burst time이 가장 작은 프로세스를 먼저 처리하자!위에서 나온 FCFS에서의 문제점?-&gt; 빨리 끝내고 나갈 수 있는 Process가 오래 기다려야 한다는 것      Non-preemptive scheduling        Scheduling Criteria          Burst time 기준                  SJF(Shortest Job First) scheduling                          장점          평균 대기시간(WT) 최소화      시스템 내 프로세스 수 최소화                  부하 감소, 메모리 절약                    많은 프로세스들에게 빠른 응답시간 제공            단점                  Starvation 현상 발생 (무한대기 현상)        -&gt; Burst time이 긴 프로세스는 무한으로 대기해야할 수도 있음                    정확한 실행시간을 알 수 없음        -&gt; SPN을 사용하려면 실행시간을 알아야 Scheduling을 할 수 있는데,        ​    실행해보기 전까지 얼마나 걸리는지는 알 수가 없음                  실행시간 예측 기법이 필요하다                    마트에 있는 소량계산대랑 비슷하게 보면 될 것 같습니다.실습영상 5분 40초SRTN (Shortest Remaning Time Next): SPN의 변형버전, 남은 실행시간이 가장 적은 Process부터 실행시키는 기법  Preemptive scheduling  장점          SPN 장점 극대화                  시스템 내 프로세스 수 최소화, 평균 대기시간 최소화                      단점          실행시간 예측의 어려움      잔여 실행시간을 계속 추적해야함      Overhead      구현 및 사용이 비현실적임HRRN (HIgh-Response-Ratio-Next): SPN의 변형, Process의 대기시간을 고려한 기법SPN에서의 문제는 starvation 현상이 문제 (무한대기)      Non-preemptive scheduling    SPN + Aging concepts          Aging concepts이란?                  노약자를 배려하자 -&gt; Waiting time을 고려하라                      Scheduling Criteria          Response ratio가 높은 Process 우선      ​															필요한 BT(실행시간) 대비 얼마나 WT(대기시간)했는가가 기준이 됨  장점          SPN의 장점 + Starvation 현상 제거        단점          실행시간 예측이 필요      실습영상 13분 40초지금까지의 Scheduling algorithm을 정리해보면공평성(Fairness)가 목적  FCFS  RREfficiency/Performance가 목적  SPN  SRTN  HRRN아래있는 Algorithm들의 문제점은 실행시간을 예측해야 한다는것MLQ (Multi-level Queue)위의 SPN를 변형한 알고리즘들의 문제점인 “실행시간 예측”  실행시간 예측하지 않고 비슷한 효과를 내보자! 라는 컨셉      Ready Queue를 여러개를 가지고 각Queue마다 작업(or 우선순위)를 배정하겠다.    최초 배정 된 Queue를 벗어나지 못함  각각의 Queue는 자신만의 Scheduling algorithm 사용  Queue사이에는 우선순위 기반의 Scheduling 사용  장점          우선순위가 높은 Queue에 있는 Process 처리는 빠름        단점          여러개의 Queue 관리하는 것 자체가 힘듬      우선순위가 낮은 Queue에는 Starvation 현상이 일어난다.      MFQ (Multi-level Feedback Queue)MLQ의 경우, 최초 배정된 Queue를 벗어나지 못했다.  -&gt; 변화에 적응할 수가 없다.      그래서 MFQ는 Feedback을 통해 Priority를 조정    Dynamic priority (우선순위 조정에 현재까지의 Processor 사용 정보를 활용)      Preemptive scheduling    장점          BT(Burst time)를 예상하지 않아도 됨      Queue 사이를 이동할 수 있다.        단점          복잡하다. (우선순위 조정, Queue와 Queue사이 이동..)      Overhead가 크다.      우선순위 낮은 Queue의 Process들은 Starvation 현상        변형          Queue마다 시간 할당량을 다르게 배정                  Process 특성에 맞는 형태로 시스템 운영                    I/O bounded Process을 상위 단계 Queue로 이동                  평균 응답시간을 줄임, 작업분산으로 Utilization 극대화                    Starvation을 방지하기 위해 Aging기법으로 오래 기다린 Process를 상위 Queue로 이동        Parameters for MFQ scheduling          Queue의 수      Queue별 스케줄링 알고리즘      우선순위 조정기준      …      다양한 Parameter를 줘서  목적에 맞게 사용]]></content>
      <categories>
        
          <category> OS </category>
        
      </categories>
      <tags>
        
          <tag> OS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Github 블로그 기능추가]]></title>
      <url>/information/2020/04/06/add_utility-post/</url>
      <content type="text"><![CDATA[Github Blog에 댓글 기능 만들기 (Jekyll, utterances)MadPlay’s MadLife님 블로그 참고과정      utterances 다운로드          https://utteranc.es/            새로운 Repository 생성 (Optional)          그냥 같은 repository에다가 해도 상관없음            utterances에서 빈칸을 채우고 매핑방법 선택        만들어진 스크립트 코드를 복사해서 포스트 레이아웃에 include          스트립트 코드의 repo 항목이 내가 선택한 repository가 맞는지 확인      웹프로그래밍을 아예 모르다보니 어디다가 붙여넣기 해야하는지 햇갈렸는데 겨우 찾았다.테마마다 다를수도 있음.      /_includes 에 아래와 같은 코드를 가진 comments.html 파일을 만든다.    -comments.html-  &lt;script src="https://utteranc.es/client.js"        repo="Kojungbeom/-wareHouse"        issue-term="pathname"        theme="github-light"        crossorigin="anonymous"        async&gt;&lt;/script&gt;  /_layouts/post.html 맨 아랫줄에 다음과 같은 코드를 추가한다.&lt;hr&gt;&lt;script src="https://utteranc.es/client.js"        repo="Kojungbeom/kojungbeom.github.io"        issue-term="title"        theme="github-light"        crossorigin="anonymous"        async&gt;&lt;/script&gt;Github Blog에 카테고리와 테마 추가하기devYurim님 블로그 참고위 블로그에서는 category.html, index.html 파일을 수정해야 한다고 하셨는데,저같은 경우는 그냥 아무것도 안하고 글에categories:  - Informationtags:  - Information그냥 이런식으로 해주니까 나왔습니다.Jekyll 자체가 워낙 잘되있어서 그런듯하지만, 테마마다 다를 수 있으므로 위 블로그를 참고하세요.]]></content>
      <categories>
        
          <category> Information </category>
        
      </categories>
      <tags>
        
          <tag> Information </tag>
        
          <tag> Jekyll </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Data Structure week5]]></title>
      <url>/data%20structure/2020/04/05/Data_structure_week5-post/</url>
      <content type="text"><![CDATA[Data Structure Week 5KAIST 산업및시스템공학과 문일철 교수님의데이터 구조 및 분석: Linear Structure and Dynamic Programmingedwith 강의를 보고 정리한 내용입니다.Weekly Objectives  This week, we briefly learn the concept and the application of conputer simulations          Introduction purpose      Objectives are  Understanding the concepts of modeling and simulation.Application 중 하나인 Simulation의 종류와 정의에 대해 알려주십니다.크게 3가지 종류의 Simulation에 대해 언급하시는데, 저같은 경우는 헷갈리는게 많았습니다.이번 강의들은 이런게 있다고 생각하면서 들으시고 넘어가면 좋을 것 같습니다.Real World ProblemsReal world problem을 해결하기 위해서 과학적이고, 공학적으로 해결하는 구체적인 Solution도 찾아야하고,Computational analyses를 이용해서 관리하는 Solution을 만들어 내는것도 해야함-&gt; Simulation을 만들어야 한다!하지만 이런 Solution을 잘 만들기 위해선, 먼저 Problem에 대해 이해해야 한다!(이해가 바탕이 되지않으면 엉뚱한 Solution을 내놓을수도 있기 때문)How to comprehend a problem?먼저 Program에서 이해한다는게 무엇인지 생각해보자.Program을 어떻게 이해할 수 있을까?      주어진  Input에 대해서 Output이 무엇일지 예상한다.    Output를 예상할 수 있다는 말은 “프로그램이 어떻게 구동되고 있는지 이해하고 있다” 라는 말과 같다.        Estimate the progress of the program in the system (어떻게 돌아가고 있는지 추정한다.)        Just as we traced the function calls of the recursion in the execution timeline    (Recursion에서 그랬던것 처럼 프로그램의 실행을 역추적해서 살펴본다.)  문제 해결 과정      Fibonacci Sequence라는 문제가 있다.        Program으로 표현든다. (Modeling)        Program을 Execution하고 Trace해서 어떻게 돌아가는지 알아낸다.  예측 -&gt; 표현(프로그램으로) -&gt; ExecutionHow to comprehend a problem in real world?현실 세계의 문제는 어떻게 이해해야할까?ex)  Markets/Finance  Estimate the future of a given status-quo  Estimate the progress of problem factors in the system  However, the real-world problem is not a program in a well-defined programming language문제 해결 과정      “가격예측과 형성”이라는 현실문제가 있다.        Supply and Demand curve로 만들었다 (Modeling)        Supply and Demand curve의 해를 구한다.  예측 -&gt; 표현(Supply and Demand curve) -&gt; Solve(Execution)보기에는 현실문제를 다루는게 어려워보이지 않지만,Fibonacci sequence는 수학적으로 아주 잘 정의되어 있지만,현실의 문제는 그렇지 않기 때문에, 표현하는것 자체부터가 어렵다!Models and Why Modeling표현하기 어려운 현실모델을 간략화(Simplification)하여 Model을 만든다.(단순화하지만, 핵심적인 특성은 다 있도록 만드는게 목적)  Model      A simplification of the real world problems.  ex) 몽타주는 왜 쓸까? 사진이랑 다를수도 있는데?사진과는 다르지만, 얼굴의 특징을 잘 따서 만들었기 때문에 가치가 있음ex) Antoine de Saint-Exupery said  “Perfection is achieved, not when there is nothing more to add,  but when there is nothing left to take away”(교수님께서 이 말은 공학자들이 Modeling에 대해서 듣고 기억할만한 말이라고 하심.)핵심만 표현하여서 더이상 뺄게 없는것이 완벽한 것 이다.공학자들이 Modeling이라는것을 할 때 현실문제를 왜 simplification을 해야되고,무엇이 simplification의 대상이 되어야하는지에 대한 문구로 볼 수도 있겠다.  무엇을 빼야할까?      분석의 목적에 따라서 달라진다.    What to leave in the model  What to remove from the real worldTwo Types of ModelsModels to solve  Numerical modeling          Linear programming, integer programming      목표는 현실의 문제를 formula로 표현해내는 것.        최종적으로, 어떤 시점에서 해를 구해내는 것이 목표.하지만, Real World를 항상 이런식으로 formula로 만들거나 할 수 있는건 아님.너무 복잡해서 수학적인 해를 찾기 어려운 모델도 존재ex) Manufacturing Domain에서 반도체 생산단순화해보면  프로세서  카트리지  자원의 배분 ..이런것들 하나하나를 수학적으로 표현하는건 어렵다.이것들의 행동을 하나하나 표현을 하는건 너무 복잡하니까,그래서 이런 문제들을 Simulate함으로써 최적의 운영방법을 찾는 방법을 Simulation이라고 한다.Models to simulate      System dynamics, Discrete event models, Agent based models                  Event graphs, petri-net, agent modeling        Numerical modeling처럼 딱 떨어지는 해가 나오지않음        ==대신 예측치를 만들어냄==              “다양한 세팅에 대해서 아주 여러번 Simulation을 하면 최적의 Solution를 찾을 수 있을까”라고  하는 Model이 바로  Simulation Model이렇게 구해낸 해가 최적이다라고 장담은 못함System Dynamics혀노님 블로그 참고일반적으로 장기적인, 전략적 모델에서 사용됨사람들, 제품, 이벤트, 그리고 그 밖의 다른 개별적인 품목들을 그들의 수량으로 나타냅니다.비선형 모델, 순환적 연동에 근간(the many circular, interlocking..)Infectious DiseaseSIR Model (1925)  S : Susceptible (병에 걸릴 수 있는 상태)  I : Infectious (병에 걸린 상태)  R : Recovery (병에서 회복한 상태): 인구상태를 세개의 상태로 표현한 Model수가 변화되어가는 과정을 컴퓨터 Simulation함 (구체적인 해는 굳이 구해내지 않음)첫번째 식  시간에 차이에 따른 S의 차이는, I와 S를 곱한 것 이다.  S와 I의 관계를 잘 생각해보기두번째 식  시간의 차이에 따른 I는, I와 S를 곱한것이지만, 회복한 사람만큼 줄어든다.세번째 식  시간의 차이에 따른 R은, v와 I를 곱한 것 이다.  상태였던 사람은 시간에 따라서 R상태로 간다.  수식으로 표현된 상태에 따른 인구수의 변화를 컴퓨터 Simulation으로 만든거어떤 시간대를 주고 그때의 상황을 계산할수도 있긴 하지만(해를 구할 수도 있지만),대신에 Computer Simulation을 이용해서 Approximation(근사)함.현실문제를 공식에 따라서 표현한 것을 프로그램으로 만든 후에,execution을 통해 미래를 예측하는것을 Simulation!특히 위와같은 기법은 System Dynamics라고 함-&gt; 미분방정식 기반(?)의 Simulation을 활용한 현실문제 추정과 표현 기법Discrete Event Simulation혀노님 블로그 참고==연속 사건 사이에서 System의 변경은 발생하지 않는다고 가정합니다. ==따라서 Simulation은 한 Event에서 다음 사건으로 제 시간에 직접 점프 할 수 있습니다.이는 Simulation이 시간이 지남에 따라 System Dynamics를 지속적으로 추적하는연속 시뮬레이션(Continuous Simulation)과는 대조적입니다.(여기서 말하는 연속시뮬레이션은 실수단위의 데이터에 기반하여 모델링 되는 시스템)      미분방정식을 통해 시간의 변화에 따른 연속적인 변화를 나타내는 Simulation기법    (뭔가 아까 앞에서 나왔던 System Dynamics와 비슷해보입니다.)  Discrete Event Simulation은 고정된 환경하에서일률적이며 연속적으로 발생하는 사건들은 시스템의 직,간접적인 변화를 일으키지 않는다고 가정한 모델      사실 현실에서 일어나는 거의 모든 일이 확률적이고 랜덤하다.    그 와중에 확정적으로 일어나는 일 또한 분명있다.    결국 Discrete Event simulation에서 연속적으로 일어나는 Event는 시스템에 큰 영향을 끼칠만한 것이 아니라는 전제를 깔고간다.Hospital Managementex) 병원에서 사람들은  대기실  Exam room  치료실  출구이런곳을 돌아다닌다.SIR Model과 다른점은, 여기에는 여러 Object들이 있음  의사  환자  간호사  …이 Object들과 Resource들이 서로서로  Interaction을 일으킨다.그리고 예를들어 환자라는 Object는 환자진료 프로세스에 따라서 움직인다.There are a sequence of the patient care process.환자가 병원에 옴 -&gt; 예약 -&gt; 진료 -&gt; Exit(Chaining 되어있는 작업들)이런 Procedure와 병원의 Layout(Procedure가 일어나는 공간)이 합쳐져서,Simulation이 된다. (7:35)여기서 Object들이 각각의 Procedure를 만나는것을 Event가 발생했다고 하고,앞의 SIR과 다른점은 Event가 나눠져있다는 것이다.(SIR은 시간의 변화에 따라 지속적으로 변하는 것이었음. Event 단위가 아님)Airport Model두번째 Discrete event simulation 예시공항에서는  체크인  보안검사  식당  Gates  Plane 등등같은 Event들이 있다.이런 Event들을 정의하고, 통계를 많이 확보하면 공항이라는 공간을 어떻게보다 효과적으로 관리를 할 수 있을지 알 수 있다.(Simulation을 통해서)Layout도 중요하지만,Event들의 Sequence를 어떻게 설계하느냐가 성능을 좌지우지한다.공항이 생긴다면 많은 사람이 방문하기 때문에 최적화(Optimization)시키는것이 중요하다.Simulation을 만들어서 실험하는 것은 필수적이다. (한번 만들려면 돈이 엄청드니까 잘만들어야함)Agent Based Simulation혀노님 블로그 참고핵심단어는 Decentralized(분산적), Individual-centric(개인중심)The active entities(Object or Agent)를 식별하고,행동을 정의하고,그것들을 특정환경에 배치하고 연결하여 시뮬레이션을 실행Discrete Event Simulation은 한계가 있음  같은 종류의 Object라도 하는일들도 다르다  목적도 다를 수있음 (특성이 다르다)단순히 움직이는 것이 아니라, 인구학적인 특성을 가지고, 여러 변수들을 생각해서개체(Entities or Object) 하나하나에 특징을 살리는 방식이 Agent Based SimulationTraffic Simulation또다른 형태의 Simulation인 Traffic Simulation  자동차들마다 목적지도 다름  수송용 트럭일수도 있고, 관광용 버스일수도 있다.Graphic structure를 활용할 것임 (나중에 배움)]]></content>
      <categories>
        
          <category> Data Structure </category>
        
      </categories>
      <tags>
        
          <tag> Data Structure </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[OS Lecture 4]]></title>
      <url>/os/2020/04/01/OS4-post/</url>
      <content type="text"><![CDATA[==유튜브 HPC Lab. KOREATECH 채널, 김덕수 교수님의 OS 강의를 보고 정리한 내용입니다.==Lecture 4Thread 관리프로세스 관리(Process management)에서 Context switch가 등장했고,Context switch는 Cost가 크기때문에 가능한 줄이는게 좋고,줄이기위한 해결책으로 나온 Thread (한국어로 “실”)어떤 녀석인지 살펴보자Process and Thread이번에는 Process를“Resource를 할당받아 원하는 목적을 달성하는것” 이라고 하면,다음과 같이 Process를 나눌 수 있다.Process  할당 (Allocation)  제어 (Control)여기서 제어부분만 따로 떼어놓은 것이 Thread하나의 Process안에 Thread는 여러개가 있을 수 있음ex) 마치 팔이 여러개인 느낌Thread: 자원은 공유하고, 자신만의 각각의 제어요소를 가지고 있는 녀석다시말해  Process는 Resource + Control 라고 볼 수 있음Resource 영역 (자원 영역)  내가 짠 코드 (Program counter가 어떤 부분을 하고 있는지 가리키고 있음)  전역 데이터 (Global data)  힙  …Contorl 영역 (제어 영역)  제어정보          Stack pointer      Program Counter 등등            지역 데이터 (Local data)    ex) 어떤 지역에서만 유효한 데이터 -&gt; 제어를 위해 사용          Stack 영역에 저장이 됨      여기서, 이 제어 영역을 Thread라고 하는데,하나의 Process안에 여러개가 존재할 수 있다고 했다.한 Process안에서 Resource를 공유하면서, 여러개의 Thread가 존재한다.  같은 프로세스의 Thread들은 동일한 주소 공간 공유그리고 각 Thread마다 자신들의 Stack영역을 가지고, 그 안에서 Local data를 만들고, 그 안에서 작업함그리고 코드안에서 어떤영역을 해야하는지 각각 PC로 가리키는중다시 정리하면  Light Weight Process (LWP)          프로세스는 원래 자원하고 제어를 각각 가지고 있어야함      쓰레드같은 경우, 자원은 공유하고 제어부분만 가지고있으니까 더 가벼움            Processor 활용의 기본 단위    구성 요소          Thread ID      Register set (PC, SP 등)      Stack (i.e. local data)      제어 요소 외 코드, 데이터 및 자원들은 프로세스 내 다른 Thread들과 공유전통적 “Process “ 는 단일 Thread ProcessSingle-Thread vs Multi-Threads  Single      제어 하나, 자원 하나    Multi      제어 여러개, 자원 하나  Thread의 장점자원 공유 (Resource sharing)      프로세스가 자원을 공유하면, 하나의 프로세스가 처리 할 동안 하나는 멈춰있어야함 (Context switch도 발생)    -&gt; 하나의 자원을 여러개의 Thread가 동시에 사용(공유)이 가능하고, Context switch도 발생하지 않음    -&gt; Kernel의 개입을 피할 수 있음 -&gt; 효율성 증가  Economy  프로세스의 생성, Context switch에 비해 효율적Multi-Processor 활용      병렬처리를 통한 성능 향상    -&gt; 여러개의 쓰레드 == 여러개의 cpu core 동시에 사용 가능  사용자 응답성 (Responsiveness)  일부 스레드 처리가 지연되도, 다른 스레드는 계속 작업 처리 가능Thread 사용의 예ex) FPS 게임중에 화면출력, 사용자입력, 스피커/마이크사용을 동시에 하기위해서는멀티쓰레드가 아니라면, 하나를 하려면 나머지를 멈춰야하는일이 벌어짐.Solution  쓰레드를 여러개 만들어서 역할을 나눠주면됨 (이때 게임을 돌리기위한 자원은 공유됨)-&gt; 사용자 응답성을 높인다는게 이런 의미Thread의 구현사용자 수준 스레드 (User Thread)  사용자 영역의 스레드 라이브러리로 구현 됨 (쓰레드를 라이브러리처럼 구현)          라이브러리가 스레드의 생성, 스케줄링등을 관리      POSIX threads, Java thread API 등등      Thread Control Block(TCB)는 사용자 영역에 존재            개념적으로 살펴보면, Kernel Thread는 하나, User Thread는 여러개    -&gt; N:1 매핑이 된 상태        Kernel은 Thread의 존재를 모름          유연하고 low cost 관리 가능      Portability가 높음 (라이브러리만 같으면 내가 만든 멀티스레드 프로그램을 그대로 사용가능하다!)            단점은 커널이 스레드의 존재를 모르니까 그냥 프로세스 단위로 자원 할당을 해버림          하나의 쓰레드가 block상태가 되면, 모든 스레드가 대기해야됨 (Single-threaded kernel의 경우!)      커널 수준 스레드 (Kernel Thread)  OS(kernel)가 직접 관리  Thread Control Block(TCB)는 Kernel 영역에 존재  Kernel 영역에서 Thread의 생성, 관리 수행          1대1 매핑      Context switching 등 Overhead가 크다.        Kernel이 각 Thread를 개별적으로 관리          Process 내 Thread들이 병행 수행 가능                  하나가 block되도 대기할 필요 없음.                    N : 1 모델1 : 1 모델  둘다 장단점이 있으니까, N : M 모델을 사용하자 (N&gt;M)혼합형 쓰레드n개 사용자 수준 스레드 - m개의 커널 스레드 (n &gt; m)  사용자가 원하는 수만큼 스레드 사용  병행처리 가능 -&gt; Kernel Thread가 알아서 조절효율적이면서도 유연함.]]></content>
      <categories>
        
          <category> OS </category>
        
      </categories>
      <tags>
        
          <tag> OS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[OS Lecture 3]]></title>
      <url>/os/2020/03/30/OS3-post/</url>
      <content type="text"><![CDATA[유튜브 HPC Lab. KOREATECH 채널, 김덕수 교수님의 OS 강의를 보고 정리한 내용입니다.Lecture 3Process Management  Job vs ProcessJob  실행 할 프로그램 + 프로그램이 처리하는 데이터  실행 요청 전의 상태Process  실행요청을 받고, 실행을 위해 Kernel에 등록된 작업  시스템 성능 향상을 위해 Kernel에 의해 관리된다.Job은 disk 같은 곳에 보관이 되어있고,이걸 처리하기 위해 시스템(Kernel)에 처리하라고 요청하고,그것이 Kernel에 등록 된 상태를 Process!간단하게 생각하면 job은 메모리 할당을 안받은 상태고, Process는 받은 상태이다.-&gt; 다시 말하면 (Kernel에 등록 된 Job) == (Process)Definition of Process: 간단하게 말하면 “실행중인 프로그램”  Kernel에 등록되고 커널의 관리하에 있는 Job  각종 Resource들을 요청하고 할당 받을 수 있는 개체  PCB(Process Control Block)을 할당 받은 개체  능동적인 개체 (Activity entity) : Resource를 요구, 할당, 반납한다.PCB란? (나중에 살펴보기로 함)  Kernel space 내에 존재  각 Process들의 정보를 관리프로세스의 종류 (Type of Process)역할에 따라서  Kernel Process          모든 시스템 메모리와 Processor의 명령에 Access할 수 있는 프로세스        User Process          사용자 코드를 수행하는 Process      그리고 병행 수행 방법에 따라서  Independent Process          다른 Process에 영향을 주지않고, 영향을 받지 않으면서 수행하는 병행 프로세스        Cooperating Process          영향을 주고, 받는 병행 프로세스      Definition of Resource: Kernel의 관리하에 Process에 할당/반납 되는 Passive entity  H/W resources          Processor, Memory, Disk …        S/W resources          Message, signal, files, code …      PCB(Process Control Block): Process를 control하기 위해 필요한 정보들을 모아논 Block  Process 생성 시에 PCB가 생성된다.  OS가 Process 관리에 필요한 정보 저장이 PCB는 Kernel이 관리하는 영역에 저장이 됨.(Kernel이 Process를 관리하니까 당연..)PCB가 관리하는 정보  PID : Process Identification Number(프로세스 고유 식별 번호)  스케줄링 정보  프로세스 상태          자원 할당, 요청 정보 등        메모리 관리 정보  입출력 상태 정보  문맥 저장 영역 (Context save area)          Process의 레지스터 상태를 저장?        계정 정보          이 프로세스가 누구껀지에 대해서      PCB는 OS별로 다르고, PCB 참조 및 갱신 속도가 OS의 성능을 결정짓는 중요한 요소 중 하나Process StatusProcess : Resource간의 상호작용에 의해 결정프로세스들이 시스템에 등록되면 거쳐가는 상태를 짤라서 살펴보면,  Created State      어떤 Job이 Kernel에 등록된, 그래서 프로세스가 최초로 생성된 상태    Job을 Kernel에 등록  PCB 할당 및 Process 생성  이제 기로에 서게 됨 (가용 메모리 공간이 있는곳으로 감)          Ready or Suspended ready (메모리가 있으면 Ready, 없으면 Suspended ready)        Ready State로 먼저 가보자      Processor 외에 다른 모든 Resource를 할당 받은 상태    Processor 할당 대기 상태 (CPU를 기다리고있는 상태)  즉시 실행 가능 상태  CPU를 할당받으면(Dispatch 되면) Running state가 된다.      필요한 Resource 다 할당받고,열심히 Job을 실행하는 상태  Running State를 벗어나는 두가지 경우  Processor를 뻇겨서 Ready로 돌아가는 경우 (Preemption == Timer run-out)          Processor 스케줄링에 의해서! Running state -&gt; Ready state        I/O를 기다리고 있는 경우 (Block/Sleep)          Running state -&gt; Asleep state      I/O를 하려고 Asleep state로 갔다고 했을 때..내가 아까 일하고있었다고 해서 새치기하면 안되는거니까,Wakeup(Asleep state -&gt; Ready state) 하고 Ready state로 다시 가서 Dispatch(Schedule) 되서 Running state로 간다.  Job이 들어와서 Process가 생성, 메모리가 할당을 받아서 Ready state가 된다.  기다렸다가 Processor 할당받으면 Running state가 된다. (Dispatch)  I/O 기다리면서 Asleep state로 대기한다. (Block/Sleep)  Ready state로 다시 돌아가서 다시 일한다. (Wakeup)Create state에서 Ready state로 갔을때의 과정!  Suspended State      메모리를 할당받지 못한(빼앗긴) 상태    Suspended ready  Suspended blocked (Asleep state로 있다가 Memory까지 빼앗겨버린 상태)  Swap-out, Swap-inSuspended state인 경우, 그동안 어디까지 했는지는 저장을 해야한다.-&gt; Memory image로 Swap device에 보관. (Swap-out)-&gt; Memory image를 다시 메모리에 올리는 것. (Swap-in)  Terminated/Zombie State      프로세스가 일 다하고 끝난 상태        모든 Resource 반납후에 terminated state가 된다. (Exit)    -&gt; Kernel 내에 일부 PCB 정보만 남아 있는 상태인데, 이후 프로세스 관리를 위해 정보를 수집한다.  수집이 끝나면, 프로세스가 소멸된다.Process 관리를 위한 자료구조Ready QueueI/O QueueDevice QueueAsleep state의 경우 Processor 외의 다른 Resource들을 요청하는 것이다.-&gt; Resource별로 Queue를 따로 관리한다.일단 이런 구조가 있다라고만 알고있도록 하자.인터럽트 (Interrupt): 예상치 못한, 외부에서 발생한 이벤트 (Unexpected, External events)Interrupt의 종류  I/O interrupt (언제 어떤 키보드를 누르고, 마우스로 클릭할지 모름)  Clock interrupt  Console interrupt  Program check interrupt  Machine check interrupt  Inter-process interrupt  System call interruptInterrupt 처리 과정  Interrupt가 발생 (공부하고 있는데 친구가 옆에서 쿡 찌름)  Kernel이 개입해서 프로세스 중단 (하던 공부를 중지하고 반응함)  Interrupt handling          Interrupt handling (발생장소, 원인파악 후에 인터럽트 서비스 할 것인지 결정)      Interrupt service (행동을 취함)      ex) Process “Pi”가 실행중  interrupt 발생  Kernel이 개입해서 Context saving(책갈피 느낌)해서  PCB에 저장한다.  Interrupt handling (이 interrupt를 처리하기에 어떤 service로 처리할지)  Interrupt service process가 들어와서 실행된다.  Ready 상태에 있던 다른 프로세스들 중 하나를 넣어주게 된다. (Pi 일수도 있고 다른 프로세스 일 수도 있고)          Pj가 들어왔을때, PCB로 부터 하던일 복구하고 자기일을 다시 수행한다.      Context Switching (문맥 교환)  Context      프로세스와 관련된 정보들의 집합, 이 정보는 두군데에 저장한다.    CPU register context -&gt; in CPU          CPU는 자기가 작업할 것들을 Register에 올려놓고 작업을 한다.        Code &amp; data, Stack, PCB -&gt; in memory  Context saving      CPU 안에 있던 현재 Process의 Register context를 Memory에 저장하는 작업    Context restoring      Register context를 프로세스로 복구하는 작업 (다시 Register로 올림)    Context switching (Process switching)      실행중인 프로세스의 Context를 저장하고, 앞으로 실행 할 프로세스의 Context를 복구 하는 일    Kernel의 개입으로 이루어진다. (scheduling)Context Switch Overhead컴퓨터안에는 프로세스가 많고, 자주 switch 되는데,불필요한 Context switching을 줄이는것이 중요하다.-&gt; Thread (다음 강의에서 계속)]]></content>
      <categories>
        
          <category> OS </category>
        
      </categories>
      <tags>
        
          <tag> OS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Data Structure week4]]></title>
      <url>/data%20structure/2020/03/30/Data_Structure_week4-post/</url>
      <content type="text"><![CDATA[Data Structure Week 4KAIST 산업및시스템공학과 문일철 교수님의데이터 구조 및 분석: Linear Structure and Dynamic Programmingedwith 강의를 보고 정리한 내용입니다.Weekly ObjectivesThis week, we learn how to program recursive routines and dynamic programming concepts.  Recursion  Dynamic programmingObjectives are  Understanding the concept of recursions          Repeating problems      Divide and conquer      Recursion function call      Recursion escape      Recursion depth        Able to implement recursive programs  Understanding the concept of dynamic programming          Reusing previous function call result (재활용으로 실행시간을 빠르게)      Memorization for time saving      Repeating Problems and Divide and Conquer​                                                                    회사체계 Diagram  graph TD  A["회사"] --&gt; |150| B["인사부"]  A --&gt; |300| C["영업부"]  A --&gt; |150| D["개발부"]  C --&gt; |100| E("서울점")  C --&gt; |100| F("인천점")  C --&gt; |100| H("부천점")ex) 내가 CEO이고, 각 부서에 필요한 돈을 내려주면,자연스럽게 계층적인 구조가 된다. 돈의 분배가 반복적으로 일어난다. (Repeating Problems)이때 돈의 양은 아래계층으로 내려가면서 줄어든다. (Divide)  Repeating Problem란?      Problem이 반복해서 일어난다. (이름그대로)    Divide and Conquer란?      문제를 쪼개서 문제를 해결해나가는 과정  # Pseudo codeclass Department:    dept = ["sales", "manu", "randd"]    def calculateBudget(self):        sum = 0        for itr in range(0, numDepartments):            sum = sum + dept[itr].calculateBudget()        return sumcalculateBudget function 안을 보면,동일한 calculateBudget function를 호출하고 있다.무작정 함수안에서 그 함수를 또 call하는 형태로 만들었다고 해서 Recursion이라고 하지않는다.포인트는 반복하는 과정에서 scale이 더 작아진 Parameter가 들어온다는 것이다.이것을 바로 Recursion이라고 하고, (Divide된 작은 문제로 동일한 함수를 call)Recursion의 컨셉이 바로 Divide and Conquer이라고 한다.More examplesRepeating Problem의 예제를 더 알아보자.FactorialGreat Common Divisor최대공약수를 구하는 방법중 하나가 Euclid’s algorithm이 있음.GCD(A, B) = GCD(B, A mod B)GCD(A, 0) = A예를 들어서GCD(32, 24)= GCD(24, 8)= GCD(8, 0) = 8 이 바로 GCD!def Euclidean(a, b):    r = a % b    if r != 0:        r = a % b        return Euclidean(b, r)    else:        return b공통점  Function call이 반복된다.  Parameter size는 줄어든다.  Mathematical induction (Reverse Mathmatical Indunction..?)과 유사하더라.Self-Similar 한것이 반복적으로 일어난다.다만 Size는 줄어든 상태로!Definition of Recursion: A programming method to handle the repeating items in a self-similar wayFunction call 속에서 또 function을 반복적으로 call하는 형식.# Pseudo codedef functionA(target):    ---    functionA(target prime) // target의 size가 줄어듬    ---    if (escapeCondition):        return A;Fibonacci sequence(피보나치 수열)을 표현한 실제 코드를 보면,위에서 말했던 것 처럼, Function안에서 Function call이 일어나고 있고,Parameter size는 n에서 n-1, n-2로 줄어들었다.def Fibonacci(n):    # escape routine    if n == 0:        return 0    if n == 1:        return 1        # Recursion with smaller size parameter    intRet = Fibonacci(n-1) + Fibonacci(n-2)    return intRetfor itr in range(0, 10):    print(Fibonacci(itr))Recursions and StackframeRecursion 할 때 컴퓨터 내부에서는 어떻게 처리하고 있을지 살펴보자.  Recursion of function은 컴퓨터 내부에서 Increase the items in the Stackframe      Stackframe은 Function call의 역사를 기록하고 있는 “Stack” (LIFO, Last In First Out)  Stack의 Operation은 Push, Pop (Top에서만 이루어졌던거 기억하기!)Stackframe 에서도 마찬가지로,  Push : When a function is invoked (Function call이 일어나면 push)  Pop : When a function hits return or ends (Function이 return되면 pop)What to store?Local variables 과 Function call parameters를 저장함  Local variables : Function속에서만 접근이 가능한 변수.  Function call parameters : 특정 Function call instance에 할당된 Parameter.          ex) F(4)에서 4가 Function call parameter!      흘러가는 모양을 Stack으로 표현을 해보면..이런식으로 흘러가게 된다.(그림을 mermaid로 이쁘게 넣고 싶었는데 사이즈 조절을 못하겠네요 ㅠㅠ)Merge Sort: 다양한 Sorting 방법중에, Recursion을 이용한 Sorting Algorithm이다.기본적인 원리는LIst를 더 작은 사이즈로 계속해서 쪼개고,더 쪼개질 수 없을 때 List안의 값을 비교하면서 순서에 맞게 다시 리스트를 합쳐나가는 것이다.  Decompose into two smaller lists  Aggregate to one larger and sorted list긴 리스트를 Decompose 해가면서 쪼갠다.Aggregate는 두개의 리스트를 합쳐나가는데,  작은 것을 앞에쓰고, 큰것을 뒤에 쓰면서 sorting함(행렬곱의 순서와 똑같이 비교한다.)결국 MergeSort는 재귀적으로 하위의 더 작아진 List에서연속적으로 Function call이 이루어져서 나온 return들을 합친것을 최종 return으로 받게 됨Implementation Example: Merge Sortimport randomdef performMergeSort(lstElementToSort):    # Escape routine    if len(lstElementToSort) == 1:        return lstElementToSort        # Decomposition    lstSubElementToSort1 = []    lstSubElementToSort2 = []    for itr in range(len(lstElementToSort)):        if len(lstElementToSort)/2 &gt; itr:            lstSubElementToSort1.append(lstElementToSort[itr])        else:            lstSubElementToSort2.append(lstElementToSort[itr])        # Recursion, 여기서 List가 전부 쪼개진 형태가 됨    lstSubElementToSort1 = performMergeSort(lstSubElementToSort1)    lstSubElementToSort2 = performMergeSort(lstSubElementToSort2)        idxCount1 = 0    idxCount2 = 0    for itr in range(len(lstElementToSort)):        # 한쪽에 있는 element가 다 lstElementToSort로 들어갔을때를 대비        if idxCount1 == len(lstSubElementToSort1):            lstElementToSort[itr] = lstSubElementToSort2[idxCount2]            idxCount2 += 1        elif idxCount2 == len(lstSubElementToSort2):            lstElementToSort[itr] = lstSubElementToSort1[idxCount1]            idxCount1 += 1        # 본격 값 비교 if statement        elif lstSubElementToSort1[idxCount1] &gt; lstSubElementToSort2[idxCount2]:            lstElementToSort[itr] = lstSubElementToSort2[idxCount2]            idxCount2 += 1        else:            lstElementToSort[itr] = lstSubElementToSort1[idxCount1]            idxCount1 += 1    return lstElementToSort    lstRandom = []for itr in range(0, 10):    lstRandom.append(random.randrange(0,100))print(lstRandom)lstSorted = performMergeSort(lstRandom)print(lstSorted)이렇게 작성하면 된다.뒤에서 하게 될 Dynamic Programming 방식으로도  Merge Sort를 짤 수 있을까 싶어서 찾아봤는데,Merge Sort를 Dynamic Programming방식으로 짜는건 알맞지 않다.그 이유는 Merge Sort에는 Overlapping되는 sub-instance가 없기 떄문이다!-&gt; 이전에 이미 계산했던 instance와 같은 값을 가진 instance를 Re-use할 일이 없다는 뜻!​    (물론 Merge sort할 List안에 중복되는 값이 있을 수는 있지만, 그 값을 재사용 할 일은 없다.)자세한 설명은 이곳을 확인 (영어주의)Problems in Recursions of Fibonacci SequenceRecursion의 문제점은 Function call이 너무 많다는것심지어 동일한 Parameter를 가지고있는 function call이라서,같은 값을 가지는 녀석들을 불필요하게 반복하게 됨Dynamic Programming은 이러한 문제점을 해결할 수 있는 방법이다.-&gt; Unnecessary한 function call을 줄일 수 있다.  어떻게?      결과값을 기록해두면 된다.  Dynamic Programming: A general algorithm design technique for solving problems defined by or formulated as recurrences with overlapping sub-instances (overlapping sub-instance가 있는 형태의 recurrence을 푸는 방식)overlapping sub-instance (중복된 값이 여러번 나오는 걸 의미한다.)-&gt; 중복되는 하위 값들Main storyline (recurrence structure를 거꾸로 만드는 스토리라인)  Setting up a recurrence  Small Instance를 Solve한다.  Local variable로 받아서 그때그때 쓰는게 아니라, Instance의 return에 대한 값을 table에 record한다.  Extract a solution of a larger instance from the table-&gt; F(4) 를 풀기위해 F(1), F(2), F(3)을 먼저 계산해서 기록해두는것Memoization (Memorization 아님)Dynamic Programming의 핵심은 무엇일까? (Recursion과의 차이점은?)  Storing the result of previous function calls (다시 사용하기 위해서)이전 결과를 저장하는 공간을 Memoization이라고 한다.Memoization와 이전에 나왔던 Stackframe에는 철학적인 차이가 있음  More philosophical sense          Recursion : Top-down of divide and conquer (위에서 아래로 나누어서 계산하고)                  풀려고하는 것을 먼저시도를 하다가 어쩔수없이 recursion 느낌?          stackframe을 이용한 top-down 방식                    Dynamic programming : Bottom-up of storing and building (아래서부터 계산하여 올라가는 방식)                  memoization table을 이용한 bottom-up 방식                    sub-instance가 많다고 할 경우 Dynamic programming을 이용해서 푸는게 좋음Implementation Example: Fibonacci Sequence in DPRecursion과 다르게 Function속에 다시 같은 Function call하는 코드는 필요 없다.대신, 결과를 쌓을(저장할) Table(memoization)은 있어야함def FibonacciDP(n):    dicFibonacci = {}    dicFibonacci[0] = 0    dicFibonacci[1] = 1    for itr in range(2, n+1):        dicFibonacci[itr] = dicFibonacci[itr-1] + dicFibonacci[itr-2]    return dicFibonacci[n]for itr in range(0, 10):    print(FibonacciDP(itr))(Memoization을 만들때는 Dictionary collection variable type을 쓰는게 좋다.)  Storing a Fibonacci number for a particular index시간복잡도(7주차에 배울 예정)을 비교해보면      We have a new space requirement, the dictionary or the table, of O(N)    (나중에 배울거임, 최대얼마만큼 커질수 있느냐? 라는 한계를 나타내는 Big-O notation이라는거)        We have reduced execution time from O(2^n) to O(N)  Recursion을 활용했을때 시간복잡도가 O(2^n)이었던것이,Dynamic Programming일때  O(N)으로 줄어듬Assembly Line SchedulingDynamic Programming의 예시ex) 자동차 공장  여러가지 공정을 Station단위로 나눴다.  Station들로 구성된 Line들이 여러개이다.  각각의 Station마다 소요시간이 다르다.  기계가 고장나는것을 대비하여 옆라인으로 이동할 수도 있다고 한다.(이동하는것은 추가시간이 필요하다.)어느 Line으로 넣어주어야 생산품이 더 빨리 나올것이냐에 대해서 생각해보아야함어떤 방법이 생산품이 더 빠르게 나올지를 알기위해Dynamic Programming을 사용한다.Key point는 Bottom-up 이라는것  (Stackframe은 Top-down)Process of Assembly Line SchedulingTable에 이전의 결과를 기록함으로써,적은수의 Function call으로도 Problem의 boundary를  확장해나갈수있다. (문제를 growth)Assembly Line Scheduling 예시에서는 Memoization table 두개를 사용      Minimum Travel Time (어떤 Station에 도착하는 최단시간을 기록한다.)          앞에서 기록해둔 Time들로 뒤에 것들을 쉽게 계산해낼수 있는것            Retrace Table (바로 직전 어떤경로를 통해서 여기까지 오게되었는지 기록한다.)                  어디서 받는것이 최고로 좋은지 적어놓는 Table        Retrace Table을 이용해서 역추적하여 최적의 경로를 알 수 있음.            Implementation Example: Assembly Line Scheduling in Recursion먼저 Assembly Line Scheduling을 Recursion을 이용해서 짠다.Recursion을 code로 짤때 가장먼저 생각할거 : Escape routineRecursion 방식으로 짠 Assembly Line Scheduling code(교수님이 반드시 직접 타이핑해서 짜보라고 하셨음.)# Top-downclass AssemblyLines:    timeStation = [[7,9,3,4,8,4], [8,5,6,4,5,7]]    timeBelt = [[2,2,3,1,3,4,3], [4,2,1,2,2,1,2]]    intCount = 0    def Scheduling(self, idxLine, idxStation):        '''        idxLine : This indicates which Line is it.        idxStation : This indicates the number of stations.        '''        print("Line, Station :", idxLine, idxStation, "recursion calls :", self.intCount)        self.intCount = self.intCount + 1                # Escape routine        if idxStation == 0:            if idxLine == 1:                return self.timeBelt[0][0] + self.timeStation[0][0]            elif idxLine == 2:                return self.timeBelt[1][0] + self.timeStation[1][0]                # Recursive call        '''        costLine1 : When it doesn't go across Lines.        costLine2 : When it goes across Lines.         '''        if idxLine == 1:            costLine1 =             	self.Scheduling(1, idxStation-1) + self.timeStation[0][idxStation]            costLine2 =             	self.Scheduling(1, idxStation-1) + self.timeStation[0][idxStation] + self.timeBelt[1][idxStation]        elif idxLine == 2:            costLine1 =             	self.Scheduling(2, idxStation-1) + self.timeStation[1][idxStation]            costLine2 =             	self.Scheduling(2, idxStation-1) + self.timeStation[1][idxStation] + self.timeBelt[0][idxStation]                # Compare which one takes less time.        if costLine1 &gt; costLine2 :            return costLine2        else:            return costLine1            def startScheduling(self):        numStation = len(self.timeStation[0])        costLine1 = self.Scheduling(1, numStation - 1) + self.timeBelt[0][numStation]        costLine2 = self.Scheduling(2, numStation - 1) + self.timeBelt[1][numStation]        if costLine1 &gt; costLine2 :            return costLine2        else:            return costLine1   Implementation Example: Assembly Line Scheduling in DP이번에는 Dynamic Programming 방식으로 짠 Assembly Line Scheduling code이다.언뜻 보면 Recursion보다 더 복잡해보이지만, 프로그램을 실행하는 입장에서는 더 간단함.(Recursion으로 짜면 보는 입장에서 직관적으로 볼 수 있다는 장점이 있다.)# 프로그램을 실행하는 입장에서 더 간단함# Bottom-upclass AssemblyLines:    '''    timeScheduling : Travel time table    stationTracing : Retrace table    '''    timeStation = [[7,9,3,4,8,4], [8,5,6,4,5,7]]    timeBelt = [[2,2,3,1,3,4,3], [4,2,1,2,2,1,2]]    # Assign memoization tables    timeScheduling = [list(range(6)), list(range(6))]    stationTracing = [list(range(6)), list(range(6))]    def startSchedulingDP(self):        numStation = len(self.timeStation[0])        # Memoization tables의 초기값 설정        self.timeScheduling[0][0] = self.timeStation[0][0] + self.timeBelt[0][0]        self.timeScheduling[1][0] = self.timeStation[1][0] + self.timeBelt[1][0]                for itr in range(1,numStation):            '''            어떤 Station에서 그 다음 Station으로 갈 때,            다른 Line에서 오는게 빠른지,            아니면 기존 Line에서 오는게 빠른지 비교 후, 더 빠른쪽을 더해줌.            '''              if self.timeScheduling[0][itr-1] &gt; self.timeScheduling[1][itr-1] + self.timeBelt[1][itr-1]:                self.timeScheduling[0][itr] =                 	self.timeStation[1][itr] + self.timeBelt[1][itr] + self.timeScheduling[1][itr-1]                self.stationTracing[0][itr] = 1            else :                self.timeScheduling[0][itr] =                 	self.timeStation[0][itr] + self.timeScheduling[0][itr-1]                self.stationTracing[0][itr] = 0                            if self.timeScheduling[1][itr-1] &gt; self.timeScheduling[0][itr-1] + self.timeBelt[0][itr-1]:                self.timeScheduling[1][itr] =                 	self.timeStation[1][itr] + self.timeBelt[0][itr] + self.timeScheduling[0][itr-1]                self.stationTracing[1][itr] = 0            else :                self.timeScheduling[0][itr] =                 	self.timeStation[1][itr] + self.timeScheduling[1][itr-1]                self.stationTracing[1][itr] = 1                costLine1 = self.timeScheduling[0][numStation-1] + self.timeBelt[0][numStation]        costLine2 = self.timeScheduling[1][numStation-1] + self.timeBelt[1][numStation]                # 마지막 Retracing table element 출력을 위한 조건문        if costLine1 &gt; costLine2 :            return costLine2, 1        else:            return costLine1, 0            def printTracing(self, lineTracing):        numStation = len(self.timeStation[0])        print("Line :", lineTracing, "Station :", numStation)        for itr in range(numStation-1, 0, -1):            lineTracing = self.stationTracing[lineTracing][itr]            print("Line :", lineTracing, "Station :", itr)DetailsEuclid’s algorithmMathematical inductionjjycjn’s Math Storehouse 블로그 참고      P(2)가 참이다.        P(n)이 참이면 P(2n)도 참이다.        P(n)이 참이면 P(n−1)도 참이다.  Fibonacci SequenceSUNGHWAN PARK님 블로그 참고피보나치 수열의 0번째 항은 0, 1번째 항은 1, 그 외 항은 Fibo(n-1)과 Fibo(n-2)의 합으로 표현된다. 피보나치 수열을 구하는 데에는 다양한 알고리즘이 있다.  위에서 했던 재귀적 풀이  Loop문을 이용한 반복적 풀이  Dynamic 계획법을 이용한 풀이]]></content>
      <categories>
        
          <category> Data Structure </category>
        
      </categories>
      <tags>
        
          <tag> Data Structure </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[OS Lecture 2]]></title>
      <url>/os/2020/03/28/OS2-post/</url>
      <content type="text"><![CDATA[유튜브 HPC Lab. KOREATECH 채널, 김덕수 교수님의 OS 강의를 보고 정리한 내용입니다.Lecture2OS Overview운영체제의 역할  User Interface (편리성)          CUI (Character user interface)      GUI (Graphical user interface)      EUCI (End-User Comfortable interface)        Resource Management (효율성)          HW resource      SW resource            Process and Thread management (Process는 “실행주체”, Thread는 가벼운 Process)    System management (시스템 보호)컴퓨터 시스템의 구성Hardware위에 OS가 존재하고 그 위에 Software와 Application들..운영체제의 핵심은 Kernel (뒤로가서 자세히 보신다고 함)  System Call Interface      사용자가 kernel을 마음대로 조작해버리면 문제를 일으킬 수 있으니까,    필요한 기능이 있으면 OS에 요청하는 통로  혹은 kernel이 할 수 있는 기능중에서 사용자가 쓸 수 있는걸 모아둔 것이다.운영체제의 구분동시 사용자 수      혼자 씀 (한명의 사용자가 모든 시스템 자원을 독점한다.)          ex) Window 7/10 , Android…)            동시에 여러명이서 씀 (자원들에 대한 소유 권한 관리가 필요하다.)          ex) Unix, Linux…        -&gt; 동시에 쓰는건 기본적으로 Multi-tasking 기능이 필요하다.  동시 실행 프로세스 수      Single-tasking system (단일작업, 한번에 하나의 프로세스만 존재,          ex) MS-DOS        -&gt; 하나가 끝나야 다음 것을 실행할 수 있다.        Multi-tasking system (다중작업, 작업들 사이의 동시 수행, 동기화 등을 관리해야한다.)          ex) Unix/Linux..      작업 수행 방식      순차 처리    옛날에는 OS가 존재하지 않았기 때문에, 기계어로 프로그램을 직접 작성했어야했다.    하드웨어 관리를 OS가 아니라 직접해야했기 때문에 하드웨어에 대한 이해또한 필요했다.    -&gt; 실행하는 작업에 대한 각각의 준비 시간이 소요된다.        Batch Systems          중앙에서 작업을 모아서 한번에 일괄처리 - &gt; 준비시간을 줄여준다.      시스템 지향적 (System-oriented)      장점                  시스템 자원 공유          처리효율(Throughput) 향상                    단점                  같은 유형의 작업들이 모이기를 기다려야 함 -&gt; 긴 응답시간                          Time Sharing Sytems (시분할 시스템)    : 시간을 나눠서 여러 프로그램을 나눠서 조금씩 사용하는 시스템          시스템 자원 공유      사용자 지향적 (User-oriented)      여러명이서 같이 쓰려고하다보니 파일 시스템 및 가상 메모리 관리가 필요하다.      장점                  응답시간 단축          생산성 향상                    단점                  통신 비용 증가, 보안문제가 있음 (단말기로 접속하니까)          사용자 수가 증가하면 속도가 저하된다.                          Personal Computing    : 개인이 시스템을 전체 독점해서 사용하는 방식                  앞에 시스템들은 cpu를 쉬지않고 돌려서 활용률을 높이려고 했지만,        Personal Computing에서는 고려 대상이 아님                    OS가 상대적으로 단순                  But, 사용자의 편리성을 높여주는 다양한 기능들이 많다.                            장점                  빠르다.                            단점                  혼자 사서 써야되서 성능이 낮음                          Parallel Processing Systems (병렬처리시스템)          단일 시스템 내에서 둘 이상의 Processor 사용 (ex) CPU 여러개)      메모리 등의 자원 공유 (Tightly-coupled system)      사용 목적                  성능향상          Tolerence 보장                    프로세서간 관계 및 역할 관리 필요하다.      확장하는데 한계가 있다.            Distributed Processing Systems (분산처리시스템)    : 네트워크를 기반으로 구축된 병렬처리 시스템          물리적인 통신망을 이용해서 연결      분산운영체제를 통해 하나의 프로그램, 자원처럼 사용가능      Cluster system, client-server system      장점                  자원 공유 -&gt; 높은 성능          Fault tolerence                    단점                  구축 및 관리가 어렵다.                          Real-time Systems    : 작업 처리에 제한 시간을 가지는 시스템 (제한 시간 내에 서비스를 제공하는것이 자원 활용 효율보다 중요!)          Task의 종류                  Hard real-time task                          발전소, 무기제어                                Soft real-time task                          동영상 재생                                Non real-time task                    운영체제의 구조 (OS Structure)커널 (Kernel): OS의 알맹이  OS의 핵심 부분 (메모리 상주)          가장 빈번하게 사용되는 기능들 담당한다.                  ex) processor, memory 등등..                      동의어로는 핵(neucleus), 관리자(Supervisor), 상주 프로그램(Resident program)이 있다.유틸리티 (Utility): 운영체제에서 커널을 제외한 나머지 부분에 있는 것들이다.  비상주 프로그램 (메모리에 항상 올라와있지는 않다.)  UI등 서비스 프로그램안쪽부터하드웨어 - Kernel - system calls - utilities 까지가 OS (동심원을 생각)단일구조 (Single structure): 운영체제의 기능을 하나의 거대한 커널로 모아놓은 구조ex) main 함수안에 다 넣어서 만든 프로그램.  장점          커널 내 모듈간 직접 통신 가능 -&gt; 빠르다        단점          Kernel의 거대화 -&gt; 추가 기능 구현, 유지보수가 어렵다.      한 모듈의 문제가 전체 시스템에 영향을 준다.      계층구조 (hierarchy)  장점          모듈화 (Modulization)                  각각의 기능에만 집중하면 됨 -&gt; 단순화                      단점          단일 구조에 비해 상대적으로 성능 저하                  원하는 기능 수행을 하기 위해서는 여러 계층을 거쳐야 하기 때문이다.                    마이크로 커널구조 (Microkernel Structure): Kernel의 크기 최소화  필수 기능만 포함한다.  기타 기능은 사용자 영역에서 수행한다.운영체제의 기능 (OS features): 관리를 총괄한다.Process Management  프로세스(Process)          프로세스는 커널에 등록된 실행 단위 (실행중인 프로그램)      프로그램 수행 주체 (entity)        OS의 프로세스 관리 기능          생성/삭제, 상태관리      자원 할당      프로세스 간 통신 및 동기화 (Synchronization)      교착상태(Deadlock) 해결        프로세스 정보 관리          PCB (Process Control Block)      Processor Management  CPU (Central Processing Unit)  Process Scheduling -&gt; 처리 순서 결정  Processor 할당 관리          Process들에 대한 Processor 할당 관리      Memory Management: 주기억장치 (Computer memory)  Multi-user, Multi tasking 시스템          메모리 할당 및 회수      메모리 여유 공간 관리      메모리 영역 접근 보호        메모리 할당 방법 (scheme)          전체 적재      일부 적재      이 부분은 뒤에가서 자세히 다루신다고 합니다.File Management파일 : 논리적인 데이터의 저장 단위  사용자 및 시스템의 파일 관리(생성/삭제, 백업 등등..)  Directory 구조 지원I/O Management: 입출력 처리장치에서 운영체제를 거쳐서 프로세서로 보낸다.이 외에도 하는 일은 굉장히 많지만ex) 디스크, 네트워크, 보안 등등..일단 큰그림만 그려보기로!]]></content>
      <categories>
        
          <category> OS </category>
        
      </categories>
      <tags>
        
          <tag> OS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[OS Lecture 1]]></title>
      <url>/os/2020/03/28/OS1-post/</url>
      <content type="text"><![CDATA[유튜브 HPC Lab. KOREATECH 채널, 김덕수 교수님의 OS 강의를 보고 정리한 내용입니다.Lecture 1Computer Hardware  Processor          CPU,  GPU…        Memory          주기억장치, 보조기억장치        주변장치          키보드, 마우스, 모니터, 프린터, 모뎀 등등..      Processor: 컴퓨터의 두뇌 (CPU)  연산 수행  컴퓨터의 모든 장치의 동작 제어장치 안을 들여다보면,Register, Control Unit, ALU (나중에 자세히!)Processor의 동작  ALU (Arithmetic logic unit)      계산하는 연산장치  ALU가 중간에 있고, 다양한 Register를 통해서 연산이 이루어진다.(Control unit에 대해서는 나중에..)운영체제의 역할은 프로세서를 관리하는것을 포함한다.(작업 할당 및 관리)Register프로세서 내부에 있는 메모리-&gt; 컴퓨터에서 가장 빠른 메모리Register의 종류  용도에 따른 분류          전용 레지스터, 범용 레지스터        사용자가 변경 할 수 있는지 여부          사용자 가시 레지스터, 사용자 불가시 레지스터        저장하는 정보에 따른 분류          데이터 레지스터, 주소 레지스터,…      명령어들이 Line by Line으로 되어있으면다음에 실행 할 명령어의 주소를 보관하는 Register-&gt; Program counter현재 실행 할 명령어를 보관하는 Register-&gt; Instruction Register계산하는 과정에서 어떤 값을 일시적으로 저장한 Register-&gt;  ACCumulatorMemory데이터를 저장하는 장치 (기억장치)  프로그램, 사용자 데이터 등등..메모리의 종류  Register(가장 빠른 메모리)  Cache (CPU)  Main Memory(주기억장치, DRAM)  Secondary Memory(보조기억장치, HDD)아래로 갈수록 가격은 싸고 용량은 크고, 위로 갈수록 용량은 작고 가격은 비싸고, 빠르다.1,2,3은 Processer(CPU)가 프로그램과 데이터에 직접 접근이 가능하다.4는 프로그램과 데이터를 Main memory로 옮겨야 접근이 가능하다.Main Memory: 프로세서가 수행할 프로그램과 데이터 저장한다. (반드시)Processor는 디스크에 곧바로 Access하지 못한다. (하드웨어적인 관점)CPU 속도는 급속히 빨라졌는데 메모리는 더디다.-&gt; 속도 차이 문제 해결을 위해 Main Memory를 사용한다.(병목현상 해소)  CPU보다 용량은 크고, 가격은 저렴하다.Cache프로세서 내부에 있는 메모리(L1, L2 캐시 등)이번에는 메모리와 CPU의 속도차이 문제를 해결하기 위해 사용한다.(병목현상 해소)크기가 무진장 작다.Cache의 동작Register랑 마찬가지로 CPU안에 있다.Register와의 차이점 : Register는 Core에 더 가까이 있다.-&gt; Register보다 느리고 Main memory보다 빠르다.먼저 Cache로 가서 원하는 데이터가 있는지 물어보고,없으면(Cache miss) 메인메모리로 가서 그 데이터를 cache로 가지고 들어와서, 프로세서에 전달한다.있으면 (Cache hit) 프로세서에 바로 전달한다.Cache 가 효과를 낼 수 있는 이유Locality  Spatial locality(공간적 지역성)          한번 참조한 주소에 인접한 주소를 참조할 가능성이 높다라는 특징이 있다.        Temporal locality(시간적 지역성)          한번 참조한 주소를 곧 다시 참조할 가능성이 높다라는 특징이 있다. ex) for loop      Locality는 Cache hit ratio와 밀접하다.-&gt; 알고리즘 성능 향상을 위한 중요한 요소 중 하나..캐시라는것은 데이터를 읽으면 딱 그것만 데려오는건 아니다.Cache Line or Cache block의 크기만큼 가져오게 된다.Auxiliary memory:  보조기억장치 (하드디스크, usb, cd, sd카드)프로세서가 직접 접근할 수 없다.메모리에 올려놓고 사용해야한다.하지만 실행하려는 프로그램이 20GB인데 Memory가 8GB밖에 안된다면?-&gt; 가상메모리(하드디스크를 메모리처럼 활용하는것)를 사용한다.System Bus하드웨어들이 데이터 및 신호를 주고 받는 물리적인 통로  제어 버스  주소 버스  데이터 버스]]></content>
      <categories>
        
          <category> OS </category>
        
      </categories>
      <tags>
        
          <tag> OS </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Data Structure week3]]></title>
      <url>/data%20structure/2020/03/25/Data_structure_week3-post/</url>
      <content type="text"><![CDATA[Data Structure Week 3KAIST 산업및시스템공학과 문일철 교수님의데이터 구조 및 분석: Linear Structure and Dynamic Programmingedwith 강의를 보고 정리한 내용입니다.Weekly ObjectivesThis week, we learn the first set of data structures: Linked list, stack, and queue.Objectives are  Understanding the definition of abstract data types  Firmly understanding how references work  Understanding various linked list, stack, and queue structure          Singly linked list, doubly linked list, circular linked list..      Able to implement a stack and a queue with a list        Understanding the procedures of linked list, stack, and queue management          Insert, delete, search…      Should be able to estimate the number of steps for inserts, deletes, and searches.      ==References structure는 정확히 알고 있어야 함!!==Array for ListList는 왜 사용할까?ex)학교 매점은 번호표가 없기 때문에 먼저 온 순서에 관계없이 목소리가 큰 사람, 팔이 긴 사람이 먼저 간식을 사가는 경우가 있다. 이런 경우 매점 안은 난장판인 경우가 많다. 하지만 은행이나 우체국처럼 번호표가 있다면, 사람들은 순서에 맞춰서 자신의 차례를 기다리면 되기 때문에, 난장판이 되지 않는다.List는 바로 번호표와 같은 역할을 한다. 각각의 element에 번호표를 부여하여 Data를 효율적으로 관리 할 수 있는것이다.  List란 Data를 구조화 된 형태로 만들 수 있는 도구Abstract Data TypesAn abstract data type( ADT ) is an abstraction of a data structureAbstraction(추상화)란?  현실에 있는 것의 느낌이라던가, 내제되있는걸 간단화해서 표현하는 것그렇다면 Data structure의 추상화란?  Store, search, insert, delete같이 데이터에 대한 operation을  있는 그대로 상세히 표현한게 아니라, 추상적으로 표현하는 것 이다.3가지를 필수적으로 표현해야한다.An ADT specifies:      Data stored (어떤 데이터가 저장되는지)        Operations on the data (그 데이터를 가지고 어떤 operation을 하는지)        Error conditions associated with operations    (예외처리는 어떻게하는지, 자리가 없는데 insert, 없는데 delete같은거)  ex) ADT modeling a simple stock trading system(주식 매매 시스템)  The data stored are buy/sell orders  The operations supported are          order buy      order sell      void cancel        Error conditions:          Buy/sell a nonexistent stock(없는 주식을 사는 경우)      cancel a nonexistent order(없는 주문을 취소하는 경우)      내부가 어떻게 되있는지는 알지 못하지만, 무슨 데이터를 가지고,어떤 operation을 사용할 것인지는 명시를 하겠다! 라고 하는것이 바로 ADTCreating a List by ArrayPython에서는 List가 Array 역할을 한다.Array  각각의 element는 index가 있어야함  index는 0부터 시작함Search Procedure in Arrayex) ‘d’와 ‘c’를 앞에서 정의한 Array에서 찾는다고 하자(Python에서는 그냥 ‘in’예약어를 쓰면 되긴하지만, index를 navigating을 연습해보자.)(From the first to the last until hit is the only way)Array의 Length만큼 retrievals를 했는데 찾으려는 Element가 없다면?-&gt; 그 element는 그 Array속에 없다.찾는 Element가 Array속에 없다는 사실을 보장하기 위해서는!저장되어있는 데이터의 개수만큼은 비교를 해봐야한다.Insert Procedure in Array==ex) ‘b’와 ‘d’ 사이에 ‘c’를 Insert==  새로운 List를 만든다. (새로운 Element가 Insert됐을때의 길이를 가진 리스트, List y)  Reference를 insert할 공간(이 공간의 index를 a라고 가정) 직전까지 copy  c의 reference를 y[a]에 넣는다.  나머지 남은 Reference들을 넣는다  List x의 reference를 List y의 reference로 바꾼다. (마지막에 x=y)  Total count of retrievals = a + 1 + n - a - 1 = n  Insert할때는 n번의 search retrievals정도가 필요하다.x = ['a', 'b', 'c', 'd', 'e', f]idxInsert = 2valInsert = 'c'y = range(6)for itr in range(0, idxInsert):	y[itr] = x[itr]y[idxInsert] = valInsertfor itr in range(idxInsert, len(x)):	y[itr+1] = x[itr]x = y	Delete Procedure in Arrayex) ‘d’를 list에서 Delete  새로운 List y를 만든다. (Element가 Delete됐을때의 길이를 가진 리스트)  Delete 하려는 Element 전까지는 동일한 값을 reference하니까 그대로 copy  Delete 하려는 Element는 놔두고, 그 다음 순서의 Element들의 reference copy  x의 reference를 y의 reference로 바꾼다.  Total count of retrievals = a + n - a - 1 = n - 1x = ['a', 'b', 'c', 'd', 'e', f]idxInsert = 2valInsert = 'c'idxDelete = 3y = range(6)for itr in range(0, idxDelete):	y[itr] = x[itr]y[idxInsert] = valInsertfor itr in range(idxDelete+1, len(x)):	y[itr-1] = x[itr]x = y	Problems in ArrayArray의 문제점은?==element를 넣거나 뺄 때, line-wise retrievals가 필요하다.==-&gt; 길면 길수록 부담이 됨.  시간 복잡도가 Data의 크기가 커지면 커질수록 같이 커진다.ex) Airline passengers한 사람이 줄에 끼어든다고 했을 때, 중간에 빈공간을 만들기위해 한칸씩 밀고 끼어들어야 함.이때 다 한칸씩 이동시키는 것은 매우 번거롭다.-&gt; insert or delete하려면 모든 element를 다 건들어야 할 수도 있다. (ㅠ_ㅠ)What-if we have a magic to create a space in the middle of the line?  Array -&gt; you are bounded to the 1-dimension that you have  Linked list -&gt; you are bounded no more!Array같이 index로 선형인 것 일 때 이런 마법은 일어날 수 없지만,마법을 부리기 위해1차원적으로 등간격으로 정의된 space에 데이터를 더이상 저장하지 않겠다!-&gt; Linked ListLinked ListIndex구조가 아닌 Reference 구조로, 중간에 공간을 만들어낼수 있는 Linked List!  Reference : 데이터의 위치를 가리키고 있는 것Reference에 대해서 다시 살펴보면,x = [1, 2, 3]y = [100, x, 200]이라고 할 때, x를 바꾸었을때, y도 같이 바뀌게 됨 왜냐면 y안에 있는 ‘x’는 ‘x’를 가리키고 있는 Reference이기 때문이다.값이 동일하다는 건 무슨 의미를 가질까?      x1과 x2에 [1,2,3]이 저장되어 있을 때 값은 같다.        하지만 저장된 곳은 다를 수 있다. -&gt; Reference가 다를 수도 있다.  Basic Structure: Singly linked listConstruct a singly linked list with nodes and referenceA node consists of  A variable to hold a reference to its next node  A variable to hold a reference to its value objectSpecial nodes: Head and Tail  You can construct the singly linked list without them  But, using them makes search, insert and delete more convenientGenerally, requires more coding than array  Node = reference to its object + reference to its next nodeHead는 리스트의 맨 처음 노드, Tail은 리스트의 맨 마지막 노드원래 Node에는 두가지 variable이 있는데, Head를 보면 object에는 저장되어 있는건 없지만, reference로 다음값을 가리키고는 있다. Tail에는 아무것도 저장되어 있지않고, Next가 없다.Implementation of Node classMember Variables  다음 노드를 가리키는 variable  value object를 hold하고 있는 variable  (선택) Head node가 있는지 없는지  (선택) Tail node가 있는지 없는지Member Functions  Various set/get methodsClass Node:    # essential	nodeNext = ''	objValue = ''    # optional	binHead = False	binTail = False	def __init__(self, objValue='', nodeNext='', binHead=False, binTail=False):		self.objValue = objValue		self.nodeNext = nodeNext		self.binHead = binHead		self.binTail = binTail	def getValue(self):		return self.objValue	def setValue(self, objValue):		return self.objValue = objValue	def getNext(self):		return self.nodeNext	def setNext(self,nodeNext):		return self.nodeNext = nodeNext	def isHead(self):		return self.binHead	def isTail(self):		return self.binTail    node1 = Node(objValue = 'a')nodeTail = Node(binTail = True)nodeHead = Node(binHead = True)Head and TailSpecial한 Node  Head : 항상 LinkedList의 맨 앞  Tail : 항상 LinkedList의 맨 뒤  These are the two corner stone showing the start and the end of the list만약 Empty Linked List라면? Head 의 reference는 Tail을 가르키고 있고,Tail Node에는 아무것도 없다.결국 Head와 Tail은 LinkedList에서 위치를 가리키기 위한 요소이다.(리스트의 범위를 알려주는 요소!) Head와 Tail없어도 구현은 가능하지만, 있는게 훨씬 convenient하다.Search procedure in singly linked listex)  ‘d’와 ‘c’를 주어진 LinkedList에서 찾아보자.First to the last 까지 검사한다.  No difference in the search pattern (기본 Array와 다른점이 없음)  index를 사용한 쉬운 접근은 불가하다.  Linked list에 있는 Next를 사용한다.방법  Find Head from the list  Find Next node          if Next==tail 이면 반복문을 break      if Next==tail 이 아니면 next.nextNode로 이동한다.      array와 마찬가지로 N번 검사를 해야지 내가 찾는 element가 있는지 없는지 알 수 있다.Insert procedure in singly linked listInsert operation이 Linked list의 Power를 볼 수 있다. 기존 Array에 경우에는 크기가 커지면 커질수록 retrievals이 많이 필요했다. 하지만 Linked list는 3개의 operation만 필요하다.  With an assumption that you have a reference to the node, Node prev that you want to put your new node next(어떤 노드 뒤에 넣고싶은지는 알고 있다라고 가정)  먼저 Node prev가 가리키고 있는 Node나 Node next를 store함.  Node prev의 nodeNext reference를 Node new로 바꾼다.  Node new의 nodeNext reference를 Node next로 바꾼다.나머지의 reference 구조는 바뀐게 없지만, insert하는 Node의 앞뒤 Node의 reference구조만 바꾸면 된다!Delete procedure in singly linked listex) ‘d’라는 것을 없앤다고 했을 때, 아까와 마찬가지로 Node_prev는 알고 있다고 가정! 아까는 Node를 하나 새로 넣어야하니까 Instantiation 했는데, Delete는 그럴필요 없고, 다음의 순서를 따른다.  삭제할 Node는 NodePrev.next 이고, NodeNext = NodePrev.next.next 이다  Reference를 Node_prev의 node_Next가 Node next를 가리키도록 바꾼다. (NodePrev.Next = NodeNext)‘d’가 사실상 없어지는것처럼 보인다. 하지만 실제로는 ‘d’를 찾아갈 reference가 없어서 찾아갈 방법이 없어지는 것이다.이렇게 된 Instance는 Garbage collector에 의해서  접근할 방법이 없는 instance를 메모리 상에서 없애버린다.Implementation of Singly linked listclass SinglyLinkedList:    nodeHead = ''    nodeTail = ''    size = 0    def __init__(self):        self.nodeTail = Node(binTail = True)        self.nodeHead = Node(binHead = True)          def insertAt(self, objInsert, idxInsert):        nodeNew = Node(objValue = objInsert)        nodePrev = self.get(idxInsert-1)        nodeNext = nodePrev.getNext()        nodePrev.setNext(nodeNew)        nodeNew.setNext(nodeNext)        self.size = self.size + 1                    def removeAt(self, idxRemove):        nodePrev = self.get(idxRemove-1)        nodeRemove = nodePrev.getNext()        nodeNext = nodeRemove.getNext()        nodePrev.setNext(nodeNext)        self.size = self.size - 1        return nodeRemove.getValue()        def get(self. idxRetrieve):        nodeReturn = self.nodeHead        for itr in range(idxRetrieve + 1):            nodeReturn = nodeReturn.getNext()        return nodeReturn        def printStatus(self):        nodeCurrent = self.nodeHead        while(nodeCurrent.getNext().isTail()==False):            nodeCurrent = nodeCurrent.getNext()            print(nodeCurrent.getValue())            def getSize(self):        return self.size        list1 = SinglyLinkedList()list1.insertAt('a', 0)list1.insertAt('b', 1)list1.insertAt('d', 2)list1.insertAt('e', 3)list1.insertAt('f', 4)list1.printStatus()list1.insertAt('c', 2)list1.printStatus()list1.removeAt(3)list1.printStatus()Stack and QueueLinked list를 활용해서 구현할 수 있는 추가적인 자료구조다.Scenario for Stack내리는 곳이 다른 여러명의 사람들이 같이 오른쪽으로만 내릴 수 있는 택시를 타고 간다고 할 때, 누가 먼저 내려야할지 안다면 택시에 탈 때 부터 미리 순서에 맞게 탈 것 이다.이렇게 데이터를 넣고 뺄 수있는 위치가 하나로 고정되어있고  처음 들어온 데이터가 가장 나중에 처리되는 데이터 구조를 Data structure를 Stack이라고 한다.  Last In First Out (LIFO)Structure of StackStack은 Linked list와 동일하게 linear하다. 어떤면에서 보면 Stack이라는것은 singly linked list의 variation이라고 봐도 된다. 하지만 Stack에서는 insert op는 없다.Difference  Voluntarily giving up          중간에 데이터들은 관리 안하겠다.      오로지 첫번째 노드만 이용해서접근하겠다. (Top Node)        The first instance in the list = The top instance in the stackAn item is inserted or removed from the stack from one end called the ‘Top’ of the stack.Stack의 이런 Mechanism을 Last-In-First-Out(LIFO)라고 한다.Operation of StackTop에서만 Operation하고, 중간영역에는 Access할 수 없다.Stack operation  Push          Insert an instance at the first      Put an instance at the top        Pop          Remove and return an instance at the first      Remove and return an instance at the top      Push와 Pop은 insert와 remove를 가지고 구현이 가능하다.Implementation of StackClass Stack(object):    lstInstance = SinglyLinkedList()    def pop(self):        return self.lstInstance.removeAt(0)    def push(self, value):        return self.lstInstance.insertAt(value,0)첫번째 위치의 것만을 access한다는 점을 이용해서 손쉽게 push와 pop을 만들 수 있다.Example: Balancing SymbolsBalancing symbols?-&gt; 프로그램에서 중괄호,소괄호,대괄호가 제대로 잘열리고 잘 닫힌 경우를 의미한다.Balancing symbols case가 아니라면? 오류가 뜨거나, 내가 원하는 Output을 얻을 수 없다.Algorithm for the balanced symbol checking  Make empty stack (빈 Stack을 만든다.)  Read symbols until end of formula (닫는 Symbol이 나올 때 까지 계속 Symbol을 읽는다.)          Opening symbol 이면 무조건 stack에 push한다.      Closing symbol 일 때                              만약 stack이 empty다(매치가 되는 opening symbol이 없다?)            -&gt; Error                                symbol의 style이 맞지 않는다?            -&gt; Error                              에러가 리포트 안되고, Stack이 empty면 Balancing Symbol 이다.      Scenario of Queue공항에 표를 사기위해 사람들이 줄을 서 있다. 줄은 당연히 맨 뒤쪽으로 계속 서야하고, 맨처음 선 사람이 부터 순서대로 표를 산다. in way와 out way가 다르고, No one gets in the middle of the line. (중간으로 들어올 수 없다.)이처럼 먼저 들어온 데이터부터 처리되서 나가는 구조를 바로 Queue라고 한다.  First in First out (FIFO)Structure of Queue중간으로는 못들어오고, 들어오는 길은 맨 뒤쪽고, 나가는 길은 맨 앞쪽Difference  The first instance in the list          The front instance in the queue        The last instance in the list          The rear instance in the queue      An item is inserted at the lastAn item is removed at the frontOperation of QueueStack과 마찬가지로 중간단계 access를 포기했기 때문에,  List의 특정 index에 대해서 잘 처리해주면, List를 활용해서 Queue를 구현할 수 있다.Enqueue      Insert an instance at the last in the linked list(맨 뒷부분에 insert)    -&gt; Put an instance at the rear in the queue  Dequeue      Remove and return an instance at the first in the linked list(맨 앞부분에 것을 remove)    -&gt; Remove and return an instance at the front in the queue  Implementation of QueueClass Queue(object):    lstInstance = SinglyLinkedList()    def dequeue(self):        return self.lstInstance.removeAt(0)    def enqueue(self, Value):        self.lstInstance.insertAt(Value, self.lstInstance.getSize())        enqueue같은것은 사이즈 변화를 신경써야함.그래서 LinkedList class에 있는 getSize 함수를 이용해서queue의 맨 뒤쪽 index를 명시해줌Implement Linked List again(This time, with UML Class Diagram)하도 중요하다고 하니까, 인터넷에 떠도는 UML Diagram보고 한번 만들어보자.class Node:    def __init__(self, data=None):        self.data = data        self.next = NoneNode Class의 member function은 작성하지 않았음class LinkedList:    def __init__(self):        self.head = Node()    def addFront(self, data):        newNode = Node(data)        curNode = self.head        newNode.next = curNode.next        curNode.next = newNode    def addEnd(self, data):        newNode = Node(data)        curNode = self.head        while curNode.next != None:            curNode = curNode.next        curNode.next = newNode            def length(self):        curNode = self.head        count = 0        while curNode.next != None:            curNode = curNode.next            count += 1        return count    def addAtPosition(self, data, idx):        newNode = Node(data)        curNode = self.head        curIndex = 0        while curIndex != idx:            curIndex += 1            curNode = curNode.next    def search(self, data):        curNode = self.head.next        idx = 0        while curNode.data != data:            curNode = curNode.next            idx += 1        return idx    def printItem(self):        list = []        curNode = self.head        while curNode.next != None:            list.append(curNode.next.data)            curNode = curNode.next        return list    def deleteFront(self):        curNode = self.head        target = curNode.next        curNode.next = target.next    def deleteEnd(self):        curNode = self.head        while curNode.next.next != None:            curNode = curNode.next        curNode.next = None    def deletePosition(self, idx):        curIndex = 0        curNode = self.head        while True:            lastNode = curNode            curNode = curNode.next            if curIndex == idx:                lastNode.next = curNode.next                return            curIndex += 1    def getItem(self, idx):        curIndex = 0        curNode = self.head        while curIndex != idx:            curNode = cur.next            curIndex += 1        return curNode.next.datatest = LinkedList()test.addEnd('a')test.addEnd('b')test.addEnd('c')test.printItem()test.deletePosition(1)test.printItem()test.getItem(0)test.search('a')현장강의]]></content>
      <categories>
        
          <category> Data Structure </category>
        
      </categories>
      <tags>
        
          <tag> Data Structure </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Data Structure week2]]></title>
      <url>/data%20structure/2020/03/24/Data_structure_week2-post/</url>
      <content type="text"><![CDATA[Data Structure Week 2KAIST 산업및시스템공학과 문일철 교수님의데이터 구조 및 분석: Linear Structure and Dynamic Programmingedwith 강의를 보고 정리한 내용입니다.Weekly ObjectivesThis week, we learn the object-oriented paradigm (OOP) and the basic of software design.Objectives are  Understanding object-oriented concepts Class, instance, inheritance, encapsulation, polymorphism….  Understanding a formal representation of software design Memorizing a number of Unified Modeling Language Notations  Understanding a number of software design patterns Factory, Adapter, Bridge, Composite, Observer                                       Memorizing their semantics and structures앞에서는 프로그래밍하는 방법을 배웠고,이번에는 잘 설계하는 방법에 대해서 알려주신다고 합니다.이번주차에서는 ==OOP와 Basic of software Design==에 대해서 배웁니다.적어도 설계도를 보고 읽을 수 있고,어떤 디자인인지 스스로 감은 잡을 수 있도록 되어야합니다.앞의 내용을 다시한번 이야기해보면,  Software Design 은 설계도  Software Implementation 은 실제 시공  Python 은 시공에 쓰이는 중장비Lobby1, Lobby2같은 경우 비슷한 역할을 하고, 비슷한 디자인이 적용이 되지만디테일은 다릅니다. (특성의 값이 다르다.)어떻게하면 기존의 설계를 재사용하고, 일관성을 유지하는지가 중요한 요소가 됩니다.Good Software DesignCorrectness      Client의 목적에 맞아야함.        Error가 없어야함.  Robustness  예상되는 사용자들의 실수에도 잘 실행될 수 있도록.Flexibility  유연하게 업데이트될 수 있어야함Usability and Reusability  디자인 목적에 대해 좋은 support를 해줘야함.(Interface or comment)  다른 목적에도 쓸 수 있으면 좋도록.  다른 환경에서도 사용할 수 있도록.Efficiency두가지 차원에서의 efficiency      쉽게 구현할 수있도록        빠르게 실행되도록  이런것들을 외울 필요는 없지만,이런것들이 중요하겠구나 라는 생각은 가져야한다.Object-Oriented Design설계라는것은 Real-world의 개념을 추상화하여서프로그램으로 만들수있는 설계로 나타내는것이 좋은 설계다.= 현실에서의 개념을 프로그램 모듈로 만들어내는 과정은행 시스템의 Concept에는 무엇이 있을까  Customer  Transaction  Banking그렇다면 현실에 존재하는 Concept을 어떻게 프로그래밍 모듈로 만들것인가?  Concept의 이름  계좌를 가진사람 == customer(개념이름)  Concept이 가지고있는 상태, 특징점      정적이지만, 특정 시점마다 어떤 값은 가지고 있어야한다.    (Attribute or Member variable // ID, AccountNum같은 개념의 특성)        Concept이 할 수 있는 행동          login, confirmSecurityCard 같은거(개념의 행동)      Transaction 행위도 위처럼 표현한다면?  Transaction (Concept의 이름)  amount, releaseATMID (Concept의 특성)  releaseMoney (Concept이 하는 행동)Real World Concepts이렇게 Concept의 이름,특성,행동을 정의하는것을 Abstarction이라고 한다.  Abstract      소프트웨어를 설계하는 목적에 맞게 끔 Concept을 간략화 한거!(Software Design Entities로 !!)  프로그래밍에서 Class와 Instance에 대해 먼저 살펴보면,What are Class and Instance?Class vs InstanceClass      Result of design and implementation        Conceptualization (특성, 행동 간략화)        corresponds to design abstarctions  Instance      Result of execution        Realization        corresponds to real world entities  Class라는건 사실 하나의 Design(definition)이다.Real world의 Concept을 파이썬에서 Class로 만들어낸다.Class를 이용해서개체마다 바뀌는 Concept의 특성을 반영하여 여러개의 instance를 만들 수 있다.메모리상에서, Class는 미리 설계하고 구현-&gt; 몇개인지 알 수 있다.하지만 Instance는 소프트웨어를 돌려봐야지만 몇개가 있는지 알 수 있다.추상화를 통해서 균일하게 설계된 여러개의 Instance를 만들어낼 수 있다.하나의 설계를 이용해서 실제로 존재하는 여러 Entities를 표현하는 것이다.Software Design as House FloorplanSoftware 디자인은 평면도를 만드는것과 같다.평면도는 마음대로 그린것이 아니라,작성 표준에 맞춰서 그려야 하는데 Software 디자인에도 작성 표준이 있다.이런 작성 표준을 알아야하는 이유는 무엇일까?Developing software에는 두가지 행위가 필요하다  Mainly design  some coding여기서 Design이 주가 됨.Need to learn how to communicate with your colleagues  Learn standard.  Learn how to represent your design to your boss.같이 일하는 동료, 혹은 상사와의 Communication을 위해 알아야 할소프트웨어를 설계하는 표준을 UML (Unified Modeling Language)이라고 한다.현실에 있는 다양한 Entities들을 UML이라는 표준을 통해서추상화하여 표현하는 방법을 알아야한다.UML notation : Class and Instance이 부분은 수업이나 UML 그림을 보면서 하시는것을 추천.    classDiagram	class Customer{		-ID : String		#AccountNum : Interger		+name : String = Hey		+login() : void		+requestWithdrwal() : Boolean		+confirmSecurityCard() : Boolean	}   Abstract class : person  Clas : Customer  Unnamed instance : Customer          instanceName::className 으로 표현함      instacneName이 안 정해졌으면 그냥 className      ID, AccountNum, Name은 Member variable(attribute, property)  +-#(name):(type)=(default value)의 형식으로 기입Login, requestWithdrawal, confirmSecurityCard는 Method(member function)  +-#(name)(arguments):(type)의 형식으로 기입Method에서의 type은 return되는 녀석의 type을 의미한다.arguments는 괄호속에 정의한다.==Visibility options==  - 는 private  + 는 public  # 는 protected현실에서 선호되는 방식은 -(private)보통 method를 이용해서 데이터에 접근하도록 만든다.​Encapsulation  클래스 설계 또는 디자인 스타일  클래스 내부에 모든내용이 쌓여있어야하고, 외부에서는 Method로 접근할 수 있어야한다는 개념.Object = Data + BehaviorData : Field, Member Variable, AttributeBehavior : Method, Member Function, OperationEncapsulation하는 것의 장점  구현에 대한 책임을 Delegate함Delegating the implementation responsibility.Delegate에 대한 자세한 글데이터를 변형하는것은 내가 짜논 behavior로만 한다.  Bring me a sausage, and i don’t care how you made it​Utilizing the visibility위의 Encapsulation **은 **visibility option을 이용해서 구현가능  Public : many can see.  Protected : seen only within the class and its descendants.  Private : only i can see.Method는 public하고Data는 private로 해서 구현한다.Python은 기본적으로는 Visibility options을 지원하진 않지만,나름대로 약속은 가능ex)____var1___ mean “다른 사람이 안썼으면 좋겠다.”라는 의미를 담고있다.Inheritance  Giving my attributes to my descendantsMy attributes include member variables and Methods(여기서는 member variable 의미하는 그 attribute가 아니라, member function까지 포함하는 의미로 쓰임.)자식들은 새로운 Attribute를 새로 가질 수도 있다.  자손들은 내가 가졌던 Attribute들을 Mask하고 자기 나름대로 바꾸어 나감.  위의 경우가 아닌경우, 물려준 성질을 따른다.필연적으로 두개의 역할이 생겨남      Superclass(부모 클래스)                  Generalized from the conceptual view        -&gt;새롭지 않고, 전형적이고 일반적인 특성만 가지고있음.                  Subclass(자식 클래스)                  Specialized from conceptual view        -&gt; 새롭고 특별한 특성도 있다.            c++이나 python은 여러개의 class에서 상속가능 (Multiple inheritance)Subclass에 superclass의 attribute와 method가 다 들어가있다.Inheritance in PythonProgram Language마다 상속하는 방법은 조금씩 다르다.Python에서 Object라는것은 가장 상위의 시조, 조상괄호에 아무것도 넣지않아서 아무것도 상속받지 않은것 같지만, 기본적으로 Object에서 상속받는다.  (object) = ()class father(object):있고class mother(object):있으면class Child(Father, Mother):def init(self):​    super(Child, self).init()super  inherite하고있는 상위단계의 class를 call한다.  이름이 겹치는 method가 있으면 child껄로 overriding 된다.self and superself      reference variable pointing the instance itself        자기자신을 가리킨다.  super      reference variable pointing the base class instance        super는 Base class methods 를 call한다.    -&gt; 첫번째 inheritance를 찾는다.  이렇게 Multiple inheritance 상황에서는 super는 첫번째 inherit받는 녀석을 call함-&gt; 반대로 말하면 첫번째 inheritance를 찾기위해서는 super를 이용하면 된다.PolymorphismPoly : ManyMorph : Shape단어를 직역하면 “다양한 모양”  Different behaviors with similar( ex) 점박이 인것은 동일하지만 밝은색인지 어두운색인지)**유사한 Signature를 가지고 있지만 다른 행동을 할 때Polymorphism이 적용됐다라고 한다.== signature = Method name + parameter lists ==Signature로 어떤 Method가 어떤 Method인지 구분할 수 있다. (?)Polymorphism은 상속이라는 개념이 적용되었을 때 사용한다.Polymorphism의 하위 개념으로  Method Overriding      부모class와 자식class의 method의 method name 과 parameter list가 같을 때    Base class has a method A(num), and its derived class has a method A(num)    -&gt; Base class에 있는 동일한 method signature를 엎어쳐서 새로이 정의된 method로 실행한다.    Method Overloading      Method name은 동일하지만 Parameter가 달라서 다양하게 사용 가능하다.    A class has a method A(num), A(num, name)…..    -&gt; Parameter가 다를 때 어떻게 실행하느냐를 정의한다  ​Abstract ClassAbstarct Class, or Abstarct Base Class in pythonAbstract Class란?  Abstract Method가 있는 ClassMethod가 Signature part만 정의되어 있다. (Implementation가 없다.)동작을 못하는데 왜 필요할까?ex)사람이 여러명이서 작업할 때, 창문을 만든다고 했을 때“창문이 반드시 열리긴해야돼. 근데 어떻게 열릴지는 너네가 알아서해”라고 할 때,창문을 열리게 만들기만 하면, 나머지는 내 마음대로 하면된다.Entity의 기본적인 특성을 지키면서, 그 안에서 자유롭게 Customize할 수 있도록하기 위함이다.Abstract class in not a complete implemetation,it is more like a half-made produce.결국 이걸로 Instance를 만들수는 없다.The concrete class with full implementations andinheriting the abstract class will be a basis for instances.일반적인 클래스가 Abstarct class를 Inherit하고 override해서, 그래서 풀 구현을 하고,자식 클래스를 이용해서 Instantiate 해서 활용한다.디자인을 하면 이런 Abstract Class가 유용하게 사용될 수 있을 것이다!​Overriding Methods in ObjectBase class를 Specify하지 않더라도, Base class로 Object를 그대로 받아온다.(Object는 가장 상위의 조상님)Object에는 속에 사용자가 정의한 내용은 아무것도 없다.하지만 Python에서 정의한 내용이 숨겨져 있다.기본 method를 override해서 유용하게 사용가능  init -&gt; constructor 기본적인 initialize setting을 한다.  del -&gt; destructor  eq -&gt; memory space를 건들지 않고 값을 비교한다.( == )  cmp -&gt; comparison 대소를 비교한다.  add -&gt; 덧셈을 한다.기본적인 기능을 더 쉽게할 수 있게 만드는 Method들이다.​Duck TypingInstance끼리 비교하는 Method일 때, 항상 같은 Class가 들어가지 않을 수도 있다.이런 경우를 고려를 해야하는데, 그러지 않고 짠 코드를 Duck Typing이라고 부른다.-&gt; 실행타임에서 오류가 발생한다. (Interpret 언어의 특성)  EAFP(Easier to Ask for Forgiveness then Permission)      ==그냥 나중에 실행타임에 가서 에러를 내자라는 방식임.==  ​More about UML Notations얘도 그림보시면서..현실에는 다양한 UML diagram있음class, state, use-case, deployment지금까지는 class diagram에 대해서만 했다.그 외에도 다양한 UML Diagram이 있다.  Use-case :  상호작용을 보여준다  State : method 속에 있는 내용이 어떻게 점점점 개발할건지에 대한 순서도  Deployment : Packaging을 어떻게하고 어떤서버에 어떻게 올릴 것인가 등등..  Abstract class : Abstract method가 있는 classAbstract class -&gt; class로 가져오려면 Method override(inheritance)Same method signature일때 method override,이름은 동일하고 parameter가 다를때 method overload 한다.​Structure of Classes in Class DiagramWhat makes a structure?-&gt; Entity and Relationship  Association은 어떤 관계를 맺고 있는지, (화살표, )  Generalization은 상속관계를, (삼각형 화살표, hallow point arrow)  Aggregation(마름모 화살표)위 화살표들을 가지고 이어져있으면,뭔가 관계가 있다! 라는걸 알 수 있다.​Generalization근본적으로 inheritance relationship에 기반을 둔다.Inheritance는 필연적으로 두가지 다른 타입의 class를 만들어낸다고 했다.  Super class  Sub classis-a relationship의 관계Direction of generalizationex) “Customer” is a “Person”sub -&gt; super 방향customer -&gt; personFrom sub class, to super class모양은 Hollow triangle shape이다.Base class가 person이 되고Leaf class가 Park::CustomerNote)  Sub class에는 Super class의 Member variable과 Member function이  선언하지않아도 있다는걸 기억하자! Method overload, Method overrideAssociationhas-a relationship의 관계(어떤 클래스가 무엇을 가지고 있다.)Member variables과 연관이 되어있다.      A customer has a number of holding accounts.        An account has an account holder customer.  기본적으로 필요한 정보  Multiplicity에 대한 정보(1 : 多, 多 : 1, …)          알맞게 기입해주어야 한다.      Simple Line으로 표현 ( Generalization은 Hollow triangle shape )만약 Simple arrow가 붙으면,      A customer has a reference to bank accounts        A bank account has a reference to a customer    -&gt; 방향을 나타내주기 위한 표현이 됨! (Navigability)    (쌍방향으로 있을수도 있음)  Account holderHolding accounts1과 *는 1 to Many의 관계를 의미한다.-&gt; customer하나에 bank account가 여러개 된다.​Multiplicity of Association      *often means many.        1..* means 1 to many, * means 0 to many.    1 -&gt; exactly one,  0..1 -&gt; one or zero.  아무것도 표기하기 않았을 때 default는 1이다.​AggregationSpecial case of association= Special has-a relationshipMore like, part-whole or part-of relationship변형된 has-a 관계Hollow diamond shape 으로 표현Aggregation에서 어떤 Special한 의미가 나오는 것 일까?  가족구성원이 하나도 없는 가족은 존재할 수 없다.여러명일때는 괜찮지만, 0명일때는 안된다.가족구성원이 없다면, Family 자체도 메모리 상에서 없애버려야된다.  If nothing to aggregate, there is no family.Aggregation often occur  when an aggregating class is a collection class 일때!  when the collection class’s life cycle depends on the collected classes.항상 FamilyMember를 관리를 해서 Family의 존재유무를 체크해야한다.​DependencyUse Relationship다른걸 import해서 활용한다.Method는 잘 활용되겠다. 저장의 용도는 아니다.활용했다는걸 표현할때는 점선과 Simple arrow shape으로 표현.Member variable로 관계되지않는다.-&gt; Local variable ….​Let’s practice​시나리오가 주어지면 그릴 수 도 있어야하고,읽을수도 있어야한다.Archetype 이라고 하는것은 마치 templete과 같은 것 이다.이런 목적을 위해서 설계를 하는 Pattern이 존재한다.​현장강의 Exercise 2​Diagram를 배우는 이유?엔지니어라면 알아야한다. (소통을 위해서)내가 UML에 맞게 그려놓으면, 다른 엔지니어들이 알 수 있도록..Class is one templete, instance made with the templete.Objective  Make the complete analysis : calculate the analysis accuracy  Use the attribute of classes  Make the charts표준편차 구하는법standard devation]]></content>
      <categories>
        
          <category> Data Structure </category>
        
      </categories>
      <tags>
        
          <tag> Data Structure </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Data Structure week1]]></title>
      <url>/data%20structure/2020/03/21/Data_structure_week1-post/</url>
      <content type="text"><![CDATA[KAIST 산업및시스템공학과 문일철 교수님의데이터 구조 및 분석: Linear Structure and Dynamic Programmingedwith 강의를 보고 정리한 내용입니다.Orientation건물들을 보면 보통 일정한 패턴를 가지고 있는데, 그렇지 않으면 뭔가 어색하다. 왜 일정한 패턴을 가지고 있냐고 물어본다면, 그렇게 만드는게 효율적이니까 그렇다.Data structure도 마찬가지이다. 건설에 비유해보자. Data Structure가 방 배치를 어떻게 할것인가라면, Algorithm은 어떻게 그 방을 찾을까라고 할 수 있다.  사람들이 방을 어떻게 찾을지를 고려하여, -&gt; Algorithm  방 배치에 반영한다. -&gt; Data structureAnalyzed data = Accessed data실제로 실무에 나가게 되면, Analyzed 된 데이터를 다루는게 아니라 직접 Analyze해야하기 때문에 Analyzing method는 매우 중요함 (할 줄 알아야 함)파이썬은 Analizing의 key가 되어가고 있기 때문에 Python을 이용하여 강의를 진행한다.-준비물-오프라인 강의 오기전에 예습2명이 팀이고 같이 진행파이썬이 있는 노트북(python 3.5 and the most recent version of PyCharm파이썬에 대해서 먼저 알아보기Python reviewThis week, we review Python that will be used for a programming language for this course.Objectives are  파이썬 환경 세팅  HelloWorld program 실행하기  파이썬의 기본적인 문법 암기하기  파이썬의 프로그래밍 구조에 대해 이해하기  파이썬 변수들의 reference를 이해하기  Control과 loop 구문 이해하기  함수 호출과 클래스 선언 이해하기  파이썬의 list, tuple, dictionary 이해하기  Sample GUI program 실행하기Programming and DS&amp;A(Data Structure and Algorithm)  Algorithm  An algorithm is a step-by-step procedure, which defines a set of instructions to be executed in a certain order to get the desired output.  Data structure  A data structure is a data organization, management, storage format that enables efficient access and modification두가지는 연관성이 있지만 다른 계층의 일을 한다.프로그래밍에서 Data structure와 Algorithm이 어떤 의미를 가지느냐!기본적으로 프로그래밍은 구현하는 도구!      예를들어, 건축가가 집을 지으려함 설계도를 들고있다.    집을 어떻게 이용하면 좋을지에 대한 아이디어가 담긴게 바로 설계도(구조, 동작들을 감안한 것).    그 다음 시공을 하는데 집을 지을 수 있는 도구가 필요함.(중장비)  -&gt; 이때 설계도는 프로그래밍에서는 DS&amp;A인거고, 도구는 Python개발자는 설계도 필요하고 구현도 해야한다. 이때, 구현은 Programming으로 하고, 설계는 Data structure와 Algorithm으로, Python을 이용해서한다고 생각하면 되는데, 화장실을 짓는다고 했을 때, 화장실을 어디에 둘 것인지(Data structure), 어떻게 찾을 지(Algorithm)라고도 볼 수 있다.나를 더욱 더 특별하게 만드는 건 단순히 프로그래밍만 잘하는게 아니라, 엔지니어로서 어떻게 설계를 할 것이냐이다.  프로그래밍과 Data Structure, Algorithm의 조화가 필요함What is Python      91년도에 발표        Interpreter language &lt;-&gt; Compiler          Compiler는 실행이전에 최적화 시켜서 실행,      Interpreter는 최적화되지 않아도 그때그때 실행.        -&gt; 코드 작성은 빠르고 실행은 느리다. Fast development speed, slow execution speed    Object-oriented Programming      Dynamic type of variables        Unique code structure        좋은 Structure를 유지하도록 강제한다는 관점에서 Structure에 적응하면 자유로운 것보다 편할수 도 있음.    Specialty in data analyses          Various numerical and statistical libraries : Numpy and Scipy      Base language for Tensorflow and others      Programming and Execution EnvironmentIntegrative Development Environment(IDE)  파이썬 위에 있어서 걔를 활용하는거 Text edit나 특정 행동을 다하고 파이썬에서 돌리기 위한 도구.  To reduce implementation time, debugging time자세히 들어가기 전 간단히 파이썬에서 구성요소를 나열하면      indentation -&gt; 파이썬은 들여쓰기(indentation)로 block 지정한다.        self는 자기 자신을 의미한다. self라는 변수를 이용해서 행동을 정의하게끔 하는 것 이다.        Constructor, Destructor는 Instance가 생성 또는 없어질 때 실행        class는 틀, 판(Templete)과 같다.  Naming and Styling회사마다, 연구실마다 다 다르긴 한다. 의미를 잘 전달할 수 있는 형식으로 만들어야 한다는 건 똑같다.Camel Casing 방식ex) HelloWorldNaming : Use names clearly conveying the meaning  class name : Noun for the concept to be represented by the class, Capitalize the first letter of each word.                                                                  ex) MyFirstClass, HelloWorld  variable name : Noun for the contents to be stored, start with lower case.                 ex) numberOfStudents, intCount  method name : Verb for the method action, start with lower case.                          ex)performAverage(self, val1, val2)  method : function in classComments주석을 잘 다는것도 중요하다. comment area에 두면 declaration or execution에 아무런 영향을 안주니까 부담없이 달자.’’’ ‘’’ or “”” “”” or #Data TypePython은 Data type이 없는게 아니라 나중에 Assign 되는 방식이다. 변수이름만 보고는 내용물의 Data type을 알 수가 없는데, 나중에 저장이 되면 Variable에 Data type이 존재하게 되는 것 이다.integer, float, ~~~, complex(복소수), character, ~~ex) complex(3,4) = 4+3j complex.real , imagOperators+, - *, /, %(modulo)실수에 int()를 씌운다는건 정수화시켰다라고 말할 수 있는데, 이렇게 Data type을 바꾸는 것을  Type Casting이라고 한다.ex) int(), str() …만약 float로 정수를 나누면 소수점 이하도 나오는데, 이런 경우에 파이썬은 정보량이 항상 많은 쪽으로 유지된다.정보량 int&lt;float== is the equivalence of values!= is the in-equivalence of valuesswapping statement가 쉽게 가능.num1, num2 = num2, num1핵 쉽네String데이터를 ‘ or “로 wrap해서 사용한다. String value는 Equivalence Test가 가능하다. String이라는것이 무엇인가의 연속인데 그중에서 인덱스 값을 이용해서 특정한 값에 접근할 수 있다. String variable은 사실상 linear collection of letters인거고, 그들은 index를 가지고 있다.  negative index도 가능하다. ex) str[-1], str[-2]String으로 여러가지 Operator가 가능한데, 그중에서 +가 제일 직관적이다.in, not in로는 진위여부 확인이 가능하다. (긴 문자열 속에 짧은 문자열이 들어가 있느냐)  다시! String은 index를 이용한 collectionIndex in SequenceThis index applies to strings as well as tuples, lists-&gt; Applies to any sequence variables  First element index starts with 0인덱스 하나하나를 찍을수도 있지만, “:”를 이용해서 범위를 지정할 수도 있다..ex) 1:3 -&gt; x:y 일 때 y 로 가기 직전에 멈춘다.1:9:2 -&gt; x:y:z 일 때 from x to y with z steps.5::-1 에서 y의 default는 length of the sequence, z는 1.len()는 string의 길이를 의미한다. (길이는 index보다 1이 크겠지.) negative step 일때는 거꾸로 출력됨.      string -&gt; 개별 문자들의 열        index -&gt; 열의 번호  ListList is another type of sequence variable. string은 ”,’로 문자열을 지정할 수 있지만, 숫자같은 경우는 []를 이용함.  range(x,y,z) == xyz —&gt; from x to y , z is step size.(point)는 instance속에 있는 method를 쓰기위해 사용.      lstTest.append(“hey”)        del(lstTest[index])        lstTest.reverse()        lstTest.remove(element)        lstTest.sort() —&gt; 오름차순으로 sorting을 해라  숫자가 아닌것은 ASKII로 바꿔서 숫자와 비교되고, 리스트에는 뭐든지 다 저장될 수 있다는 걸 기억하자.Tupletuple은 list와 거의 동일하지만 Only different in changing values.즉, tuple은 value를 바꾸는걸 허락하지 않는다. 다시 말하면 item을 assign 하는것이 불가능하다. 왜이런것이 필요할까?여러사람이 프로그래밍하다보면 constant(상수)표현이 필요하기 때문이다.고정되어야하는 값들이 있으니까, 그런것들을 표현하는데 쓰인다.  tuple의 value들은 ()로 묶어줌(Parentheses)Dictionarycollection variable type 인데 sequential 하지 않다. keys와 values의 pair 형태로 되어있고,  pair들을 {}로 묶어줌.(Brace)  dicTest[index] 가 아니고 dicTest[key], key에 대응하는 value를 return함.          dicTest.keys()      dicTest.values()      dicTest.items()      IFA condition statementif boolean:    statement for Trueelif boolean:    statement for Trueelse:    statements for False파이썬에는 switch-case statement 없다. 위의 코드처럼 작성하면 되는데, indentations 주의해서 규칙적으로 들여써야지 block에 혼란이 안생긴다.ForFor statement is A loop statement대표적인 loop statementfor Variable in sequence:  statements for loopelse:else는 for-loop가 정상적으로 끝나면 else 구문을 실행하도록 사용하기도 한다.Useful statements for loops      loop를 control하기 위한 control statement        continue -&gt; 만나는 즉시 for loop로 돌아가라!        break -&gt; 만나자마자 밖으로 튀어나가라(else까지 포함해서)  for itr in range(y):range에 의해서 정의된 sequence가 하나하나 itr에 적용이 된다!Function Statement위의 다양한 statement들은 control를 위한 것이고, 이 부분은 Function을 정의하는 방법이다.​```def : function정의하는 keyword    name : function's name    params : function's inputreturn : 결과물을 반환하는 keywork​```def name(params):    statements    return var1, var2 ...f(x) = ax + b 에서, x가 params 라고 생각하면 되고, ax + b 가 statement파이썬은 다른 언어와 다르게 return type이 존재하지 않는다. 계산된 값을 어떤형태로든, 몇개로든 return이 되는게 편리한 점 중 하나다.  You can return multiple variables.  조심해야할건 order(순서)를 지켜서 return해야한다는 것이다.One line function is called lambda functionlambdaAdd = lambda numParam1, numParam2 : numParam1 + numParam2다시 return type을 정의해줄 필요가 없다는 것의 장단점을 살펴보면      장점 : 편하고, 고민이 필요없음        단점 : 다른 언어는 계산하기전에 체크를 해볼 수 있는데, 파이썬은 에러가 나중에 발생한다.  -&gt; 프로그램을 쉽게 짤 수 있지만, 나중에 에러가 생길 수 있다!Sample Program : Finding Prime Numbers알고리즘 정리하기jm-park님 블로그 참고 Assignment and Equivalence리스트에 있는 다양한 값이라던가 Object를 비교하는 일이 간단한 일은 아니다. 매커니즘에 대한 이해가 필요하다. 같은 Type이 아니라면 비교조차 될 수 없기 때문이다. 또한 내부의 element에 대해서도 생각해보자.list1에 또다른 list list2를 넣으면 무슨일이 일어날지에 대해 생각해보면 리스트안에 또다른 리스트가 들어가있다, 즉 Nested 형태가 된다. 즉, list도 하나의 element가 될 수 있다는 것이다. 이렇게 활용성이 매우 크고, 그만큼 경우의수도 많은데, 그에 따른 규칙도 많기 때문에 잘 따라야한다.아래에서는 Reference의 개념에 대해 다룬다.x = [1,2,3]y = [100,x,120]z = [x,'a','b']위와 같은 코드가 있다고 할 때, 만약 x값을 바꾸고, 다른 List를 살펴보면, x라는 하나의 variable만 바뀌었을 뿐인데, 그것을 포함하고 있는 곳에도 변화가 있음을 확인할 수 있다. 왜? Because of references. y와 z에는 x의 값을 저장하는게 아니라 x의 reference가 있는 것이다.  reference == 화살표x has two references from y and z. The values of y and z are determined by x, and x is changed.어떤값을 어떤 variable에 assignment할 때, 값이 실제로 들어갈 수도 있고, reference가 부여 될 수도 있는 것이다. primitive data type은 실제로 들어가고, object들은 reference 형태로 들어간다.(list, tuple, dictionary)value 비교와 reference 비교를 하는 두가지 equivalence가 따로 있으니까 referencesee the ripple effectsx의 change가 y와 z의 change를 일으켰다(incur)== : checks the equivalence of two referenced valuesis : checks the equivalence of two referenced objects’ IDsClass and Instance위에 “Assign Data”에서 primitive data가 아닌 것들에 대해서 이야기를 했는데, 이 외에도 Object가 엄청 많다.  설계도 = class  집 = instanceClass block는 몇개의 Variables 과, 몇개의 Functions으로 이루어져있다.  Class block -&gt; Class Definition Area실제로 Function call이 일어나야 무언가 작동하지homeAtDaejeon = MyHome()실제로 사실 위의 코드도 function call인데, MyHome의 constructor(생성자)를 콜하는 것이다!Constructor 의 return 은 하나의 Instance가 나와서 저장되는거==Note) primitive 아닌것들은 reference로 저장!==primitive가 아닌 것: List, tuple, dictionary …여러개의 Instance를 선언했을 때,Class는 같지만 서로 다른 Instance니까 Reference는 다름==그리고 self는 Instance 자기 자신이다.==  Instance      Function도 있고, 특성치를 저장하는 Variable도 독립적으로 가지고 있는게 바로 instance!  Point StatusClass의 중요한 Method는 뭐가있을까Constructor(클래스를 선언할 때 call되는 Method!)DeconstructorClass를 다시 보면,Variable도 있고, Function도 있다.def __init__(self): 형식으로 되어있는건 뭘까?  ==Constructor라고 부르자라고 약속!==      It is called when instantiated  Constructor에서의 self는 좀 다른데, self가 return 값이라 생각하면될듯(Instance 그 자체)이걸로 Instance를 초기화 할 때 사용하면 좋겠네~  Destructor는?      It is called when the instance is removed from the value table  ==집을 무너뜨리는거!=== Instance를 없애는거!Module and Import한 파일안에 여러클래스를 넣어놓기가 쉽지않으니,한 파일에는 하나의 클래스만 넣는걸 추천여러개의 클래스를 엮어서 활용하고 싶을 땐 어떻게 해야할까?Home.py 먼저 보자from time import ctime// time은 package이고, 그 안에 있는 ctime을 가져와라// 선물꾸러미 : packageMyHome 이라는 Class는 Home.py에 있는 Class임Member Variable: cololrRoof, stateDoor그리고 각각의 Method들이 자신들의 Block안에서 자신을 Definition함그리고 init , del 는 constructor와 destructor.init안에 보면 ctime()이라는걸 쓰고있지-&gt; 얘를 사용하기 위해서는 from time import ctime을 해야하는거UsingMyHome.py를 보자import Home-&gt; Home.py를 실제로 가져온다!from time import ctime도 마찬가지-&gt; time package안에 ctime을 가져온다.  import Home을 하는 순간에 Home.py을 가져와서 미리 실행을 해본다. 라는 개념Home.MyHome(“~~~~~”) 을 수행한다는건 무슨의미?-&gt; Home 속의 MyHome class를 활용하겠다.Organizing Modules by Package어떻게 Directory를 이용해서 import 할지?Directory 구조src/edu/kaist/seslab/le362/week1/~~~처럼 되어있고그 안에 보면 __init__.py 가 있는데 얘는 뭐일까?-&gt; 특정 Directory가 python package라는걸 의미하는 File나머지는 week1안에 있는 Class들을 정의해논 .py file들임그래서 만약 src에 내가 작성한 파일이 있다고할 때from edu.kaist.seslab.le362.week1 import Home뒤에 .py file import할때는 with extension으로==from 은 만약 같은 디렉토리에 있는걸 import할때 생략가능==Sample Program: Interaction with Your Program위에서 부터 보면CashierLine class의 Definition blocklstLine은 Member Variabledef로써 Definition되는 Function들은 member function(method)line = CashierLine()// 하나의 instance를 create해라! -&gt; constructor callclass CashierLine:    lstLine = []    def addCustomer(self, strName):        self.lstLine.append(strName)    def processCustomer(self):        strReturnName = self.lstLine[0]        self.lstLine.remove(strReturnName)        return strReturnName    def printStatus(self):        strReturn = ''        for itr in range(len(self.lstLine)) :            strReturn += self.lstLine[itr] + " "        return strReturnbinLoop = Trueline = CashierLine()while binLoop:    strName = input("Enter Customer Name : ")    if strName == ".":        break    elif strName == "-&gt;":        print("Processed : ", line.processCustomer())        print("Line : ", line.printStatus())    else:        line.addCustomer(strName)        print("Line : ", line.printStatus())print("Number of remaining customers : ", len(line.lstLine))이 코드를 따라해보면서 내가 몰랐던 것은..Member Variable을 사용할때는 항상 앞에 self와 ”. “을 붙어서 사용해야 한다는거..Method안에서 선언하고 사용하는 Variable 들에게는 필요없지만Member Variable은 Class전체에 영향을 주기때문인 것 같음..현장강의 ExerciseRemember! String is a array of characters  for loop      Very important. Very simple control statement. manipulate program process.    Different class definition with function definition      function definition is in definition.  special cases function -&gt; constructor, destructor.Class is a setup functionProgram is divided largely in two parts  Definition part  Execution partsentidata =[]  for loop(sentidata.append(row))      create a 2-D array    zip(v1,v2) statement      call elementwise pair of vector v1 and v2    enumerate(list)      call indaex and value together  ex) for index, value in enumerate(v1):​     pirnt(index, value)  sum(list)      sum of list    int(float(x))      Convert a string type x into integer type -&gt; type casting    List comprehension      Make a list of value that satisfied the condition  list = [value for loop(condition)]Offline Class PlanProduct Review and sentiment AnalysisProduct review(positive or negative), information.What if we have 10,000 reviews and want to find the negative ones?자신들의 제품을 어떤쪽으로 보완시켜야하는지 알기위해서negative한 의견들을 모아서 보기위해 파악할수있는 프로그램.Why simple word searching doesn’t work.-&gt; 어떤것이 대상이냐에 따라서 단어에 따른 평가가 좋은것일수도 있고 나쁜것일수도 있기 때문.ex) cool pizza, hot pizza, cool beer, hot beerFor statistical analyses,How to represent description in a numerical setting.because we will use number.-&gt; We turned the review text into a vector(first method)A vector &lt;1,0,0,1&gt;**A word list **Then the review contain “I” and “reliant”Conditional Probability and Bayes Theorem“actually” and “positive” reviewH(hypothesis) : review is something that we want to know.-&gt; condition like positive or negative.**E(evidence) **: word is something that **we can observe.H is given how is the probability of being E            P(E=’actually’      H=’positive’)      = P(H=’positive’ and E=’actually’) / P(H=’positive’)P(E l H)를 P(H l E)로 만들면 그 힘을 볼수가 있음.E를 알 수가 있으니까,P(H l E) = P(E l H)P(H) / P(E)Formula를 통해서 P(H)를 구할 수가 있다.==Many words == many evidence E, such as E1, E2, E3, E4….==수많은 word들이 있을것이다.만약 review에 N개의 word가 있다고했을 때==N개의 evidence를 가지고 있는거.==여기서 simple하지만 big한 assumption을 해준다.  Each word usage is independent to other word usages given a sentiment label.  Not true, but make things easy.  This means that E1,..En are independent events.이제 Bayes theorem을 이용해서Review가 positive 인지 negative인지,어떤 word가 들어갔을 때 review가 positive인 확률은 얼마인지 구할 수 있는것이다.winner님 블로그에서 보고 필기한 내용입니다.  2번째에서 공식이 근사화되고,마지막에 나온 Result를 보면 같음.]]></content>
      <categories>
        
          <category> Data Structure </category>
        
      </categories>
      <tags>
        
          <tag> Data Structure </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
