# C언어 이야기

1969년에 C언어로 UNIX OS를 개발했다. 근데 C언어가 세상에 나온건 1971~72년 시기이다. 뭔가 이상하다. 왜 언어보다 UNIX가 먼저 나온걸까? 왜냐면 B언어로 먼저 개발이 되었기 때문이다. B언어의 창시자는 Ken Thompson인데, 사실 B언어로 만들어진 UNIX는 작동이 잘 안됐다. 그래서 Dennis Ritchie가 이 프로젝트에 투입이 되는데, 기존의 B언어로는 어렵다고 판단, 새로운 언어인 C언어를 만들어서 UNIX의 80% 정도를 전면 재제작했다. 이때, B언어에서 C언어로 넘어가면서 달라진점이 무엇일까? C언어는 기존 B언어 대비 더 많은 자료형의 개념을 끌고왔다. (ex) 포인터) 이렇게 구현된 C언어로 UNIX를 완성시킨다. 뜬금없지만 이 이야기의 결론은 자료형이 중요하다는 것이다. 자료형 개념이 발전함으로써 UNIX가 완성되었으니까 말이다. 



C언어는 표준 스팩이 있다. 1992년대에는 C89였다. 근데 한국에서 가장많이 배우는 형식은 C95다. 근데 이 책은 C99 기준으로 썼다. 가장 최근(2015기준)에 나온 스팩은 C11이다. 스팩이라는걸 제대로 이해하려면 멀티스레드라던가 TLS같은 개념을 모르면 이해할 수가 없다. C99를 배웠는지 확인하는 방법은 무엇일까? 자료형중에 long long int가 있고, %lld, %a가 있는걸 아냐고 물어보면 된다. 그리고 inline함수도 있는데, 이게 성능하고 직결되기 때문에 아는게 좋다.

HelloWorld.c 같은걸 소스코드라고 부르고 이걸 High level 언어라고 한다. 여기서 High는 인간을 뜻하고, 컴퓨터가 CPU로 연산을 하는데, 이 소스코드를 컴퓨터가 알아먹을 수 있도록 바꿔야하는데, 컴퓨터가 알어먹을 수 있는 언어가 기계어다. 결국 이 소스코드를 기계어로 번역해야하는데, 이걸 해주는게 Compiler다. (Visual studio 2019) 

소스코드는 번역될때 두 스텝을 거친다. 첫번째는 `.obj`, 마지막 단계에서는 `.exe`로 된다. 크게본다면 c 소스코드는 설계도, `.obj`는 부품과 같다. 그리고 `.exe`는 완성품이다. 설계도가지고 부품만드는건 **Compiler**가 하고, 부품으로 완성품만드는건 **Linker**가 한다. 



## #include 전처리기 Preprocessor

먼저 알고가기) 소스코드 형식에는 `.c`랑 `.h`가 있는데 `.c`는 definition용, `.h`는 declaration용이다.

ex) #include <stdio.h>

ex) int main(void)

- 함수 선언 및 정의
- 함수이름 앞 Data type은 return type, 괄호안에는 parameter
- f(x) = y에서 f가 main, x가 paramter, y의 형식이 return type

항(item)<구문(statement)<함수(function)<프로그램(Program)



잡소리끝내고 Preprocessor가 무엇인가? 전처리기인데 뭐 전에 처리하는것이냐? 바로 Compile전에 처리를 하는 녀석이다. stdio.h에 printf함수가 들어가 있는데, 컴파일전에 stdio.h를 코드의 일부로 포함하여 컴파일하라는 의미이다.

프로그램이라는게 별게 아니다. 단순한 행동들을 연속되게 쭉 이어져나가는 흐름이 바로 프로그램이다. 



## 함수 Function

용어정리 꼭할것 하나의 예시

ex) main에서 printf를 call했을 때, main은 caller, printf는 callee가 된다. 

문자열이 보안사고를 가장 흔하게 일으키는데, 문자열은 본질이 배열이다. "문자배열"이라고 꼭 기억하자

callee는 caller에서 값을 반환

